<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake Playground</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script>
    function Try(elm)
    {
        //collect the text previous sample
        var source = elm.parentElement.previousElementSibling.innerText;

        var link = "./playground.html?code=" + encodeURIComponent(btoa(source)) +
            "&to=" + encodeURI("1") +
            "&options=" + encodeURI("");

        window.open(link, 'popup','width=800,height=600');
    }
// find-replace for this
// <button onclick="Try(this)">try</button> 
</script></head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<article>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Intro</a>
</li>
<li>
<a href="#toc_1">Static analyzer</a>
</li>
<li>
<a href="#toc_2">Include directories</a>
</li>
<li>
<a href="#toc_3">Command line</a>
<ul>
<li>
<a href="#toc_4">OPTIONS</a>
</li>
<li>
<a href="#toc_5">-fanalyzer</a>
</li>
<li>
<a href="#toc_6">-autoconfig</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">Output</a>
</li>
<li>
<a href="#toc_8">Setting the path</a>
</li>
<li>
<a href="#toc_9">Pre-defined macros</a>
<ul>
<li>
<a href="#toc_10">Pre-defined macros for MSVC compatibility</a>
</li>
<li>
<a href="#toc_11">Pre-defined macros for GCC compatibility</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">C99 Transformations</a>
<ul>
<li>
<a href="#toc_13">C99 restrict pointers</a>
</li>
<li>
<a href="#toc_14">C99 Variable-length array (VLA)</a>
</li>
<li>
<a href="#toc_15">C99 Flexible array members</a>
</li>
<li>
<a href="#toc_16">C99 static and type qualifiers in parameter array declarators</a>
</li>
<li>
<a href="#toc_17">C99 Complex and imaginary support</a>
</li>
<li>
<a href="#toc_18">C99 Universal character names (\u and \U)</a>
</li>
<li>
<a href="#toc_19">C99 Hexadecimal floating constants</a>
</li>
<li>
<a href="#toc_20">C99 Compound literals</a>
</li>
<li>
<a href="#toc_21">C99 Designated initializers</a>
</li>
<li>
<a href="#toc_22">C99 Line comments</a>
</li>
<li>
<a href="#toc_23">C99 inline functions</a>
</li>
<li>
<a href="#toc_24">C99 _Pragma preprocessing operator</a>
</li>
<li>
<a href="#toc_25">C99 __func__ predefined identifier</a>
</li>
<li>
<a href="#toc_26">C99 Variadic macros</a>
</li>
<li>
<a href="#toc_27">C99 _Bool</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">C11 Transformations</a>
<ul>
<li>
<a href="#toc_29">C11 _Static_assert</a>
</li>
<li>
<a href="#toc_30">C11 Anonymous structures and unions</a>
</li>
<li>
<a href="#toc_31">C11 _Noreturn</a>
</li>
<li>
<a href="#toc_32">C11 Thread_local/Atomic</a>
</li>
<li>
<a href="#toc_33">C11 type-generic expressions (_Generic)</a>
</li>
<li>
<a href="#toc_34">C11 u&#39; &#39; U&#39; &#39; character constants</a>
</li>
<li>
<a href="#toc_35">C11 u8&quot;literals&quot;</a>
</li>
<li>
<a href="#toc_36">C11 _Alignof or C23 alignof</a>
</li>
<li>
<a href="#toc_37">C11 _Alignas or C23 alignas</a>
</li>
</ul>
</li>
<li>
<a href="#toc_38">C23 Transformations</a>
<ul>
<li>
<a href="#toc_39">C23 _Decimal32, _Decimal64, and _Decimal128</a>
</li>
<li>
<a href="#toc_40">C23 static_assert / single-argument static_assert</a>
</li>
<li>
<a href="#toc_41">C23 u8 character prefix</a>
</li>
<li>
<a href="#toc_42">C23 No function declarators without prototypes</a>
</li>
<li>
<a href="#toc_43">C23 Improved Tag Compatibility</a>
</li>
<li>
<a href="#toc_44">C23 Unnamed parameters in function definitions</a>
</li>
<li>
<a href="#toc_45">C23 Digit separators</a>
</li>
<li>
<a href="#toc_46">C23 Binary literals</a>
</li>
<li>
<a href="#toc_47">C23 Introduce the nullptr constant</a>
</li>
<li>
<a href="#toc_48">C23 Make false and true first-class language features</a>
</li>
<li>
<a href="#toc_49">C23 {} empty initializer</a>
</li>
<li>
<a href="#toc_50">C23 auto</a>
</li>
<li>
<a href="#toc_51">C23 typeof / typeof_unqual</a>
</li>
<li>
<a href="#toc_52">C23 Improved Normal Enumerations</a>
</li>
<li>
<a href="#toc_53">C23 constexpr</a>
</li>
<li>
<a href="#toc_54">C23 Enhancements to Enumerations</a>
</li>
<li>
<a href="#toc_55">C23 Attributes</a>
</li>
<li>
<a href="#toc_56">C23 fallthrough attribute</a>
</li>
<li>
<a href="#toc_57">C23 deprecated attribute</a>
</li>
<li>
<a href="#toc_58">C23 maybe_unused attribute</a>
</li>
<li>
<a href="#toc_59">C23 nodiscard attribute</a>
</li>
<li>
<a href="#toc_60">C23 [[unsequenced]] and [[reproducible]]</a>
</li>
<li>
<a href="#toc_61">C23 __has_attribute</a>
</li>
<li>
<a href="#toc_62">C23 __has_include</a>
</li>
<li>
<a href="#toc_63">C23 #warning</a>
</li>
<li>
<a href="#toc_64">C23 #embed</a>
</li>
<li>
<a href="#toc_65">C23 #elifdef #elifndef</a>
</li>
<li>
<a href="#toc_66">C23 __VA_OPT__</a>
</li>
<li>
<a href="#toc_67">C23 BitInt(N))</a>
</li>
<li>
<a href="#toc_68">C23 Compound Literals with storage specifier</a>
</li>
<li>
<a href="#toc_69">C23 Variably-modified (VM) types</a>
</li>
</ul>
</li>
<li>
<a href="#toc_70">C2Y Transformations</a>
<ul>
<li>
<a href="#toc_71">Extension - defer</a>
</li>
<li>
<a href="#toc_72">Extension - if with initializer</a>
</li>
<li>
<a href="#toc_73">Extension typename on _Generic</a>
</li>
</ul>
</li>
<li>
<a href="#toc_74">Cake Extensions (Not in C23, C2Y)</a>
<ul>
<li>
<a href="#toc_75">Extension - try catch throw</a>
</li>
<li>
<a href="#toc_76">Extension Literal function - lambdas</a>
</li>
<li>
<a href="#toc_77">Extension #pragma dir</a>
</li>
<li>
<a href="#toc_78">Extension #pragma expand</a>
</li>
<li>
<a href="#toc_79">Type traits</a>
</li>
<li>
<a href="#toc_80">Extension - Ownership checks</a>
</li>
<li>
<a href="#toc_81">Extension assert statement</a>
</li>
</ul>
</li>
<li>
<a href="#toc_82">Versions</a>
</li>
</ul>
<h2 id="toc_0">Intro</h2>

<p>Cake works as an extension for MSVC on Windows and as an extension for GCC on Linux. This approach makes Cake useful in real and existing programs. </p>

<p>When applicable, Cake uses the same command line options of MSVC and GCC.</p>

<h2 id="toc_1">Static analyzer</h2>

<p>For static analyzer concepts of ownership and nullable pointers visit  <a href="ownership.html">ownership</a> </p>

<h2 id="toc_2">Include directories</h2>

<p>On Windows, Cake can be used on the command line similarly to MSVC.
Cake reads the <code>INCLUDE</code> variable, the same variable used by MSVC to locate the include directories.</p>

<p>Additionally, you can run Cake outside the Visual Studio command prompt by placing the file <code>cakeconfig.h</code> in 
the same directory or above the source files, and specifying the directories using #pragma dir.</p>

<p>If Cake doesn&#39;t find <code>cakeconfig.h</code> in the local directories, it will try to locate it in the 
same path as the Cake executable.</p>

<p>The <strong>-autoconfig</strong> option generates the <code>cakeconfig.h</code> automatically on both Windows and Linux.</p>

<p>To manually discover which directories are included, you can run the command:</p>

<pre><code>echo %INCLUDE%
</code></pre>

<p>at Visual Studio command prompt.</p>

<p>To find out what are the directories used by GCC type:</p>

<pre><code>echo | gcc -E -Wp,-v -
</code></pre>

<p>Sample of cakeconfig.h</p>

<pre><code class="language-c">
#ifdef __linux__
/*
   To find the include directories used my GCC type:   
   echo | gcc -E -Wp,-v -
*/
#pragma dir &quot;/usr/lib/gcc/x86_64-linux-gnu/11/include&quot;
#pragma dir &quot;/usr/local/include&quot;
#pragma dir &quot;/usr/include/x86_64-linux-gnu&quot;
#pragma dir &quot;/usr/include&quot;

#endif

#ifdef _WIN32
/*
   To find the include directories used my  MSVC,
   open Visual Studio Developer Commmand prompt and type:
   echo %INCLUDE%.
   Running Cake inside mscv command prompt uses %INCLUDE% automatically.
*/
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/14.38.33130/ATLMFC/include&quot;
#pragma dir &quot;C:/Program Files/Microsoft Visual Studio/2022/Professional/VC/Auxiliary/VS/include&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/ucrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/um&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/shared&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/winrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10/include/10.0.22000.0/cppwinrt&quot;
#pragma dir &quot;C:/Program Files (x86)/Windows Kits/NETFXSDK/4.8/include/um&quot;

#endif

</code></pre>

<p>Sample, project <code>cakeconfig.h</code></p>

<pre><code class="language-c">
//system includes...etc
#include &quot;C:\Program Files (x86)\cake\cakeconfig.h&quot;

//project extra includes
#pragma dir &quot;.\openssl\include&quot;

</code></pre>

<h2 id="toc_3">Command line</h2>

<pre><code>cake [options] source1.c source2.c ...

SAMPLES

    cake source.c
    Compiles source.c and outputs /out/source.c

    cake -target=C11 source.c
    Compiles source.c and outputs C11 code at /out/source.c

cake file.c -o file.cc &amp;&amp; cl file.cc
    Compiles file.c and outputs file.cc then use cl to compile file.cc

cake file.c -direct-compilation -o file.cc &amp;&amp; cl file.cc
    Compiles file.c and outputs file.cc for direct compilation then use cl to compile file.cc
  
</code></pre>

<h3 id="toc_4">OPTIONS</h3>

<h4>-I  (same as GCC and MSVC)</h4>

<p>Adds a directory to the list of directories searched for include files</p>

<h4>-no-output</h4>

<p>Cake will not generate output</p>

<h4>-D (same as GCC and MSVC)</h4>

<p>Defines a preprocessing symbol for a source file</p>

<h4>-E (same as GCC and MSVC)</h4>

<p>Copies preprocessor output to standard output</p>

<h4>-o name.c (same as GCC and MSVC)</h4>

<p>Defines the output name. used when we compile one file</p>

<h4>-remove-comments</h4>

<p>Remove all comments from the output file</p>

<h4>-direct-compilation</h4>

<p>output code as compiler sees it without macros.</p>

<h4>-target=standard</h4>

<p>Output target C standard (c89, c99, c11, c2x, cxx)
C99 is the default and C89 (ANSI C) is the minimum target</p>

<h4>-dump-tokens</h4>

<p>Output tokens before preprocessor</p>

<h4>-fi</h4>

<p>Format input (format before language conversion)</p>

<h4>-fo</h4>

<p>Format output (format after language conversion, result parsed again)</p>

<h4>-Wname -Wno-name  (same as GCC)</h4>

<p>Enables or disable warnings.
See <a href="warnings.html">warnings</a></p>

<h4>-disable-assert</h4>

<p>disable cake extension where assert is an statement. See extensions</p>

<h4>-showIncludes</h4>

<p>Causes the compiler to output a list of the include files. The option also displays nested include files, that is, the files included by the files that you include.</p>

<h4>-Wall</h4>

<p>Enables all warnings</p>

<h4>-sarif</h4>

<p>Generates sarif files
Sarif VS plugin <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer</a></p>

<h4>-msvc-output</h4>

<p>Output is compatible with visual studio IDE. We can click on the error message and IDE selects the line. </p>

<h3 id="toc_5">-fanalyzer</h3>

<p>This option enables an static analysis of program flow. This is required for some
ownership checks</p>

<h3 id="toc_6">-autoconfig</h3>

<p>Generates cakeconfig.h header. 
On Windows, it must be generated inside the Visual Studio Command Prompt to read the INCLUDE variable.
On Linux, it calls GCC with echo | gcc -v -E - 2&gt;&amp;1 and reads the output.</p>

<h2 id="toc_7">Output</h2>

<p>One directory called <strong>out</strong> is created keeping the same directory structure of the input files.</p>

<p>For instance:</p>

<pre><code class="language-c">cake c:\project\file1.c
</code></pre>

<p>output:</p>

<pre><code>  c:\project
  ├── file1.c
  ├── out
      ├── file1.c
</code></pre>

<p>More files..</p>

<pre><code>cake c:\project\file1.c c:\project\other\file2.c
</code></pre>

<p>output</p>

<pre><code>  c:\project
  ├── file1.c
  ├── other
  │   ├── file2.c
  ├── out
      ├── file1.c
      ├── other
          ├── file2.c
</code></pre>

<h2 id="toc_8">Setting the path</h2>

<p>This command is useful on windows to add the current path to system path. (This is not persistent)</p>

<pre><code>set PATH=%PATH%;%CD%
</code></pre>

<h2 id="toc_9">Pre-defined macros</h2>

<pre><code class="language-c"> #define __CAKE__ 202311L
 #define __STDC_VERSION__ 202311L
 #define __STDC_OWNERSHIP__ 1
</code></pre>

<p>The define <strong>STDC_OWNERSHIP</strong> indicates that the compiler suports owneship checks</p>

<h3 id="toc_10">Pre-defined macros for MSVC compatibility</h3>

<p><a href="https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros">https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170#standard-predefined-macros</a></p>

<h3 id="toc_11">Pre-defined macros for GCC compatibility</h3>

<p><a href="https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html">https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html</a></p>

<h2 id="toc_12">C99 Transformations</h2>

<p>C89 is the minimum target.</p>

<p>However the idea if C89 target is NOT support very old compilers, but generate code that can be compiled with C++.</p>

<p>C89 
<a href="https://port70.net/%7Ensz/c/c89/c89-draft.html">https://port70.net/~nsz/c/c89/c89-draft.html</a></p>

<p>C99
<a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf</a></p>

<pre><code class="language-c"> #define __STDC_VERSION__ 199901L  //C99
</code></pre>

<h3 id="toc_13">C99 restrict pointers</h3>

<pre><code class="language-c">void f(const char* restrict s);
</code></pre>

<p>Becomes in C89</p>

<pre><code class="language-c">void f(const char* /*restrict*/ s);
</code></pre>

<p>N448</p>

<h3 id="toc_14">C99 Variable-length array (VLA)</h3>

<p>The idea is not implement variable length arrays with automatic storage duration. (__STDC_NO_VLA__ 1). </p>

<p>But there are other uses of VLA.</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int n = 2;
    int m = 3;
    int (*p)[n][m] = malloc(sizeof * p);

    printf(&quot;%zu\n&quot;, sizeof(*p));

    free(p);
}

</code></pre>

<p>Becomes C89 (not implemented)</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int n = 2;
    int m = 3;
    
    /*these variables are created to store the dynamic size*/
    const int vla_1_n = n;
    const int vla_1_m = m;
    
    int (*p)[n][m] = malloc((vla_1_n*vla_1_m)*sizeof(int));

    printf(&quot;%zu\n&quot;, (vla_1_n*vla_1_m)*sizeof(int));

    free(p);
}

</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n683.htm</a></p>

<h3 id="toc_15">C99 Flexible array members</h3>

<pre><code class="language-c">struct s {
    int n;
    double d[]; 
};
</code></pre>

<p>Becomes (not implemented)</p>

<pre><code class="language-c">struct s {
    int n;
    double d[]; //?
};
</code></pre>

<h3 id="toc_16">C99 static and type qualifiers in parameter array declarators</h3>

<pre><code class="language-c">#include &lt;stdlib.h&gt;

void F(int a[static 5]) {
}

int main() 
{    
    F(0);
    F(NULL);
    F(nullptr);

    int a[] = {1, 2, 3};    
    F(a);//error
    
    int b[] = { 1, 2, 3 , 4, 5};
    F(b); 

    int c[] = { 1, 2, 3 , 4, 5, 6};
    F(c);
}

</code></pre>

<p><code>static</code> is removed when target is &lt; c99.</p>

<p>Cakes verifies that the argument is an array of with equal or more elements.</p>

<p>Cakes extend this check for arrays without static as well.</p>

<h3 id="toc_17">C99 Complex and imaginary support</h3>

<p>Not implemented</p>

<h3 id="toc_18">C99 Universal character names (\u and \U)</h3>

<p>TODO</p>

<h3 id="toc_19">C99 Hexadecimal floating constants</h3>

<pre><code class="language-c">double d = 0x1p+1;
</code></pre>

<p>Becomes in C89</p>

<pre><code class="language-c">double d = 2.000000;
</code></pre>

<p>Cake converts the hexadecimal floating to decimal
floating point using strtod then snprintf.
That means this conversion is not precise.</p>

<h3 id="toc_20">C99 Compound literals</h3>

<pre><code class="language-c">struct s {
  int i;
};

int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    q = p, p = &amp; ((struct s) { j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<p>Becomes in C89 (not implemented yet)</p>

<pre><code class="language-c">struct s {
  int i;
};
int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    struct s compound_literal_1 = { j++ };
    q = p, p = &amp; compound_literal_1;
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<p>N716
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n716.htm</a></p>

<h3 id="toc_21">C99 Designated initializers</h3>

<pre><code class="language-c"> int main()
 {
  int a[6] = {[4] = 29, [2] = 15 };

  struct point { int x, y; };

  struct point p = { .y = 2, .x = 3 }
 }

</code></pre>

<p>Becomes C89 (not implemented yet)</p>

<pre><code class="language-c">int main()
{
  int a[6] = { 0, 0, 15, 0, 29, 0 };
  struct point { int x, y; };
  struct point p = { 3, 2 }
}
</code></pre>

<p>N494
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n494.pdf</a></p>

<h3 id="toc_22">C99 Line comments</h3>

<p>When compiling to C89 line comments are converted to 
/<em>comments</em>/.</p>

<h3 id="toc_23">C99 inline functions</h3>

<p>TODO
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n741.htm</a></p>

<h3 id="toc_24">C99 _Pragma preprocessing operator</h3>

<p>TODO </p>

<h3 id="toc_25">C99 __func__ predefined identifier</h3>

<p>Parsed. C89 conversion not implemented yet.</p>

<h3 id="toc_26">C99 Variadic macros</h3>

<p>We need to expand the macro when comping to C89.
This is covered by # macro expand.</p>

<p>Sample:</p>

<pre><code class="language-c">
#include &lt;stdio.h&gt;

#define debug(...) fprintf(stderr, __VA_ARGS__)
#pragma expand debug

int main()
{
  int x = 1;
  debug(&quot;X = %d\n&quot;, 1);
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

#define debug(...) fprintf(stderr, __VA_ARGS__)
#pragma expand debug

int main()
{
  int x = 1;
  fprintf(stderr, &quot;X = %d\n&quot;, 1);
}
</code></pre>

<p>I am considering to mark the debug macro to be expanded automatically
if __VA_ARGS__ is used. Then pragma expand will not be necessary.</p>

<p>N707
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n707.htm</a></p>

<h3 id="toc_27">C99 _Bool</h3>

<p>When compiling to C89 _Bool is replaced by unsigned char.</p>

<pre><code class="language-c">//line comments
int main(void)
{
    _Bool b = 1;
    return 0;
}
</code></pre>

<p>Becomes in C89</p>

<pre><code class="language-c">/*line comments*/
int main(void)
{
    unsigned char b = 1;
    return 0;
}
</code></pre>

<p>Alternative design - typedef ?
Considering C23 has bool and the objective of C89 version is to have a version that compiles in C++ the best option would be use bool, true, false.</p>

<h2 id="toc_28">C11 Transformations</h2>

<pre><code class="language-c">#define __STDC_VERSION__ 201112L //C11
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf</a></p>

<p><a href="https://files.lhmouse.com/standards/ISO%20C%20N2176.pdf">https://files.lhmouse.com/standards/ISO%20C%20N2176.pdf</a></p>

<h3 id="toc_29">C11 _Static_assert</h3>

<p>When compiling to versions &lt; C11 _Static_Assert is removed.</p>

<h3 id="toc_30">C11 Anonymous structures and unions</h3>

<p>TODO</p>

<h3 id="toc_31">C11 _Noreturn</h3>

<pre><code class="language-c">_Noreturn void f () {
  abort(); // ok
}
</code></pre>

<p>Becomes in &lt; C11</p>

<pre><code class="language-c">/*[[noreturn]]*/ void f () {
  abort(); // ok
}
</code></pre>

<p>C23 attribute [[noreturn]] provides similar semantics. The _Noreturn function specifier is an obsolescent feature</p>

<h3 id="toc_32">C11 Thread_local/Atomic</h3>

<p>Parsed but not transformed.</p>

<h3 id="toc_33">C11 type-generic expressions (_Generic)</h3>

<p>When compiling to C99, C89 we keep the expression that matches the type.</p>

<p>For instance:</p>

<p>The expression that matches the argument 1.0 is <strong>cbrtl</strong>.</p>

<p>The result of _Generic in C99 will be cbrtl. Because this is inside a macro we need to tell the transpiler to expand that macro using pragma expand.</p>

<p>N1441
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1441.htm</a></p>

<pre><code class="language-c">#include &lt;math.h&gt;

#define cbrt(X) _Generic((X),    \
                  double: cbrtl, \
                  float: cbrtf , \
                  default: cbrtl \
              )(X)

#pragma expand cbrt

int main(void)
{
    cbrt(1.0);
}
</code></pre>

<p>Becomes in C99, C89</p>

<pre><code class="language-c">#include &lt;math.h&gt;

#define cbrt(X) _Generic((X),    \
                  double: cbrtl, \
                  float: cbrtf , \
                  default: cbrtl \
              )(X)

#pragma expand cbrt

int main(void)
{
     cbrtl(1.0);
}
</code></pre>

<h3 id="toc_34">C11 u&#39; &#39; U&#39; &#39; character constants</h3>

<p>//TODO</p>

<pre><code class="language-c"> int i = U&#39;ç&#39;;
 int i2 = u&#39;ç&#39;;
</code></pre>

<p>Becomes in &lt; C11</p>

<pre><code class="language-c"> //TODO
 int i = ((unsigned int)132);
 int i2 = ((short)121);
</code></pre>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_35">C11 u8&quot;literals&quot;</h3>

<p>u8 literals are converted to escape sequences.</p>

<pre><code class="language-c">char * s1 = u8&quot;maçã&quot;;
char * s2 = u8&quot;maca&quot;;
</code></pre>

<p>Becomes in &lt; C11</p>

<pre><code class="language-c">char * s1 = &quot;ma\xc3\xa7\xc3\xa3&quot;;
char * s2 = &quot;maca&quot;;
</code></pre>

<p>N1488
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1488.htm</a></p>

<p>Important: Cake assume source is utf8 encoded.</p>

<h3 id="toc_36">C11 _Alignof or C23 alignof</h3>

<p>When compiling to C99 or C89 it is replaced by the equivalent constant.</p>

<pre><code class="language-c"> int main()
 {
   int align = alignof(int);
 }
</code></pre>

<p>Becomes &lt; C11</p>

<pre><code class="language-c"> int main()
 {
   int align = 4;
 }
</code></pre>

<h3 id="toc_37">C11 _Alignas or C23 alignas</h3>

<p>Not implemented. </p>

<h2 id="toc_38">C23 Transformations</h2>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n3096.pdf</a></p>

<pre><code class="language-c">#define __STDC_VERSION__ 201710L  //C17
#define __STDC_VERSION__ 202311L  //C23
</code></pre>

<h3 id="toc_39">C23 _Decimal32, _Decimal64, and _Decimal128</h3>

<p>Not implemented.</p>

<h3 id="toc_40">C23 static_assert / single-argument static_assert</h3>

<p>In C23 static_assert is a keyword and the text message is optional.</p>

<p>Whe comping to C11, static_assert is replaced by it C11 version _Static_assert. If the static_assert has only one argument the text becomes &quot;error&quot;.</p>

<p>N1330
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1330.pdf</a></p>

<pre><code class="language-c">int main()
{    
    static_assert(1 == 1, &quot;error message&quot;);
    static_assert(1 == 1);
}

</code></pre>

<p>Becomes in C11</p>

<pre><code class="language-c">int main()
{    
    _Static_assert(1 == 1, &quot;error message&quot;);
    _Static_assert(1 == 1, &quot;error&quot;);
}
</code></pre>

<p>In &lt; C11 it is replaced by one space;</p>

<h3 id="toc_41">C23 u8 character prefix</h3>

<p>Not implemented yet.
<a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2418.pdf</a></p>

<h3 id="toc_42">C23 No function declarators without prototypes</h3>

<p><a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2841.htm</a></p>

<pre><code class="language-c">int main(){
    func(); //this is an error in C23
}
</code></pre>

<p>See also Remove support for function definitions with identifier lists  </p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2432.pdf</a></p>

<h3 id="toc_43">C23 Improved Tag Compatibility</h3>

<p>Not implemented yet.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf</a></p>

<pre><code class="language-c">struct foo { int a; } p;
void bar(void)
{
  struct foo { int a; } q;
  q = p;
}
</code></pre>

<p>Becomes &lt; C23</p>

<pre><code class="language-c">struct foo { int a; } p;
void bar(void)
{
  struct foo  q;
  q = p;
}
</code></pre>

<h3 id="toc_44">C23 Unnamed parameters in function definitions</h3>

<pre><code class="language-c">int f(int );

int f(int ) {
}
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2480.pdf</a></p>

<p>Cake should add a dummy name when generating C &lt; 23. (Not implemented yet)</p>

<h3 id="toc_45">C23 Digit separators</h3>

<pre><code class="language-c">int main()
{
    int a = 1000&#39;00;
}
</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">int main()
{
    int a = 100000;
}  
</code></pre>

<p>This transformation happens at token level, so even preprocessor and inactive blocks are transformed.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2626.pdf</a></p>

<h3 id="toc_46">C23 Binary literals</h3>

<pre><code class="language-c">#define X  0b1010

int main()
{
    int a = X;
    int b = 0B1010;
}

</code></pre>

<p>Becomes in C11, C99, C89</p>

<pre><code class="language-c">#define X  0xa

int main()
{
    int a = X;
    int b = 0xa;
}

</code></pre>

<p>This transformation happens at token level, so even preprocessor and inactive blocks are transformed.</p>

<h3 id="toc_47">C23 Introduce the nullptr constant</h3>

<pre><code class="language-c">
int main()
{
  void * p = nullptr;
  auto p2 = nullptr;
  typeof(nullptr) p3 = nullptr;
}

</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code>int main()
{
  void * p = ((void*)0);
  void  * p2 = ((void*)0);
  void  * p3 = ((void*)0);
}

</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3042.htm</a></p>

<h3 id="toc_48">C23 Make false and true first-class language features</h3>

<p>When compiling to C89 bool is replaced by unsigned char,  true by 1 and false by 0. </p>

<p>When compiling to C99 and C11 bool is replaced with <strong>_Bool</strong>, true is replaced with <code>((_Bool)1)</code> 
and false with <strong>(_Bool)0)</strong></p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2935.pdf</a></p>

<h3 id="toc_49">C23 {} empty initializer</h3>

<pre><code class="language-c">
int main()
{
    struct X {
        int i;
    } x = {};

    x = (struct X) {};

    struct Y
    {
        struct X x;
    } y = { {} };
}  

</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">
int main()
{
    struct X {
        int i;
    } x = {0};

    x = (struct X) {0};

    struct Y
    {
        struct X x;
    } y = { {0} };
}

</code></pre>

<blockquote>
<p>Note: Cake code is 100% equivalent because it does not make padding bit zero.</p>
</blockquote>

<h3 id="toc_50">C23 auto</h3>

<pre><code class="language-c">static auto a = 3.5;
auto p = &amp;a;

double A[3] = { 0 };
auto pA = A;
auto qA = &amp;A;
</code></pre>

<p>Becomes &lt; C23</p>

<pre><code class="language-c">static double a = 3.5;
double  * p = &amp;a;

double A[3] = { 0 };
double  * pA = A;
double  (* qA)[3] = &amp;A;
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3007.htm</a></p>

<h3 id="toc_51">C23 typeof / typeof_unqual</h3>

<pre><code class="language-c">
#define SWAP(a, b) \
  do {\
    typeof(a) temp = a; a = b; b = temp; \
  } while (0)

#pragma expand SWAP

int main()
{
    /*simple case*/
    int a = 1;
    typeof(a) b = 1;

    /*pay attention to the pointer*/
    typeof(int*) p1, p2;

    /*let&#39;s expand this macro and see inside*/
    SWAP(a, b);

    /*for anonymous structs we insert a tag*/
    struct { int i; } x;
    typeof(x) x2;
    typeof(x) x3;

   /*Things get a little more complicated*/
   int *array[2];
   typeof(array) a1, a2;
   
   typeof(array) a3[3];
   typeof(array) *a4[4];

   /*abstract declarator*/
   int k = sizeof(typeof(array));

   /*new way to declare pointer to functions?*/
   typeof(void (int)) * pf = NULL;
}

</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">

#define SWAP(a, b) \
  do {\
    typeof(a) temp = a; a = b; b = temp; \
  } while (0)

#pragma expand SWAP

int main()
{
    /*simple case*/
    int a = 1;
    int  b = 1;

    /*pay attention to the pointer*/
    int  *p1,  *p2;

    /*let&#39;s expand this macro and see inside*/
     do {int temp = a; a = b; b = temp; } while (0);

    /*for anonymous structs we insert a tag*/
    struct _anonymous_struct_0 { int i; } x;
    struct _anonymous_struct_0  x2;
    struct _anonymous_struct_0  x3;

   /*Things get a little more complicated*/
   int *array[2];
   int  *a1[2],  *a2[2];
   
   int  *(a3[3])[2];
   int  *(*a4[4])[2];

   /*abstract declarator*/
   int k = sizeof(int*[2]);
   
   /*new way to declare pointer to functions?*/
   void  (*pf)(int) = ((void*)0);
}
</code></pre>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2927.htm</a>
<a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2930.pdf</a></p>

<h3 id="toc_52">C23 Improved Normal Enumerations</h3>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n3029.htm</a></p>

<h3 id="toc_53">C23 constexpr</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3018.htm</a></p>

<p>Cake convert constexpr declarator with a cast and the value.
addressof constexpr declarator is not implemented.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

constexpr int c = 123;

int a[c];

constexpr double PI = 3.14;

static_assert(PI + 1 == 3.14 + 1.0);

int main()
{
   printf(&quot;%f&quot;, PI);
}

</code></pre>

<p>Becomes &lt; C23</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

const int c = 123;

int a[((int)123)];

const double PI = 3.14;

int main()
{
   printf(&quot;%f&quot;, ((double)3.140000));
}
</code></pre>

<p>TODO: Maybe suffix like ULL etc makes the code easier to read.</p>

<h3 id="toc_54">C23 Enhancements to Enumerations</h3>

<pre><code class="language-c">enum X : short {
  A
};

int main() {
   enum X x = A;   
}
</code></pre>

<p>Becomes &lt; C23</p>

<pre><code class="language-c">enum X {
  A
};

int main() {
   short x = ((short)A);   
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3030.htm</a></p>

<h3 id="toc_55">C23 Attributes</h3>

<p>Conversion to &lt; C23  will just remove the attributes.</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf</a>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2554.pdf</a></p>

<p>Related: Standard Attributes in C and C++ - Timur Doumler - ACCU 2023
<a href="https://youtu.be/EpAEFjbTh3I">https://youtu.be/EpAEFjbTh3I</a></p>

<h3 id="toc_56">C23 fallthrough attribute</h3>

<p>Not implemented</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2408.pdf</a></p>

<h3 id="toc_57">C23 deprecated attribute</h3>

<p>Partially implemented
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2334.pdf</a></p>

<h3 id="toc_58">C23 maybe_unused attribute</h3>

<p>Implemented
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2270.pdf</a></p>

<h3 id="toc_59">C23 nodiscard attribute</h3>

<p>Partially implemented</p>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2267.pdf</a></p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf">https://open-std.org/JTC1/SC22/WG14/www/docs/n2448.pdf</a></p>

<h3 id="toc_60">C23 [[unsequenced]] and [[reproducible]]</h3>

<p>Parsed.</p>

<p><a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm">https://open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm</a></p>

<h3 id="toc_61">C23 __has_attribute</h3>

<p>Its is implemented in cake.
Conversion &lt; C23 not defined. Maybe a define.</p>

<h3 id="toc_62">C23 __has_include</h3>

<pre><code class="language-c">
#if __has_include(&lt;stdio.h&gt;)
#warning  YES
#endif

#if __has_include(&lt;any.h&gt;)
#warning  YES
#else
#warning  NO
#endif

</code></pre>

<p>Its is implemented in cake.
Conversion &lt; C23 not defined. Maybe a define.</p>

<h3 id="toc_63">C23 #warning</h3>

<p>When compiling to versions &lt; 23 it is commented out.</p>

<pre><code class="language-c">int main()
{
  #warning my warning message  
}
</code></pre>

<p>When target &lt; C23 becomes</p>

<pre><code class="language-c">int main()
{
  /* #warning my warning message */  
}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2686.pdf</a></p>

<h3 id="toc_64">C23 #embed</h3>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #embed &quot;stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);
}
</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">
https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3017.htm

#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
    35,112,114,/*lot more here ...*/ 13,10
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);
}

</code></pre>

<p>I am considering add an option to generate a file with a suffix
like &quot;embed_stdio.h&quot; then the equivalent code will be:</p>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #include &quot;embed_stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);
}
</code></pre>

<h3 id="toc_65">C23 #elifdef #elifndef</h3>

<pre><code class="language-c">#define Y

#ifdef X
#define VERSION 1
#elifdef  Y
#define VERSION 2
#else
#define VERSION 3
#endif
</code></pre>

<p>Becomes &lt; C23</p>

<pre><code class="language-c">#define Y

#ifdef X
#define VERSION 1
#elif defined   Y
#define VERSION 2
#else
#define VERSION 3
#endif

</code></pre>

<h3 id="toc_66">C23 __VA_OPT__</h3>

<p>Implemented.
Requires #pragma expand. (TODO make the expansion automatic)</p>

<pre><code class="language-c">
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP

/*maybe this could be automatic if &lt;C23*/
#pragma expand F
#pragma expand G
#pragma expand SDEF
#pragma expand EMP

void f(int i, ...) {}


int main()
{
  int a = 1;
  int b = 2;
  int c = 3;
  
  F(a, b, c);
  F();
  F(EMP);
  G(a, b, c);
  G(a, );
  G(a);

}

</code></pre>

<p>Becomes in &lt; C23</p>

<pre><code class="language-c">
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
#define EMP

/*maybe this could be automatic if &lt;C23*/
#pragma expand F
#pragma expand G
#pragma expand SDEF
#pragma expand EMP

void f(int i, ...) {}


int main()
{
  int a = 1;
  int b = 2;
  int c = 3;
  
   f(0, a, b, c);
   f(0 );
   f(0);
   f(0, a, b, c);
   f(0, a );
   f(0, a );

}
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3033.htm</a></p>

<h3 id="toc_67">C23 BitInt(N))</h3>

<p>Not implemented</p>

<h3 id="toc_68">C23 Compound Literals with storage specifier</h3>

<p>Not implemented yet.</p>

<pre><code class="language-c">void F(int *p){}

int main()
{
   F((static int []){1, 2, 3, 0})
}
</code></pre>

<p>Becomes (not implemented yet)</p>

<pre><code class="language-c">void F(int *p){}

int main()
{
    static int _compound_1[] = {1, 2, 3, 0};
    F(_compound_1);
x   }
</code></pre>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3038.htm</a></p>

<h3 id="toc_69">C23 Variably-modified (VM) types</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2778.pdf</a></p>

<h2 id="toc_70">C2Y Transformations</h2>

<h3 id="toc_71">Extension - defer</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3199.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3199.htm</a></p>

<p><em>defer</em> will call the defer statement before the block exit at inverse order of declaration.</p>

<pre><code>     defer-statement:
        defer secondary-block
</code></pre>

<p>For instance:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  do {
     FILE* f = fopen(&quot;in.txt&quot;, &quot;r&quot;);
     if (f == NULL) break;
     defer fclose(f);

     FILE* f2 = fopen(&quot;out.txt&quot;, &quot;w&quot;);
     if (f2 == NULL) break;
     defer fclose(f2);
     //...    
  }
  while(0);
}
</code></pre>

<p>Becomes in C23, C11, C99, C89</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  do {
     FILE* f = fopen(&quot;in.txt&quot;, &quot;r&quot;);
     if (f == ((void*)0)) break;

     FILE* f2 = fopen(&quot;out.txt&quot;, &quot;w&quot;);
     if (f2 == ((void*)0)) {  fclose(f); break;}
     
     fclose(f2); fclose(f);
   }
  while(0);
}
</code></pre>

<h3 id="toc_72">Extension - if with initializer</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3196.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3196.htm</a></p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
   int size = 10;
   if (FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;); f)
   {
     /*...*/
     fclose(f);
   }
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
   int size = 10;
   {FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;);if ( f)
   {
     /*...*/
     fclose(f);
   }}
}
</code></pre>

<p>C++ proposal
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html</a></p>

<h3 id="toc_73">Extension typename on _Generic</h3>

<p><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3260.pdf</a></p>

<pre><code class="language-c"> int main()
{
    const int * const p;
    static_assert(_Generic(p, const int *: 1));

    /*extension*/
    static_assert(_Generic(int, int : 1));
    static_assert(_Generic(typeof(p), const int * const: 1));
}
</code></pre>

<h2 id="toc_74">Cake Extensions (Not in C23, C2Y)</h2>

<h3 id="toc_75">Extension - try catch throw</h3>

<pre><code>   try-statement:
      try secondary-block
      try secondary-block catch secondary-block   
</code></pre>

<pre><code>jump-statement:
  throw;
</code></pre>

<p>try catch is a external block that we can jump off.</p>

<p>try catch is a <strong>LOCAL jump</strong> this is on purpose not a limitation.</p>

<p>catch block is optional.</p>

<pre><code class="language-c">try
{
   for (int i = 0 ; i &lt; 10; i++) {
      for (int j = 0 ; j &lt; 10; j++) {
        ... 
        if (error) throw;
        ...
      }
   }
}
catch
{
}
</code></pre>

<h3 id="toc_76">Extension Literal function - lambdas</h3>

<p>Lambdas without capture where implemented using a syntax similar of compound literal for function pointer.</p>

<p>Lambdas are the most complex code transformation so far because sometimes function scope types needs to be transformed to file scope. This is important because manual lambda capture
is something we want to use in function scope.</p>

<p>For instance:</p>

<pre><code class="language-c">extern char* strdup(const char* s);
void create_app(const char* appname)
{
  struct capture {
     char * name;
  } capture = { .name = strdup(appname) };

  (void (void* p)) {
    struct capture* capture = p;    
  }(&amp;capture); 
}
</code></pre>

<p>Because struct capture was in function scope and the lambda function will be created at file scope the type <strong>struct capture</strong> had to be moved from function scope to file scope.</p>

<pre><code class="language-c">extern char* strdup(const char* s);

struct _capture0 {
     char * name;
  };
  
void _lit_func_0(void *p) {
    struct _capture0* capture = p;    
  }

void create_app(const char* appname)
{
  struct _capture0  capture = { .name = strdup(appname) };
  _lit_func_0(&amp;capture);  
}
</code></pre>

<h3 id="toc_77">Extension #pragma dir</h3>

<pre><code class="language-c">#pragma dir &quot;C:/Program Files (x86)/Windows Kits/10//include/10.0.22000.0/cppwinrt&quot;
</code></pre>

<p>pragma dir makes the preprocessor include the directory when searching for includes.</p>

<h3 id="toc_78">Extension #pragma expand</h3>

<p>pragma expand tells the C back-end to not hide macro expansions. This is necessary when
the compiler makes changes inside the macro code.</p>

<p>Sample:</p>

<pre><code class="language-c">
#define SWAP(a, b) \
    do { \
      typeof(a) temp = a; a = b; b = temp; \
    } while(0)

#pragma expand SWAP

int main()
{
   int a = 1;
   typeof(a) b = 2;
   SWAP(a, b);
   return 1;
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">#define SWAP(a, b) \
    do { \
      typeof(a) temp = a; a = b; b = temp; \
    } while(0)

#pragma expand SWAP

int main()
{
   int a = 1;
   int b = 2;
    do {int temp = a; a = b; b = temp; } while(0);
   return 1;
}

</code></pre>

<h3 id="toc_79">Type traits</h3>

<p>We have some compile time functions to infer properties of types.</p>

<pre><code class="language-c">
_is_char()
The three types char, signed char, and unsigned char are collectively called the character types.

_is_pointer
Pointer to object or function

_is_array
Array type

_is_function
A function type describes a function with specified return type. 

_is_floating_point
float, double, and long double return true

_is_integral
The standard signed integer types and standard unsigned integer types are collectively called the
standard integer types;

_is_arithmetic
Integer and floating types are collectively called arithmetic types. 

_is_scalar
Arithmetic types, pointer types, and the nullptr_t type are collectively called scalar types

</code></pre>

<h3 id="toc_80">Extension - Ownership checks</h3>

<p>See <a href="ownership.html">ownership</a></p>

<h3 id="toc_81">Extension assert statement</h3>

<p>In cake assert is an statement. The reason is because it works as tips for flow analysis 
and these checks are checked in runtime in debug bugs.
The different is that assert is also evaluated in release.
That means the expression must be valid.
To disable this extension use -disable-assert options. </p>

<p>When cake reads GCC MSVC headers it overrides the macro assert to match the cake
assert statement.</p>

<h2 id="toc_82">Versions</h2>
</article></body></html>