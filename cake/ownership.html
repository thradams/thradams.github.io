<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake Playground</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<article>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Owner Objects</a>
<ul>
<li>
<a href="#toc_1">Non pointer Owner Objects</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">View Objects</a>
</li>
<li>
<a href="#toc_3">Deleting Owner Pointers</a>
</li>
<li>
<a href="#toc_4">Copying a owner pointer to a obj_owner pointer</a>
</li>
<li>
<a href="#toc_5">Static analysis</a>
</li>
<li>
<a href="#toc_6">Ownership Feature Strategy (Inspired by stdbool.h)</a>
</li>
</ul>
<h2 id="toc_0">Owner Objects</h2>

<p>An <strong>owner object</strong> is an object referencing another object and managing its lifetime.</p>

<p>The most common type of owner objects are pointers, often referred to as <strong>owner pointers</strong>. An owner pointer is created with the qualifier owner, as illustrated in Listing 1:</p>

<h5>Listing 1 - Owner Pointer to FILE</h5>

<pre><code class="language-c">FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
if (f)
    fclose(f);
</code></pre>

<p><strong>Note:</strong> The owner qualifier is actually a macro and the real keyword is _Owner. Being a macro have an advantage that it can be defined to nothing for compilers that don&#39;t implement ownership. For this job we can include ownership.h, but these details will be omitted for now.</p>

<p><strong>Rule</strong>: An <strong>owner object</strong> is always the unique owner of the referenced object.</p>

<p><strong>Rule</strong>: When owner objects are copied the ownership is transfered.</p>

<p>For example, in Listing 2, the ownership of the owner pointer <code>f</code> is transferred to <code>f2</code>:</p>

<h5>Listing 2 - Assignment of Owner Objects is a Move</h5>

<pre><code class="language-c">    FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
    FILE *owner f2 = f; /*MOVED*/
    if (f2)
    fclose(f2);
</code></pre>

<p><strong>Rule:</strong> Before the end of its lifetime, owner objects must transfer the ownership of the objects they own.</p>

<p>Invoking a function is analogous to assignment, resulting in the object’s transfer of ownership. In the previous examples, we were already transferring ownership of the owner pointer to the close function, which is declared as follows:</p>

<h5>Listing 3 - Declaration of close</h5>

<pre><code class="language-c">void close(FILE *owner p);
</code></pre>

<h3 id="toc_1">Non pointer Owner Objects</h3>

<p>We can have other types of <strong>owner objects</strong>. For instance, Berkeley sockets use an integer to identify the socket, as shown in listing 4:</p>

<h5>Listing 4 - Non-Pointer owners objects</h5>

<pre><code class="language-c"> owner int server_socket =
     socket(AF_INET, SOCK_STREAM, 0);
 /*...*/
 close(server_socket);
</code></pre>

<h2 id="toc_2">View Objects</h2>

<p>A <strong>view object</strong> is an object referencing another object without managing its lifetime. The lifetime of the referenced object must be bigger than the lifetime of the view object.</p>

<p>The most common view objects are pointers called <strong>view pointers</strong>. </p>

<p>The view qualifier is not necessary for pointers, since it&#39;s the default behavior. When an owner object is copied to a view object, the ownership is not transferred, as shown in Listing 5:</p>

<h5>Listing 5 - Calling Function with View Parameters</h5>

<pre><code class="language-c">void use_file(FILE *f) {}

int main() {
    FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
    if (f) {
        use_file(f); /*NOT MOVED*/
        fclose(f);
    }
}
</code></pre>

<p>When a <strong>view</strong> qualifier is used in structs, it makes all members as view objects. Listing 6.</p>

<h5>Listing 6 - A view parameter</h5>

<pre><code class="language-c">struct X {   
  char *owner text;   
};  

void f(view struct X x) { /*...*/ }  

int main() {
    struct X x = {};
    f(x); /*NOT MOVED*/    
    free(x.text);
}
</code></pre>

<h2 id="toc_3">Deleting Owner Pointers</h2>

<p><strong>Owner pointers</strong> take on the responsibility of owning the pointed object and its associated memory, treating them as distinct entities. A common practice is to implement a delete function to release both resources, as illustrated in Listing 7:</p>

<h5>Listing 7 - Implementing the delete function</h5>

<pre><code class="language-c">struct X { 
  char *owner text; 
};
void x_delete(struct X *owner p) {
  if (p) {
    /*releasing the object*/ 
    free(p-&gt;text);
    
    /*releasing the memory*/ 
    free(p); 
  }
}
int main() {
  struct X * owner pX = calloc( 1, sizeof * pX);
  if (pX) {
    /*...*/;
    x_delete( pX); 
  }
}
</code></pre>

<p>When the object is created on the stack, we can implement a destructor, as shown in Listing 8:</p>

<h5>Listing 8 - Implementing a destructor</h5>

<pre><code class="language-c">struct X {
    char *owner text;
};  
void x_destroy(struct X x) {
    free(x.text);
}  
int main() {
    struct X x = {};
    /*...*/
    x_destroy(x); /*x is moved*/
}
</code></pre>

<p>However in C, structs are typically passed by pointer rather than by value. To transfer the ownership of an owner object to a pointer, I introduce a new qualifier, <strong>obj_owner</strong>. </p>

<p>A pointer qualified with <strong>obj_owner</strong> is the owner of the pointed object but not responsible for managing its memory.</p>

<p>Listing 9 illustrates how to implement a destructor using a obj_owner pointer parameter.</p>

<h5>Listing 9 - Implementing a destructor using obj_owner</h5>

<pre><code class="language-c">struct X {
    char *owner text;
};
void x_destroy(struct X *obj_owner x) {
    free(x-&gt;text);
}
int main() {
    struct X x = {};
    /*more code*/
    x_destroy(&amp;x); /*x is moved*/
}
</code></pre>

<p>In order to prevent moving from a non owner object, only <code>address of expressions</code> to <code>obj_owner</code> are allowed. For instance, listing 10 shows we cannot move a view pointer.</p>

<h5>Listing 10 - Non address of expression or owner pointer.</h5>

<pre><code class="language-c">struct X {
 struct Y * p;
};

void y_destroy(struct Y * obj_owner p);

void f(struct X * x) {
  y_destroy(x-&gt;y); //ERROR
}
</code></pre>

<h2 id="toc_4">Copying a owner pointer to a obj_owner pointer</h2>

<p>We can copy an owner pointer to an <strong>obj_owner</strong> pointer. In this scenario, only the ownership of the pointed object is transferred, not the memory ownership. Listing 11 illustrates how we can use <code>x_destroy</code> in the implementation of <code>x_delete</code>.</p>

<h5>Listing 11 - Using <code>x_destroy</code> to implement <code>x_delete</code></h5>

<pre><code class="language-c">struct X {
  char *owner text; 
};

void x_destroy(struct X *obj_owner x) {
  free(x-&gt;text); 
}

void x_delete(struct X *owner p) { 
  if (p) {
    x_destroy(p); /* *p is moved*/
    free(p);
  }
}

int main() {
   struct X * owner pX = calloc( 1, sizeof * pX);
   if (pX) {
     /*...*/;
     x_delete( pX); 
   }
 } 
</code></pre>

<h2 id="toc_5">Static analysis</h2>

<p>All the rules we have presented are checked by the compiler. Let&#39;s revisit our first example:</p>

<pre><code class="language-c">FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
if (f)
    fclose(f);
</code></pre>

<p>The flow analysis must ensure that when the owner pointer ‘f’ goes out of scope, it does not own any objects. At the end of the scope, ‘f’ can be either null or moved, and both states ensure that there are no remaining resources.</p>

<p>To check the ownership rules, the compiler uses six states:</p>

<ul>
<li>uninitialized</li>
<li>moved</li>
<li>null</li>
<li>not-null</li>
<li>zero</li>
<li>not-zero</li>
</ul>

<p>We can print these states using the <strong>static_debug</strong> declaration. We can also assert the variable is at a certain state using the <strong>static_state</strong> declaration. Listing 12 shows this usage:</p>

<h5>Listing 12 - Usage of <strong>static_state</strong> and <strong>static_debug</strong></h5>

<pre><code class="language-c">int main() {
 int a;   
 static_state(a, &quot;uninitialized&quot;);  
 static_debug(a);
}
</code></pre>

<p>Output:</p>

<pre><code>source:5:2: note: static_debug
 5 | static_debug(a);
   | ^~~~~~~~~~~~
   a == &quot;uninitialized&quot;
</code></pre>

<p>As we have just seen, the <strong>uninitialized</strong> state is the state of variables that are declared but not initialized. The compiler ensures that we don&#39;t read uninitialized objects.</p>

<p>The <strong>null</strong> state means that owner objects are not referencing any object. Listing 13 shows a sample using owner pointers:</p>

<h5>Listing 13 - Null state</h5>

<pre><code class="language-c">int main() {
 void * owner p = nullptr;   
 static_state(p, &quot;null&quot;); 
}
</code></pre>

<p>The <strong>not-null</strong> state indicates that the object is referencing some object, as shown in listing 14.</p>

<h5>Listing 14 - Not-null state</h5>

<pre><code class="language-c">int main()
{
   void * owner p = malloc(1);
   if (p) {
     static_state(p, &quot;not-null&quot;);
   }
}
</code></pre>

<p>The <strong>zero</strong> state is used for non-owner objects to complement and support uninitialized checks.</p>

<h5>Listing 15 - The zero state</h5>

<pre><code class="language-c">int main()
{
   int i = 0;
   static_state(i, &quot;zero&quot;);   
}
</code></pre>

<p><strong>Zero</strong> and <strong>null</strong> are different states. This difference is necessary because, for non-pointers like the socket sample, 0 does not necessarily mean null. The compiler does not know the semantics for types that are not pointers. However, you can use <strong>static_set</strong> to override states. In Listing 16, we annotate that server_socket is null, which doesn&#39;t mean it is zero but indicates that it is not holding any resources and is safe to return without calling close.</p>

<p>The <strong>not-zero</strong> state is used for non-owner objects to indicate the value if not zero.</p>

<h5>Listing 16 - Usage of static_set</h5>

<pre><code class="language-c">  owner int server_socket =
     socket(AF_INET, SOCK_STREAM, 0);
  if (server_socket &lt; 0) {  
     static_set(server_socket, &quot;null&quot;);
     return;
  }  
 /*...*/
 close(server_socket);
</code></pre>

<p>Now let&#39;s consider <code>realloc</code> function.</p>

<pre><code class="language-c">void * owner realloc( void *ptr, size_t new_size ); 
</code></pre>

<p>In the declaration of <code>realloc</code>, we are not moving the ptr. The reason for that is because the <code>ptr</code> may or may not be moved. If the function returns NULL, <code>ptr</code> was not moved. Listing 17 shows how <strong>static_set</strong> can be used.</p>

<h5>Listing 17 - Using static_set with realloc</h5>

<pre><code class="language-c">  void * owner p = malloc(1);
  void * owner p2 = realloc(p, 2);
  if (p2 != 0)
  {
     /*
        if p2 != 0 it  means p was moved.
     */
     static_set(p, &quot;moved&quot;);
     p = p2;
  }    
  free(p);
</code></pre>

<p>The state of an object is a combination of all possible states. For instance, let&#39;s print and check the state of <code>f</code> at listing 17.</p>

<h5>Listing 17 - Flow analysis</h5>

<pre><code class="language-c">int main() {
  FILE *owner f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
  if (f)
    fclose(f);  
  static_state(f, &quot;null or moved&quot;);
  static_debug(f);
}
</code></pre>

<p>Output:</p>

<pre><code class="language-c">source:13:3: note: static_debug
 13 |  static_debug(f);
    |  ^~~~~~~~~~~~
    f == &quot;null or moved&quot;
</code></pre>

<p><strong>Rule:</strong> We cannot discard owner objects as showed in listing 18.  </p>

<h5>Listing 18 - owner objects cannot be discarded.</h5>

<pre><code class="language-c">int main() {  
 fopen(&quot;file.txt&quot;, &quot;r&quot;); //ERROR
}
</code></pre>

<p><strong>Rule:</strong> Before the assignment of owner objects, the compiler checks if the owner object is not holding any resource, as shown in Listing 19:</p>

<h5>Listing 19 - Check before assignment</h5>

<pre><code class="language-c">  FILE * owner file = fopen(&quot;file.txt&quot;, &quot;r&quot;);  
  file = fopen(&quot;file.txt&quot;, &quot;r&quot;); //ERROR
</code></pre>

<p>Sometimes is not possible to infer the state. Consider this sample.</p>

<h5>Listing 20 - Some states cannot be inferred</h5>

<pre><code class="language-c">struct X {
  char *owner text; 
};
void init(struct  X * x) {
  x-&gt;text = strdup(&quot;a&quot;);
}
</code></pre>

<p>How to know <code>x-&gt;text</code> was not holding any resource? At  listing 21, we show how <strong>static_set</strong> can be used to say <code>x-&gt;text</code> is not initialized at <code>init</code>. </p>

<h5>Listing 21 - Using static_set</h5>

<pre><code class="language-c">void init(struct  X * x) {  
  static_set(x-&gt;text, &quot;uninitialized&quot;);
  x-&gt;text = strdup(&quot;a&quot;);
}
</code></pre>

<p>The runtime assert is also used by the compiler. Consider the following sample where we have a linked list. Each node has owner pointer to next. The next pointer of the tail of the list is always pointing to null, unless we have a bug. But the compiler does not know <code>list-&gt;tail-&gt;next</code> is null. Using assert we give this inform to the compiler and we also have a runtime check for possible logic bugs.</p>

<h5>Listing 22 shows the usage of assert.</h5>

<pre><code class="language-c">struct node {
 char * owner text;
 struct node* owner next;
};

struct list {
  struct node * owner head;
  struct node * tail;
};

void list_append(struct list* list, struct node* owner node)
{
  if (list-&gt;head == NULL) {
      list-&gt;head = node;
   }
   else {
      assert(list-&gt;tail-&gt;next == 0);
      list-&gt;tail-&gt;next = node;
   }
   list-&gt;tail = node;
}
</code></pre>

<p><strong>Rule:</strong> A non-owner object cannot be copied to a owner object. </p>

<p>But, the null pointer constant is converted to a null owner pointer. Se listing 23.</p>

<h5>Listing 23 - non owner cannot be copied to owner</h5>

<pre><code class="language-c">FILE * f();
int main() {  
   FILE * owner file = f(); //ERROR   
   FILE * owner file2 = 0;  //OK
}
</code></pre>

<p><strong>Rule:</strong> A view pointer parameter cannot leave the scope with moved/uninitialized objects. Listing 24</p>

<h5>Listing 24 - Messing with view parameters</h5>

<pre><code class="language-c">void f(struct Y * p) {
    x_destroy(p-&gt;px);
} //ERROR p-&gt;x is leaving scope MOVED
  
int main() {
   struct Y  y = {};
   y.x.name = strdup(&quot;a&quot;);
   f(&amp;y);
   free(y.x.name);
}
</code></pre>

<p>However, listing 25 is correct, because before the end of scope states of the parameters are restored.</p>

<h5>Listing 25 - swap function</h5>

<pre><code class="language-c">void x_swap(struct X * a, struct X * b) {
  struct X temp = *a;
  *a = *b;
  *b = temp;
}
</code></pre>

<p><strong>Rule:</strong> When objects are moved to functions, they become uninitialized. This prevents bugs like double free. Listing 26. </p>

<pre><code> int main() {
  void * owner p = malloc(1);
  free(p);
  free(p); //ERROR p is uninitialized
}
</code></pre>

<p><strong>Rule:</strong> moved objects cannot be moved. Listing 27.</p>

<h5>Listing 27 - We cannot move a moved or uninitialized object</h5>

<pre><code class="language-c">int * owner p1 = ...;
int * owner p2 = p1;
int * owner p3 = p1; //ERROR p1 was moved
</code></pre>

<pre><code class="language-c">int * owner f(int * owner p1) {
 int * owner p2 = p1;
 return p1; //ERROR p1 was moved
}
</code></pre>

<p><strong>Rule:</strong> When coping a owner object to to a view object the compiler must check the lifetime. Listing 28</p>

<h5>Listing 28 - Lifetime check</h5>

<pre><code class="language-c">void using_file(FILE * f);

struct X { 
  char *owner text; 
};  
  
struct X * owner make_owner();  

int main() {
  struct X *p = 0;  
  {
    struct X * owner p2 = make_owner();  
    p = p2; //error p lives longer than p2  
    free(p2);
  }

  using_file(fopen(&quot;file.txt&quot;, &quot;r&quot;)); //ERROR
}
</code></pre>

<p><strong>Rule:</strong> Returned objects must be valid.</p>

<h5>Listing 34 - Assuming returned objects are valid</h5>

<pre><code class="language-c">void* owner malloc(unsigned long size);
void free(void* owner ptr);

struct X { 
  char *owner text; 
};

struct X * owner f();

int main()
{
   struct X * owner pX = f();
   if (pX) {
     static_state(pX-&gt;text, &quot;maybe-null&quot;);
   }
}
</code></pre>

<p><strong>Rule:</strong> Arguments must be valid.</p>

<h5>Listing 35 - Arguments cannot be moved or uninitialized</h5>

<pre><code class="language-c">
struct X { 
  char *owner text; 
};

void f(struct X * p);

int main() {
   struct X x;
   f(&amp;x); //ERROR
     
   struct X x1 = {0};
   struct X x2 = x1; //MOVED
   f(&amp;x1); //ERROR
}
</code></pre>

<p>For this reason, an qualifier &#39;out&#39; can be added in the future to allow passing unitalicized objects.</p>

<pre><code class="language-c">struct X {
  char *owner text; 
};
void init(out struct  X * x) {  
  x-&gt;text = strdup(&quot;a&quot;);
}
int main() {
  struct X x = {0};
  init(&amp;x);
}
</code></pre>

<p>Meanwhile, the error can be removed initializing the object.</p>

<pre><code class="language-c">struct X {
  char *owner text; 
};
void init(struct  X * x) {  
  static_set(x, &quot;uninitialized&quot;);
  x-&gt;text = strdup(&quot;a&quot;);
}
int main() {
  struct X x = {0};
  init(&amp;x);
}
</code></pre>

<p>We can also pretend the object is initialized.</p>

<pre><code class="language-c">struct X {
  char *owner text; 
};
void init(struct  X * x) {  
  static_set(x, &quot;uninitialized&quot;);
  x-&gt;text = strdup(&quot;a&quot;);
}
int main() {
  struct X x;
  static_set(x, &quot;zero&quot;);
  init(&amp;x);
}
</code></pre>

<h2 id="toc_6">Ownership Feature Strategy (Inspired by stdbool.h)</h2>

<p>If the compiler supports ownership checks and qualifiers such as _Owner, _View, _Obj_view, etc., it defines <code>__STDC_OWNERSHIP__</code>. </p>

<p>However, even if the compiler implements ownership, it is not active by default.</p>

<p>Therefore, when compiling this file, we don&#39;t have errors or warnings.</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
  void * p = malloc(1);
}
</code></pre>

<p>A second define <code>__OWNERSHIP_H__</code> is used to enable ownership, for instance, changing the definition of malloc.<br>
Including <code>#include &lt;ownership.h&gt;</code> at beginning, will define 
<code>__OWNERSHIP_H__</code> enabling ownership declaration on stdlib.h.
<code>ownership.h</code> also adds lowercase macros for _Owner etc.</p>

<p>Inside stdlib.h we will have something like: </p>

<pre><code class="language-c">#if defined(__STDC_OWNERSHIP__) &amp;&amp; defined(__OWNERSHIP_H__)
void * _Owner malloc(size_t size);  
#else
void * malloc(size_t size);
#endif
</code></pre>

<blockquote>
<p>Currently cake is using the same headers of VS and GCC that are not aware of ownership. For this reason, <code>ownership.h</code> itself is declaring malloc etc and the second declaration of malloc inside stdlib.h will not complain with the discrepancy of ownership qualifiers between declarations.</p>
</blockquote>

<p>So now, this sample:</p>

<pre><code class="language-c">#include &lt;ownership.h&gt;
#include &lt;stdio.h&gt;

int main() {
  void * owner p = malloc(1);
}
</code></pre>

<p>Will have the ownership enabled if the compiler supports ownership, otherwise owner macro will be defined as empty.</p>

<blockquote>
<p>This approach allows the same code to be compiled in compilers with or without ownership. </p>
</blockquote>

<p>The compiler will now complain about the memory leak.</p>

<p>This solution is not perfect. If we mix old and new includes the old headers may be affect.</p>

<p>For instance:</p>

<pre><code class="language-c">#include &lt;ownership.h&gt;
#include &lt;stdio.h&gt;
#include &quot;oldheader.h&quot; //affected 

int main() {
  void * owner p = malloc(1);
}
</code></pre>

<p>The old header may be affect in some ways, for instance a inline function may be using malloc and the compiler will complain the lack of ownership qualifiers.  </p>

<p>The old header maybe is using owner as a variable name. </p>

<p>The solution for this problem may be changing the order of includes. We also may silence errors for the lack of ownership qualifiers. </p>

<p>In brief:</p>

<ul>
<li>Old code can be compiled in new compilers because they don&#39;t include <code>&lt;ownership.h&gt;</code>.</li>
<li>New code using <code>&lt;ownership.h&gt;</code> can be compiled in old compilers because qualifiers are defined as empty macros</li>
</ul>

<p>I have considered something like <code>#pragma OWNERSHIP ON/OFF</code> but this is also similar controlling warning with pragma. The objective is also avoid reading <code>#pragma OWNERSHIP ON</code> everywhere.  </p>

<p>I also have considered attributes, but is not so clear the attributes for types. But also the usage of attributes would be together with macros because we can compile new code in old compilers.  </p>

<p>Although, here I am talking about a specific feature ownership, with the evolution of C this kind of situation will be very common. Maybe the natural evolution will be attributes, but attributes also feels temporary/experimental solution especially if they mean something on the type system.</p>
</article></body></html>