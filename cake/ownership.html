<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake Playground</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">Part I - Type system changes</a>
<ul>
<li>
<a href="#toc_2">New qualifiers</a>
</li>
<li>
<a href="#toc_3">Semantics</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Part II - Flow analysis</a>
<ul>
<li>
<a href="#toc_5">Special case malloc/calloc</a>
</li>
<li>
<a href="#toc_6">Disabling ownership checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">Grammar</a>
</li>
<li>
<a href="#toc_8">Checking your source code</a>
</li>
<li>
<a href="#toc_9">Terms</a>
<ul>
<li>
<a href="#toc_10">storage duration</a>
</li>
<li>
<a href="#toc_11">lifetime</a>
</li>
<li>
<a href="#toc_12">value</a>
</li>
<li>
<a href="#toc_13">object</a>
</li>
<li>
<a href="#toc_14">owner object</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>** Under development.**</p>

<h1 id="toc_0">Ownership checks for C</h1>

<p>The static ownership check is an experimental feature for Cake.
It consists of two separate implementations. </p>

<p>Part I focuses on introducing the concept of an owner qualifier in the type system and does not requires flow analysis. </p>

<p>Part II requires flow analysis, ensuring that owned resources are appropriately released when necessary.   </p>

<p>By implementing the static ownership check, and using the feature on it&#39;s own source, Cake aims to explore and evaluate the effectiveness of this feature.  </p>

<h2 id="toc_1">Part I - Type system changes</h2>

<h3 id="toc_2">New qualifiers</h3>

<ul>
<li>owner</li>
<li>view</li>
<li>obj_owner</li>
</ul>

<p>The <strong>owner</strong> qualifier declares an object that has a reference to another object.  The owner object exclusively holds the responsibility for controlling the lifetime of the referenced object. When used with a pointer, indicates that the pointer assumes ownership of the pointed object and its associated memory.</p>

<pre><code class="language-c">void * owner p = malloc(1);
free(p);
</code></pre>

<p>The <strong>view</strong> qualifier declares an object that has a reference to another object but it does not control its lifetime, which must exist beyond the lifespan of the view qualified object itself. The <strong>view</strong> qualifier is the default.</p>

<pre><code class="language-c">void * owner p = malloc(1);
if (p)
{
  void * p2 = p; /*p2 is a view*/
}
free(p);
</code></pre>

<p>The <strong>obj_owner</strong> qualifier is exclusively applicable to pointers, meaning that the pointer owns the pointed object but not the memory it occupies. It is generally used in destructors.    </p>

<pre><code class="language-c">void x_destroy(struct X * obj_owner p){
 /*
    We must release all resources used by p
    but we cannot release the memory pointed by p
 */
}  
int main() {  
  struct X x = {};
  x_destroy(&amp;x);  
}
</code></pre>

<p>For struct and unions, if at least one member has the <strong>owner</strong> qualifier, the entire type is considered to be an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">struct person {
  char * owner name;
};  

int main(){
  struct person p1 = {};  
  /*p1 is a owner type*/
}
</code></pre>

<p>Applying the <strong>view</strong> qualifier to an struct or union type designates the type as a view, regardless of whether it includes members owner qualified.</p>

<pre><code class="language-c">struct person {
  char * owner name;
};

int main(){
  view struct person p2;
   /*p2.name is view qualified*/
}
</code></pre>

<p>Similarly of what happens with structs and unions, if the element of the array is owner qualified the entire array is treated as an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">int main()
{
  struct person a[10] = {};  
  //a is the owner of 10 struct person
}
</code></pre>

<p>When array types are used in parameters the array is not considered owner qualified type. </p>

<pre><code class="language-c">void print_array(int n, struct person a[10]);

int main()
{
  struct person a[10] = {};
  print_array(10, a);
}
</code></pre>

<p>To qualify array parameters as owner we do:</p>

<pre><code class="language-c">void destroy_array(int n, struct person a[owner 10]);
</code></pre>

<p>The most common usage of <strong>owner</strong> will be pointers. However, ownership qualifiers can be applied for any type.</p>

<p>Sample:</p>

<pre><code class="language-c">owner int socket = 
    socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
</code></pre>

<p>Pointers have the additional advantage of having a natural zero semantics.   </p>

<p>Considering that the objective of owner objects is to control the lifetime of the referenced object, it does not make sense a owner pointer to functions.</p>

<blockquote>
<p>The exactly name of the new qualifiers still not defined. It can be something like <code>_Owner</code> or just <code>owner</code>.  My suggestion is to have macros for each qualifier to to be able to compile the same source code in compilers that don&#39;t support ownership checks. </p>
</blockquote>

<h3 id="toc_3">Semantics</h3>

<p>1 - When a owner object is copied to another owner object the ownership is always moved/transfered.</p>

<p>The object that receives the value must not hold any resource, otherwise the previous referenced objects would be lost.
This is natural in initialization and function arguments. </p>

<p>Sample returning values</p>

<pre><code class="language-c">T* owner make_owner() {  
   T* owner  p = ...
   return p;
}
</code></pre>

<p>Sample initialization</p>

<pre><code class="language-c">T * owner b = make_owner(); /*moved*/  
</code></pre>

<p>Sample calling functions</p>

<pre><code class="language-c">void f(T * owner a);
f(a); /*moved*/
</code></pre>

<p>When passing const owner to non const the compiler can ignore the warning. This solves an old and annoying warning.</p>

<pre><code class="language-c">const void * p = malloc(10);
free(p);
// warning: passing argument 1 of &#39;free&#39; discards &#39;const&#39; qualifier from pointer target type
</code></pre>

<p>The reason is because now the compiler has an extra information that is the owner qualifier.  </p>

<pre><code class="language-c">void free(void * owner p);
</code></pre>

<p>moving a const object to a function already means the object cannot be used anymore. The state is uninitiated, so as a consequence the warning is not necessary and can be removed.</p>

<p>Sample assignment</p>

<pre><code class="language-c">T * owner b = make_owner();
T * owner a = 0;  
...
a = b; /*moved*/;  
</code></pre>

<p>Flow analysis must ensure a is not holding any resources.</p>

<p>2 - A <strong>non owner object</strong> cannot be copied to a <strong>owner object</strong>.   </p>

<p>The only exception is the null pointer constant when copied to owner pointers.</p>

<pre><code class="language-c">T * owner f() {
  return 0; //OK
}
</code></pre>

<p>3 - An <strong>owner object</strong> can be copied to a <strong>non-owner object</strong> if its lifetime is longer than that of the <strong>non-owner object</strong>.  </p>

<p>We call the non-owner object a &quot;view&quot; in this case. </p>

<pre><code class="language-c">T F()
{
    owner T local;
    return local; /*error*/
} 
</code></pre>

<pre><code class="language-c">owner T global;
T F() {
   return global; //OK
}
</code></pre>

<pre><code class="language-c">T F(owner T arg) {
   return arg; //OK
}
</code></pre>

<pre><code class="language-c">  void F(T * p);
  F(make_owner()); //ERROR  
</code></pre>

<pre><code class="language-c">  T  *p = make_owner(); //ERROR
</code></pre>

<pre><code class="language-c">  T  *p = 0;  
  {
    T * owner p2 = make_owner();  
    p = p2; //error  
    free(p2);
  }
</code></pre>

<p>4 - Temporary owner objects cannot be discarded/ignored  </p>

<pre><code class="language-c">  make_owner(); //ERROR  
</code></pre>

<pre><code class="language-c">  void f(T * owner ) /*ERROR no name*/  
  {
  }  
</code></pre>

<h2 id="toc_4">Part II - Flow analysis</h2>

<p>The objective of flow analysis is to ensure that when the lifetime of owner object ends, it must have  already released the resources it owns. The same when we overwrite the owner object.  </p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = fopen(&quot;file&quot;, &quot;r&quot;);  
  if (f){  
      fclose(f);
  }
</code></pre>

<p>Flow analysis must know that when f goes of of scope it does not owns any resource. </p>

<p>To track ownership fours states are used &quot;uninitialized&quot;, &quot;moved&quot;, &quot;null&quot; and &quot;not null&quot;.  We can assert compile time states in cake using <strong>static_state</strong></p>

<pre><code class="language-c">T * p;  
static_state(p, &quot;uninitialized&quot;);
</code></pre>

<p>We can also print object states using <strong>static_debug</strong>.</p>

<pre><code class="language-c">T * p;  
static_debug(p);
</code></pre>

<p>Pointers can have the state &quot;null&quot; or &quot;not-null&quot;.  The combination of &quot;null or not-null&quot; is also called &quot;maybe-null&quot;.  </p>

<pre><code class="language-c">T * owner p = 0;  
static_state(p, &quot;null&quot;);

T * owner p2 = malloc(sizeof(T));  
static_state(p2, &quot;maybe-null&quot;);
</code></pre>

<p>When one owner object is copied to another the state of the source object is &quot;moved&quot;.  The state of the destination object is the same of the previous state of the source object.</p>

<pre><code class="language-c">T * owner p1 = 0;  
T * owner p2 = malloc(sizeof(T));  

static_state(p1, &quot;null&quot;);
static_state(p2, &quot;maybe-null&quot;);

p1 = p2;  

static_state(p1, &quot;maybe-null&quot;);
static_state(p2, &quot;moved&quot;);

</code></pre>

<p>The exception is when we move owner objects into functions, then the state is &quot;uninitialized&quot;. This prevents use after free or concurrency problems.</p>

<pre><code class="language-c">  T * owner p = malloc(sizeof(T));  
  free(p);
  static_state(p2, &quot;uninitialized&quot;);
</code></pre>

<p>The object state is a set of all possible states.  </p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = fopen(&quot;file&quot;, &quot;r&quot;);  
  if (f) {  
      fclose(f);
  }  
  static_state(f, &quot;null moved&quot;);
</code></pre>

<p>When an owning pointer goes out of scope and before its memory is overridden it cannot have &quot;not-null&quot; in its set state.   </p>

<p>All others possibilities are permitted. For instance, the state can be &quot;null or uninitialized&quot; or &quot;null or moved&quot;.</p>

<p>When an owning object (non pointer) goes out of scope and before its memory is overridden it must be on &quot;uninitialized&quot; or &quot;moved&quot; or &quot;uninitialized or moved&quot; state.
Structs an unions doens&#39;t have a direct state. But we can say that some struct has been moved if all of its objects have been moved.</p>

<h3 id="toc_5">Special case malloc/calloc</h3>

<pre><code class="language-c">struct X {    
    char * owner name;
};

int main() {
  struct X * owner p = malloc(sizeof (struct X));
  p-&gt;name =  strdup(&quot;hi&quot;);
}
</code></pre>

<p>We must track that object <code>p-&gt;name</code> does not have any resources before the strdup assignment. We know malloc returns an uninitialized memory but the compiler does not known. </p>

<p>For this particular case the semantics of malloc/calloc will be built-in; So the static analyzer will know malloc returns a uninitialized memory and calloc return a zeroed memory allowing us to write the code above.</p>

<h3 id="toc_6">Disabling ownership checks</h3>

<p>Some functions can have a intricate logic of pointers and instead of trying to adapt the logic we know is correct, we can just annotate &quot;unchecked&quot; at function definition.  </p>

<pre><code class="language-c">void f() &quot;unchecked&quot; {  
}
</code></pre>

<p>So far, from the experience of using this feature in cake source itself, I have much less usages of &quot;unchecked&quot; than I was expecting initially.</p>

<p><strong>assert</strong> also can be used to override the static analysis state.</p>

<pre><code class="language-c">/* linked list sample */

struct node {
 struct node* owner next;
};

struct list {
  struct node * owner head;
  struct node * tail;
};

void node_delete(struct node* owner p) {
  if (p) {
     assert(p-&gt;next == NULL);
     free(p);
  }
}

void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      p-&gt;next = NULL;
      node_delete(p);
      p = next;
  }
}
</code></pre>

<p>list_destroy can be implemented as follow:</p>

<pre><code class="language-c">void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      free(p);
      p = next;
  }
}
</code></pre>

<p>We don&#39;t need assert here because compiler knows &quot;p-&gt;next&quot; has been moved. We don&#39;t have a way do override the static analysis state &quot;moved&quot; or &quot;uninitialized&quot; using assert.</p>

<p>We also have <strong>static_set</strong> that can be used where assert does not work. For instance:</p>

<pre><code class="language-c">  void* owner pnew = realloc(p-&gt;data, n * sizeof(p-&gt;data[0]));
  if (pnew == NULL) return ENOMEM;
  static_set(p-&gt;data, &quot;moved&quot;);
  p-&gt;data = pnew;
</code></pre>

<h2 id="toc_7">Grammar</h2>

<pre><code class="language-c"> 
 type-qualifier:
   ...
   &#39;owner&#39;
   &#39;view&#39;
   &#39;obj_owner&#39;

static_debug-declaration:
  &#39;static_debug&#39; (constant-expression) ;

static_state-declaration:
  &#39;static_state&#39; (constant-expression, literal ) ;

static-declaration:  /*where static-assert is used today*/
 static_assert-declaration
 static_debug-declaration
 static_state-declaration

TODO &quot;unchecked&quot;
</code></pre>

<h2 id="toc_8">Checking your source code</h2>

<p>I suggest the creation of a header file &quot;ownership.h&quot;</p>

<pre><code class="language-c">
#pragma once

#ifdef __CAKE__
#define owner owner
#define obj_owner obj_owner
#define view view
  
void* owner calloc(int nmemb, int size);
void free(implicit void* owner ptr);
void* owner malloc(int size);
void* owner realloc(void* owner ptr, int size);
char * owner strdup( const char *src );

#else
#define owner
#define obj_owner
#define view

#endif

</code></pre>

<p>Then include this header on the top of your files and just run cake.</p>

<p>The way I am thinking is..</p>

<p>I have variables, for instance  </p>

<p>int a = 1;<br>
int b = 2;
int c = 3;  </p>

<p>if (condition) {<br>
  a = 4;<br>
  b = 5;<br>
}
else {<br>
  a = 6;<br>
  c = 7;<br>
}    </p>

<p>// a is 4 or 6<br>
// b is 2 or 5<br>
// c is 3 or 7  </p>

<h2 id="toc_9">Terms</h2>

<h3 id="toc_10">storage duration</h3>

<p>An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. </p>

<h3 id="toc_11">lifetime</h3>

<p>The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address and retains its last-stored value throughout its lifetime.</p>

<p>If an object is referred to outside of its lifetime, the behavior is undefined.</p>

<p>If a pointer value is used in an evaluation after the object the pointer points to (or just past) reaches
the end of its lifetime, the behavior is undefined.</p>

<p>The representation of a pointer object becomes indeterminate when the object the pointer points to (or just past) reaches the end of its lifetime.</p>

<h3 id="toc_12">value</h3>

<p>precise meaning of the contents of an object when interpreted as having a specific type</p>

<h3 id="toc_13">object</h3>

<p>Region of data storage in the execution environment, the contents of which can represent values.</p>

<h3 id="toc_14">owner object</h3>

<p>Is an object which value represents a reference to other object which lifetime is controlled by it.</p>
</body></html>  msvc
   