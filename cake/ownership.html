<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="style.css" />
    <title>Cake Playground</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">Part I - Type system changes</a>
<ul>
<li>
<a href="#toc_2">New qualifiers</a>
</li>
<li>
<a href="#toc_3">Semantics</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Part II - Flow analysis</a>
<ul>
<li>
<a href="#toc_5">Special case malloc/calloc</a>
</li>
<li>
<a href="#toc_6">Disabling ownership checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">Grammar</a>
</li>
<li>
<a href="#toc_8">Checking your source code</a>
</li>
<li>
<a href="#toc_9">Terms</a>
<ul>
<li>
<a href="#toc_10">storage duration</a>
</li>
<li>
<a href="#toc_11">lifetime</a>
</li>
<li>
<a href="#toc_12">value</a>
</li>
<li>
<a href="#toc_13">object</a>
</li>
<li>
<a href="#toc_14">owner object</a>
</li>
<li>
<a href="#toc_15">Samples</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>** Under development.**</p>

<h1 id="toc_0">Ownership checks for C</h1>

<p>The static ownership check is an experimental feature in Cake.
It consists of two separate implementations. </p>

<p>Part I focuses on introducing the concept of an owner qualifier in the type system and does not requires flow analysis. </p>

<p>Part II requires flow analysis, ensuring that owned resources are appropriately released when necessary.   </p>

<p>By implementing the static ownership check, and using the feature on it&#39;s own source, Cake aims to explore and evaluate the effectiveness of this feature.  </p>

<h2 id="toc_1">Part I - Type system changes</h2>

<h3 id="toc_2">New qualifiers</h3>

<ul>
<li>owner</li>
<li>view</li>
<li>obj_owner</li>
</ul>

<p>An <strong>owner object</strong> is an object that has at least one reference to another object, over which it has control of the lifetime. An owner object is the unique owner of the referenced object(s).
The <strong>owner</strong> qualifier is used to declare an <strong>owner object</strong>.</p>

<p>The most common owner objects are pointers, and we can also call them <strong>owner pointers</strong>.</p>

<pre><code class="language-c">  struct X * owner p = calloc(1, sizeof * p);    
  //...
  free(p);
</code></pre>

<p>We can have other types of <strong>owner objects</strong> that work as references but are not necessarily pointers. 
For instance, Berkeley sockets, uses a integer to identity the socket.</p>

<pre><code class="language-c">    owner int server_socket =   
       socket(AF_INET, SOCK_STREAM, 0);  
    ...   
    close(server_socket);
</code></pre>

<p>Aggregates (struct/unions/arrays) also can be a <strong>owner object</strong>.  </p>

<pre><code class="language-c">struct X {
  char * owner name;
  struct Y * owner p;
}; 
char * owner names[10];
</code></pre>

<p><strong>Owner pointers</strong> assume ownership of the pointed object and its memory, treating them as if they were two different objects.</p>

<pre><code class="language-c">struct X { char * owner text; };   
int main() {
  struct X * owner p = malloc(1);  
    
  /*releasing object resources*/  
  free(p-&gt;text);
  
  /*releasing memory*/  
  free(p);  
}
</code></pre>

<p>When owner objects are copied the ownership is moved.  </p>

<p>For instance:</p>

<pre><code class="language-c">struct X { char * owner text; };   
int main() {
  struct X x1 = {};
  ....
  struct X x2 = {};
  x2 = x1;
  
  free(x2.text);
}
</code></pre>

<p>A <strong>view object</strong> is an object that holds references to other objects but does not own those references, which must exist beyond the lifespan of the view object itself. A <strong>view pointer</strong> is a pointer that does not own the pointed object, that is the default.    </p>

<p>The view qualifier is used to override the owner qualifier in structs.</p>

<pre><code class="language-c">struct X { char * owner text; };   
int main() {
  struct X x1 = {};
  ....
  view struct X x2 = {};
  x2 = x1; //x2 is just a view
  
  free(x1.text); //x1 still the owner
}
</code></pre>

<p>We can create destructors like this</p>

<pre><code class="language-c">struct X { char * owner text; };  
void x_destroy(struct X x) {
  free(p-&gt;text);
} //ok

int main() {
  struct X x= {0};
  //...
  x_destroy(x); //x moved
}
</code></pre>

<p>However, generally structs are passed by pointer in C. The next qualifier <strong>obj_owner</strong> is used for this purpose.</p>

<p>An <strong>object owner pointer</strong> is a version of <strong>owner pointer</strong> with the difference that is is responsible only for the lifetime of the pointed object, but not responsible for it&#39;s memory lifetime.   </p>

<p>The <strong>obj_owner</strong> qualifier is used exclusively with pointers. The most common usage of <strong>object owner pointer</strong> is when creating destructors.  </p>

<p>Sample:</p>

<pre><code class="language-c">struct X { char * owner text; };  
void x_destroy(struct X * obj_owner p) {
  free(p-&gt;text);
}  

int main() {
  struct X x= {0};
  ...  
  x_destroy(&amp;x); //x was moved
}
</code></pre>

<p>Now consider this sample that is not using <strong>obj_owner</strong></p>

<pre><code class="language-c">struct X { char * owner text; };  
void f(struct X * p) {
  free(p-&gt;text);
}  
int main() {
  struct X x= {0};
  f(&amp;x);
}
</code></pre>

<p>There is nothing on the function declaration telling us or the compiler that parts of x will be moved.  </p>

<p>So, what is checked is:<br>
<strong>pointers to owner objects</strong> cannot leave the scope with the pointed objected moved or parts of it moved.</p>

<p>This sample below is correct.  </p>

<pre><code class="language-c">struct X { char * owner text; };  
void f(struct X * p) {
  free(p-&gt;text);  
  p-&gt;text = strdup(&quot;new value&quot;);
} //ok p-&gt;text is leaving the scoped initialized   
</code></pre>

<p>But</p>

<pre><code class="language-c">void f(struct X * p) {
  free(p-&gt;text);
}  //error pointed object p-&gt;text was moved
</code></pre>

<p>is not correct.</p>

<p><strong>object owner pointer</strong> to <strong>non owner objects</strong> does not make sense.   </p>

<p><strong>owner objects</strong> must use complete types.
<strong>owner pointers</strong> to functions are not allowed.</p>

<h3 id="toc_3">Semantics</h3>

<p>1 - When a <strong>owner object</strong> is copied to another <strong>owner object</strong> the ownership is moved.</p>

<p>The destination owner object must not hold any resource at the moment of copy. This is natural on initialization, function arguments and returning objects. For assignment, flow analysis is required.    </p>

<p>Sample - returning values</p>

<pre><code class="language-c">T* owner make_owner() {  
   T* owner  p = ...
   return p;
}
</code></pre>

<p>Sample  - initialization</p>

<pre><code class="language-c">T * owner b = make_owner();  
</code></pre>

<p>Sample  - calling functions</p>

<pre><code class="language-c">void f(T * owner a);
f(a);
</code></pre>

<p>When passing a owner pointer that points to const object to a owner pointer to non-const object the common warning discards &#39;const&#39; qualifier can be ignored.</p>

<pre><code class="language-c">void fred(void * owner p);
const void * owner p = malloc(10);
free(p); //no warning
</code></pre>

<p>Sample - assignment</p>

<pre><code class="language-c">T * owner b = make_owner();
T * owner a = 0;  
...
a = b;  
</code></pre>

<p>Flow analysis must ensure <code>a</code> is not holding any resources before the assignment.</p>

<p>2 - When a <strong>owner pointer</strong> is copied to a <strong>owner pointer</strong> to <code>void</code> only the ownership of the object is moved.</p>

<p>The pointed object also must have been released before.  </p>

<pre><code class="language-c">struct X { char * owner text; };   
int main() {
  struct X * owner p = malloc(1);  
  free(p-&gt;text); //moving the ownership of object
  free(p); //moving ownership of the memory  
}
</code></pre>

<p>3 - When a <strong>owner pointer</strong> is copied to a <strong>object owner pointer</strong> the ownership of the pointed object is moved, but not the ownership of the memory.</p>

<pre><code class="language-c">struct X { char * owner text; };  
  
void x_destroy(struct X * obj_owner p){
  free(p-&gt;text);
}  

int main() {
  struct X x= {0};
  ...  
  x_destroy(&amp;x); //object moved
  free(p); //memory moved
}
</code></pre>

<p>4 - We can pass a <strong>pointer to owner object</strong> as a <strong>object owner pointer</strong>. The object is moved.  </p>

<pre><code class="language-c"> struct X{
   char * owner text;
 };
 void x_destroy(struct X * obj_owner p){
  free(p-&gt;text);
}  
 int main() {
   struct X x = {0};
   x_destroy(&amp;x);//OK
 }
</code></pre>

<p>But arguments cannot leave the scoped moved.</p>

<p>5 - We cannot pass <strong>pointer to non owner object</strong> as a <strong>object owner pointer</strong>.</p>

<pre><code class="language-c"> struct X{
   char * owner text;
 };
 void x_destroy(struct X * obj_owner p){
  free(p-&gt;text);
}  
 int main() {
   view struct X x = {0};
   x_destroy(&amp;x);//ERROR
 }
</code></pre>

<p>6 - A <strong>non owner object</strong> cannot be copied to a <strong>owner object</strong>.   </p>

<p>The only exception is the null pointer constant when copied to owner pointers.</p>

<pre><code class="language-c">T * owner f() {
  return 0; //OK
}
</code></pre>

<pre><code class="language-c">int * p;
free(p); //error free requires an owner pointer
</code></pre>

<pre><code class="language-c">void x_delete(struct X * owner p);
struct X x;
x_delete(&amp;x); //error
</code></pre>

<p>7 - An <strong>owner object</strong> can be copied to a <strong>non-owner object</strong> if its lifetime is longer than that of the <strong>non-owner object</strong>.  </p>

<pre><code class="language-c">T F()
{
    owner T local;
    return local; /*error*/
} 
</code></pre>

<pre><code class="language-c">owner T global;
T F() {
   return global; //OK
}
</code></pre>

<pre><code class="language-c">T F(owner T arg) {
   return arg; //OK
}
</code></pre>

<pre><code class="language-c">  void F(T * p);
  F(make_owner()); //ERROR  
</code></pre>

<pre><code class="language-c">  T  *p = make_owner(); //ERROR
</code></pre>

<pre><code class="language-c">  T  *p = 0;  
  {
    T * owner p2 = make_owner();  
    p = p2; //error  
    free(p2);
  }
</code></pre>

<p>8 - Temporary <strong>owner objects</strong> cannot be discarded  </p>

<pre><code class="language-c">  make_owner(); //ERROR  
</code></pre>

<pre><code class="language-c">  void f(T * owner )//ERROR
  {
  }  
</code></pre>

<h2 id="toc_4">Part II - Flow analysis</h2>

<p>The objective of flow analysis is to ensure that when the lifetime of <strong>owner object</strong> ends, it must have  already released the resources it owns.<br>
The same when we overwrite the <strong>owner object</strong>.  </p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = fopen(&quot;file&quot;, &quot;r&quot;);  
  if (f){  
      fclose(f);
  }
</code></pre>

<p>Flow analysis must know that when f goes of of scope it does not owns any resource. </p>

<p>To track ownership fours states are used</p>

<ul>
<li>uninitialized</li>
<li>moved</li>
<li>null</li>
<li>not null<br></li>
</ul>

<p>We can assert compile time states in cake using <strong>static_state</strong></p>

<p>Sample:</p>

<pre><code class="language-c">T * p;  
static_state(p, &quot;uninitialized&quot;);
</code></pre>

<p>We can also print object states using <strong>static_debug</strong>.</p>

<pre><code class="language-c">T * p;  
static_debug(p);
</code></pre>

<p>References can have the state &quot;null&quot; or &quot;not-null&quot;.</p>

<p>The combination of &quot;null or not-null&quot; is also called &quot;maybe-null&quot;.  </p>

<pre><code class="language-c">T * owner p = 0;  
static_state(p, &quot;null&quot;);

T * owner p2 = malloc(sizeof(T));  
static_state(p2, &quot;maybe-null&quot;);
</code></pre>

<p>When one owner object is copied to another the state of the source object is &quot;moved&quot;.  The state of the destination object is the same of the previous state of the source object.</p>

<pre><code class="language-c">T * owner p1 = 0;  
T * owner p2 = malloc(sizeof(T));  

static_state(p1, &quot;null&quot;);
static_state(p2, &quot;maybe-null&quot;);

p1 = p2;  

static_state(p1, &quot;maybe-null&quot;);
static_state(p2, &quot;moved&quot;);

</code></pre>

<p>The exception is when we move owner objects into functions, then the state is &quot;uninitialized&quot;. This prevents use after free or concurrency problems.</p>

<pre><code class="language-c">  T * owner p = malloc(sizeof(T));  
  free(p);
  static_state(p2, &quot;uninitialized&quot;);
</code></pre>

<p>The object state is a set of all possible states.  </p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = fopen(&quot;file&quot;, &quot;r&quot;);  
  if (f) {  
      fclose(f);
  }  
  static_state(f, &quot;null moved&quot;);
</code></pre>

<p>When an owning pointer goes out of scope and before its memory is overridden it cannot have &quot;not-null&quot; in its set state.   </p>

<p>All others possibilities are permitted. For instance, the state can be &quot;null or uninitialized&quot; or &quot;null or moved&quot;.</p>

<p>When an owning object (non pointer) goes out of scope and before its memory is overridden it must be on &quot;uninitialized&quot; or &quot;moved&quot; or &quot;uninitialized or moved&quot; state.
Structs an unions doesn&#39;t have a direct state. But we can say that some struct has been moved if all of its objects have been moved.</p>

<h3 id="toc_5">Special case malloc/calloc</h3>

<pre><code class="language-c">struct X {    
    char * owner name;
};

int main() {
  struct X * owner p = malloc(sizeof (struct X));
  p-&gt;name =  strdup(&quot;hi&quot;);
}
</code></pre>

<p>We must track that object <code>p-&gt;name</code> does not have any resources before the strdup assignment. We know malloc returns an uninitialized memory but the compiler does not known. </p>

<p>For this particular case the semantics of malloc/calloc will be built-in; So the static analyzer will know malloc returns a uninitialized memory and calloc return a zeroed memory allowing us to write the code above.</p>

<h3 id="toc_6">Disabling ownership checks</h3>

<p>Some functions can have a intricate logic of pointers and instead of trying to adapt the logic we know is correct, we can just annotate &quot;unchecked&quot; at function definition.  </p>

<pre><code class="language-c">void f() &quot;unchecked&quot; {  
}
</code></pre>

<p>So far, from the experience of using this feature in cake source itself, I have much less usages of &quot;unchecked&quot; than I was expecting initially.</p>

<p><strong>assert</strong> also can be used to override the static analysis state.</p>

<pre><code class="language-c">/* linked list sample */

struct node {
 struct node* owner next;
};

struct list {
  struct node * owner head;
  struct node * tail;
};

void node_delete(struct node* owner p) {
  if (p) {
     assert(p-&gt;next == NULL);
     free(p);
  }
}

void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      p-&gt;next = NULL;
      node_delete(p);
      p = next;
  }
}
</code></pre>

<p>list_destroy can be implemented as follow:</p>

<pre><code class="language-c">void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      free(p);
      p = next;
  }
}
</code></pre>

<p>We don&#39;t need assert here because compiler knows &quot;p-&gt;next&quot; has been moved. We don&#39;t have a way do override the static analysis state &quot;moved&quot; or &quot;uninitialized&quot; using assert.</p>

<p>We also have <strong>static_set</strong> that can be used where assert does not work. For instance:</p>

<pre><code class="language-c">  void* owner pnew = realloc(p-&gt;data, n * sizeof(p-&gt;data[0]));
  if (pnew == NULL) return ENOMEM;
  static_set(p-&gt;data, &quot;moved&quot;);
  p-&gt;data = pnew;
</code></pre>

<h2 id="toc_7">Grammar</h2>

<pre><code class="language-c"> 
 type-qualifier:
   ...
   &#39;owner&#39;
   &#39;view&#39;
   &#39;obj_owner&#39;

static_debug-declaration:
  &#39;static_debug&#39; (constant-expression) ;

static_state-declaration:
  &#39;static_state&#39; (constant-expression, literal ) ;

static-declaration:  /*where static-assert is used today*/
 static_assert-declaration
 static_debug-declaration
 static_state-declaration

TODO &quot;unchecked&quot;
</code></pre>

<h2 id="toc_8">Checking your source code</h2>

<p>I suggest the creation of a header file &quot;ownership.h&quot;</p>

<pre><code class="language-c">
#pragma once

#ifdef __CAKE__
#define owner owner
#define obj_owner obj_owner
#define view view
  
void* owner calloc(int nmemb, int size);
void free(implicit void* owner ptr);
void* owner malloc(int size);
void* owner realloc(void* owner ptr, int size);
char * owner strdup( const char *src );

#else
#define owner
#define obj_owner
#define view

#endif

</code></pre>

<p>Then include this header on the top of your files and just run cake.</p>

<p>The way I am thinking is..</p>

<p>I have variables, for instance  </p>

<p>int a = 1;<br>
int b = 2;
int c = 3;  </p>

<p>if (condition) {<br>
  a = 4;<br>
  b = 5;<br>
}
else {<br>
  a = 6;<br>
  c = 7;<br>
}    </p>

<p>// a is 4 or 6<br>
// b is 2 or 5<br>
// c is 3 or 7  </p>

<h2 id="toc_9">Terms</h2>

<h3 id="toc_10">storage duration</h3>

<p>An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. </p>

<h3 id="toc_11">lifetime</h3>

<p>The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address and retains its last-stored value throughout its lifetime.</p>

<p>If an object is referred to outside of its lifetime, the behavior is undefined.</p>

<p>If a pointer value is used in an evaluation after the object the pointer points to (or just past) reaches
the end of its lifetime, the behavior is undefined.</p>

<p>The representation of a pointer object becomes indeterminate when the object the pointer points to (or just past) reaches the end of its lifetime.</p>

<h3 id="toc_12">value</h3>

<p>precise meaning of the contents of an object when interpreted as having a specific type</p>

<h3 id="toc_13">object</h3>

<p>Region of data storage in the execution environment, the contents of which can represent values.</p>

<h3 id="toc_14">owner object</h3>

<p>Is an object which value represents a reference to other object which lifetime is controlled by it.</p>

<h3 id="toc_15">Samples</h3>

<pre><code class="language-c">int mtx_init( owner mtx_t* mutex, int type );  
void mtx_destroy( mtx_t * obj_owner mutex );  

owner mtx_t mtx;
int r = mtx_init(&amp;mtx, mtx_plain);  
if (r == thrd_success){  
  static_set(mtx, &quot;not null&quot;);  
  mtx_destroy(&amp;mtx);  
}
</code></pre>
</body></html>  msvc
   