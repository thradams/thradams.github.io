<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
     <link rel="stylesheet" href="style.css" />
</head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">Part I - Type system changes</a>
<ul>
<li>
<a href="#toc_2">New Type qualifiers</a>
</li>
<li>
<a href="#toc_3">Initialization and assignment</a>
</li>
<li>
<a href="#toc_4">Returning variables</a>
</li>
<li>
<a href="#toc_5">Calling functions</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Part II - Flow analysis</a>
<ul>
<li>
<a href="#toc_7">malloc/calloc</a>
</li>
<li>
<a href="#toc_8">Disabling ownership checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">Grammar</a>
</li>
<li>
<a href="#toc_10">Checking your source code</a>
</li>
</ul>
</li>
</ul>
<p>** Under development.**</p>

<h1 id="toc_0">Ownership checks for C</h1>

<p>The static ownership check is an experimental feature for Cake.
It consists of two separate implementations. </p>

<p>The first implementation focuses on introducing the concept of an owner qualifier in the type system. </p>

<p>The second implementation revolves around flow analysis, ensuring that owned resources are appropriately released when necessary.   </p>

<p>By implementing the static ownership check, and using the feature on it&#39;s own source, Cake aims to explore and evaluate the effectiveness of this feature.</p>

<p>Once you experience checked coded, there&#39;s no turning back!</p>

<h2 id="toc_1">Part I - Type system changes</h2>

<h3 id="toc_2">New Type qualifiers</h3>

<pre><code class="language-c">type-qualifier:
  ...
  _Owner or owner
  _View or view
  _Bbj_owner  or obj_owner
</code></pre>

<p>The <strong>owner</strong> qualifier can be used when declaring a variable to indicate that its value represents a reference to a resource that must be released exclusively through that reference.</p>

<p>The <strong>view</strong> qualifier is the default for any variable, indicating that the variable is not responsible for releasing a resource, even if it has access to it. View qualified object does not control the lifetime of the resource, which must exist beyond the lifespan of the view qualified object itself.</p>

<p>The <strong>owner</strong> qualifier, when used with a pointer, indicates that the pointer assumes ownership of both the pointed object and its associated memory.</p>

<p>When converting a owner pointer to void*, only the ownership of the memory is moved.</p>

<pre><code class="language-c">void * owner f1(){
  struct X * owner p = malloc(sizeof (struct X));
  return p; //error 
}
</code></pre>

<p>Conversely, the <strong>_Obj_owner</strong> qualifier is exclusively applicable to pointers, signifying that the pointer owns the pointed object but not the memory it occupies.</p>

<blockquote>
<p>Design note: Maybe an alternative to <strong>_Obj_owner</strong> could references for C, but only in function parameters.  </p>
</blockquote>

<p>For struct and unions, if at least one member has the <strong>owner</strong> qualifier, the entire type is considered to be an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">struct person {
  char * owner name;
};

int main(){
  struct person p1 = {};
  // same as owner struct person p1;
}
</code></pre>

<p>Applying the <strong>view</strong> qualifier to an struct or union type designates the type as a view, regardless of whether it includes members owner qualified.</p>

<pre><code class="language-c">struct person {
  char * owner name;
};

int main(){
  view struct person p2;
   //p2      is view qualified  
   //p2.name is view qualified
}
</code></pre>

<p>Similarly of what happens with structs and unions, if the element of the array is owner qualified the entire array is treated as an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">int main()
{
  struct person a[10] = {};  
  //a is the owner of 10 struct person
}
</code></pre>

<p>When array types are used in parameters the array is not considered owner qualified type. </p>

<pre><code class="language-c">void print_array(int n, struct person a[10]);

int main()
{
  struct person a[10] = {};
  print_array(10, a);
}
</code></pre>

<p>To qualify array parameters as owner we do:</p>

<pre><code class="language-c">void destroy_array(int n, struct person a[owner 10]);
</code></pre>

<h3 id="toc_3">Initialization and assignment</h3>

<h4>Owner = Owner</h4>

<p>Because we must have only one owner, in this situation the ownership is moved.  </p>

<p>Although, not necessary, a new keyword <strong>move</strong> was added to make this operation more explicit.</p>

<pre><code class="language-c">owner T b;

//Initialization
owner T a = move b;
</code></pre>

<pre><code class="language-c">
owner T b;
owner T a;

//Assigment
a = move b;
</code></pre>

<p>The exception of the usage of <strong>\move</strong> is when initializing from a function result.</p>

<pre><code class="language-c">owner T make_owner();
owner T a = make_owner();
</code></pre>

<p>In assignments from functions we need to use <strong>move</strong>.</p>

<pre><code class="language-c">a = move make_owner();  
</code></pre>

<p>This reminds us about the end of lifetime of a.</p>

<h4>Owner = Non-owner</h4>

<p>This is not allowed.  </p>

<p>The exception is the initialization/assignment of owner pointers to the null pointer constant. </p>

<pre><code class="language-c">T owner * p1 = 0;       //OK
T owner * p2 = NULL;    //OK
T owner * p3 = nullptr; //OK
</code></pre>

<pre><code class="language-c">T owner * p1;
p1 = 0; //OK
</code></pre>

<blockquote>
<p>Design note: This could be extended for non pointers. The problem is we need a extra annotation to define what &quot;empty&quot; means for values other than non pointers. For instance, 0 can be valid index of a owner handle.   </p>
</blockquote>

<h4>Non-Owner = Owner</h4>

<p>In this situation we always have a view.</p>

<pre><code class="language-c">owner T b;
T a = b;            //OK
</code></pre>

<pre><code class="language-c">owner T b;
T a;
a = b;            //OK
</code></pre>

<p>We say &quot;a is a view to b&quot;.</p>

<p>We cannot have a view for a owner objects with the storage duration shorter than the view.</p>

<pre><code class="language-c">T a = make_owner(); //ERROR
</code></pre>

<pre><code class="language-c">T a;
a = make_owner(); //ERROR
</code></pre>

<pre><code class="language-c">T global;
void f()  
{    
 owner T a;
  global = a; //ERROR
}
</code></pre>

<pre><code class="language-c">
void f()  
{  
   T v;    
   {
      owner T a;
      v = a; //ERROR
   }
}
</code></pre>

<p>(The last samples are not implemented yet in cake)</p>

<h3 id="toc_4">Returning variables</h3>

<h4>Owner F() return Owner</h4>

<p>When returning local storage variables we don&#39;t use <strong>move</strong>.</p>

<pre><code class="language-c">owner T F() {
   owner T local;
   return local; //OK   
}
</code></pre>

<p>When returning non local storage variables (including function parameters) we need to use <strong>move.</strong></p>

<pre><code class="language-c">owner T global;
owner T F() {
   return global;       //ERROR
   return move global; //OK   
}
</code></pre>

<pre><code class="language-c">owner T F(owner T arg) {
   return arg;       //ERROR
   return move arg; //OK   
}
</code></pre>

<p>When returning a owner type, the caller cannot discard the result.</p>

<pre><code class="language-c"> F(); //ERROR discarding a owner result   
</code></pre>

<h4>Owner F() return Non-Owner</h4>

<p>The only possible value is null pointer constant.</p>

<pre><code class="language-c">T * owner F() {
  return 0;        // OK, or nullptr or (void*)0)
}
</code></pre>

<h4>Non-Owner F() return Owner</h4>

<p>We return a view of the object.</p>

<p>Following the general rule that view object duration must be shorter than the owner object, returning a owner local storage variable is an error.</p>

<pre><code class="language-c">T F()
{
    owner T local;
    return local; //ERROR    
} 
</code></pre>

<p>However, we can return non local variables including parameters </p>

<pre><code class="language-c">owner T global;
T F() {
   return global;       //OK (view)
}
</code></pre>

<pre><code class="language-c">T F(owner T arg) {
   return arg;         //OK (view)
}
</code></pre>

<h3 id="toc_5">Calling functions</h3>

<p>In general the rules are similar of initializing the parameter with the argument. </p>

<h4>void F(Owner); F(Owner);</h4>

<p>We explicitly use <strong>move</strong> on the caller.</p>

<pre><code class="language-c">  void F(owner T a);
  owner T a;
  F(move a);      //OK
</code></pre>

<p>We can use <strong>\implicit</strong>  to make the usage of <strong>move</strong> optional. This is useful when the semantics of the function is clear looking at it name, for instance, if the name of the function is &quot;destroy&quot; or &quot;free&quot; etc.    </p>

<p>Sample:
<code>c
void x_destroy(implicit struct X * obj_owner);
</code></p>

<blockquote>
<p>Attributes are begin considered for implicit</p>
</blockquote>

<p>The exception of using <strong>move</strong> is when passing the function result directly.</p>

<pre><code class="language-c">  void F(owner T a);
  F(make_owner()); //OK
</code></pre>

<h4>void F(Owner); F(Non-Owner);</h4>

<p>This is not allowed.<br>
The exception is the null pointer constant.</p>

<pre><code class="language-c">  F(0); //OK  
</code></pre>

<h4>void F(Non-Owner); F(Owner);</h4>

<p>Following the general rule that view object duration must be shorter than the owner object, we cannot pass owner object return by a function.</p>

<pre><code class="language-c">  F(make_owner()); //ERROR  
</code></pre>

<p>But we can pass variables, and the function parameter is a view of the argument.  </p>

<pre><code class="language-c">  owner T a; 
  F(a); //OK (view)
</code></pre>

<h2 id="toc_6">Part II - Flow analysis</h2>

<p>The objective of flow analysis is to ensure that <strong>when an owner object goes out of scope or when it is assigned it does not owns any resources</strong>.</p>

<p>We can print the object state as seen by flow analysis using <strong>static_debug</strong>.<br>
We also can assert some specific state using <strong>static_state</strong>.</p>

<p>Sample:</p>

<pre><code class="language-c">int main()
{
  int * i;  
  static_state(p, &quot;uninitialized&quot;);   

  void * owner p = 0;  
  static_state(p, &quot;null&quot;);  
  static_debug(p);
}
</code></pre>

<h3 id="toc_7">malloc/calloc</h3>

<p>A common initialization is.</p>

<pre><code class="language-c">struct X {    
    char * owner name;
};

int main() {
  struct X * owner p = malloc(sizeof (struct X));
  p-&gt;name = move strdup(&quot;hi&quot;);
}
</code></pre>

<p>We must track that object <code>p-&gt;name</code> does not have any resources before the strdup assignment. We know malloc returns an uninitialized memory but the compiler does not known. Because this is a common pattern I want to undertand this without extra annotation so semantics of malloc/realloc will be built in. </p>

<h3 id="toc_8">Disabling ownership checks</h3>

<p>We add &quot;unchecked&quot; at function definition before <code>{</code>.  </p>

<pre><code class="language-c">void f() &quot;unchecked&quot; 
{  
}
</code></pre>

<p>Disabling some parts</p>

<pre><code class="language-c">void token_delete(implicit struct token* owner p)
{
    if (p)
    {
        free(p-&gt;lexeme);
        free(p); //warning next not deleted
    }
}
</code></pre>

<h2 id="toc_9">Grammar</h2>

<pre><code class="language-c">New keywords:
  &#39;move&#39;   
  &#39;owner&#39;   
  &#39;view&#39;   
  &#39;obj_owner&#39;   
  &#39;implicit&#39;

 type-qualifier:
   ...
   &#39;owner&#39;
   &#39;view&#39;
   &#39;obj_owner&#39;

parameter-declaration:
  attribute-specifier-sequence opt &#39;implicit&#39; opt declaration-specifiers declarator  

  attribute-specifier-sequence opt &#39;implicit&#39; opt declaration-specifiers abstract-declarator opt

 argument-expression-list:
   &#39;move&#39; opt assignment-expression
   argument-expression-list , assignment-expression

 init-declarator:
   declarator
   declarator = &#39;move&#39; opt initializer

 assignment-operator:
  = 
  = move
  ...

 jump-statement:
  ...
  &#39;return&#39;;
  &#39;return&#39; &#39;move&#39; opt expression;  
 
static_debug-declaration:
  &#39;static_debug&#39; (constant-expression) ;

static_state-declaration:
  &#39;static_state&#39; (constant-expression, literal ) ;

static-declaration:  /*where static-assert is used today*/
 static_assert-declaration
 static_debug-declaration
 static_state-declaration

</code></pre>

<h2 id="toc_10">Checking your source code</h2>

<p>I suggest the creation of a header file &quot;ownership.h&quot;</p>

<pre><code class="language-c">
#pragma once

#ifdef __CAKE__
#define implicit implicit
#define owner owner
#define obj_owner obj_owner
#define move move
#define view view
  
void* owner calloc(int nmemb, int size);
void free(implicit void* owner ptr);
void* owner malloc(int size);
void* owner realloc(void* owner ptr, int size);
char * owner strdup( const char *src );
char * owner strdup( const char *str1 );

#else
#define implicit
#define owner
#define obj_owner
#define move
#define view

#endif

</code></pre>

<p>Then include this header on the top of your files and just run cake.</p>

<p>The way I am thinking is..</p>

<p>I have variables, for instance  </p>

<p>int a = 1;<br>
int b = 2;
int c = 3;  </p>

<p>if (condition) {<br>
  a = 4;<br>
  b = 5;<br>
}
else {<br>
  a = 6;<br>
  c = 7;<br>
}    </p>

<p>// a is 4 or 6<br>
// b is 2 or 5<br>
// c is 3 or 7  </p>
</body></html>  msvc
   