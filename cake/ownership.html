<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
     <link rel="stylesheet" href="style.css" />
</head>
<body>
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">One minute tour</a>
</li>
<li>
<a href="#toc_2">Move assignment</a>
</li>
<li>
<a href="#toc_3">structs/union/enum</a>
</li>
<li>
<a href="#toc_4">pointers</a>
</li>
<li>
<a href="#toc_5">destroying structs\unions</a>
</li>
<li>
<a href="#toc_6">Returning owner type</a>
</li>
<li>
<a href="#toc_7">Owner arrays</a>
</li>
<li>
<a href="#toc_8">Reality check I</a>
</li>
<li>
<a href="#toc_9">Reality check II</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">What&#39;s next?</a>
<ul>
<li>
<a href="#toc_11">Motivation</a>
</li>
</ul>
</li>
</ul>
<p>V0.4 - 01/07/2023</p>

<h1 id="toc_0">Ownership checks for C</h1>

<blockquote>
<p>This makes you feel like you&#39;re engaging in pair programming with an attentive developer working to make the program safe.</p>
</blockquote>

<h2 id="toc_1">One minute tour</h2>

<p>In this context, <em>destructor</em> is a function called before the end of lifetime of an object. The <em>lifetime</em> of an object refers to the period during which the object is accessible and valid.</p>

<p>We have a new qualifier <em>owner</em> that can be used to declare a type which requires the call of some <em>destructor</em> before the end of it&#39;s lifetime.</p>

<p>For instance, we can declare malloc as follows:</p>

<pre><code class="language-c">void * owner malloc(int 1);
</code></pre>

<p>We need the assign a owner variable to the result of malloc.</p>

<pre><code class="language-c">int main() {
  void * owner p = malloc(1);
}
</code></pre>

<p>then compiler will say
<strong>&quot;object &#39;p&#39; was not moved/destroyed&quot;</strong></p>

<p>Let&#39;s create a destructor, declaring free as:</p>

<pre><code class="language-c">void free(void * owner p);
</code></pre>

<pre><code class="language-c">int main() {
  void * owner p = malloc(1);
  free(p); //error
}
</code></pre>

<p>But the compiler will complain again.</p>

<p><strong>&quot;p cannot be moved to free implicitly, use move before the argument&quot;</strong>.  </p>

<p>Adding move before the argument it works.</p>

<pre><code>   free(move p);
</code></pre>

<p>The reason for that I want to make clear at the caller side that a variable has been moved/destroyed. </p>

<p>However, some functions have a obvious move semantic just reading the name. So for this kind of function we have  an attribute <code>[[implicit]]</code> </p>

<pre><code class="language-c">void free([[implicit]] void * owner p);
</code></pre>

<p>That makes optional the usage of <em>move</em> before the argument.</p>

<p>I hope this brief tour provides you with a glimpse of what I aim to achieve.</p>

<h2 id="toc_2">Move assignment</h2>

<p>With the introduction of the owner qualifier we need some changes in the type system.</p>

<p>In the same way we are cautious and explicit about moving a variable into a function we are with the assignment.  </p>

<p>Consider this sample</p>

<pre><code class="language-c">int main() {
  void * p1 = malloc(1);
  void * p2 = malloc(1);
  p1 = p2;
  free(p1);
  free(p2);
}
</code></pre>

<p>Assign p2 into p1 will create a memory leak of p1 object and double free of p2 object. </p>

<p>To be more explicit about this I created the move assignment</p>

<pre><code>p1 = move p2;
</code></pre>

<p>The generated code for this assignment is identical of the normal assignment.</p>

<p>After any move (assignment or function argument) the object transitions into an uninitialized state. Again nothing in runtime, this is just a state for the static analyzer.</p>

<p>Returning to our sample</p>

<pre><code class="language-c">int main() {
  void * owner p1 = malloc(1);
  void * owner p2 = malloc(1);
  p1 = move p2;
  free(p1);
  free(p2);
}
</code></pre>

<p>Compiler will complain <strong>&quot;p1 not moved/destroyed&quot; before the assignment&quot;</strong>.</p>

<p>So, this is how we can fix that.</p>

<pre><code class="language-c">int main() {
  void * owner p1 = malloc(1);
  void * owner p2 = move p1;
  free(p2);
}
</code></pre>

<p>In case you try to use <code>p1</code> after moving it the compile will complain 
<code>warning : using a uninitialized variable</code>.</p>

<p>In some cases, we will not be able to check if object is initialized or not.</p>

<pre><code class="language-c">struct X { char * owner name; };
void some_function(struct X * p) {
  p-&gt;name = strdup(&quot;new text&quot;);
}
</code></pre>

<p>The compiler will have to say   </p>

<p><code>the state of &#39;p-&gt;name&#39; cannot be determinated. You can use assertion or attribute [[unitialized]] or destroy the object before the assigment</code></p>

<p>This is what we need to do</p>

<pre><code class="language-c">  free(p-&gt;name);
  p-&gt;name = strdup(&quot;new text&quot;);
</code></pre>

<p>or
<code>c
  assert(p-&gt;name == NULL);
  p-&gt;name = strdup(&quot;new text&quot;);
</code>
or
<code>c
  [[unitialized]] p-&gt;name = move strdup(&quot;new text&quot;);
</code></p>

<h2 id="toc_3">structs/union/enum</h2>

<p>We can apply the <code>owner</code> qualifier like this</p>

<pre><code class="language-c">int main() {
 owner struct X x = {};
}
</code></pre>

<p>It works. However, imagine you  forgot to put the qualifier in a object that needs a destructor? Then we have a leak.</p>

<p>For this reason, we have an extra syntax for objects with tags.</p>

<pre><code class="language-c">struct owner X {
...
}
</code></pre>

<p>The consequence is that object is <code>owner</code> qualified by default.</p>

<pre><code class="language-c">int main() {
   struct X x = {};    
} //**&quot;object &#39;x&#39; was not moved/destroyed&quot;**
</code></pre>

<h2 id="toc_4">pointers</h2>

<p>So far, the samples with pointers were using <code>void *</code>.  </p>

<p>Now consider this situation:</p>

<pre><code class="language-c">struct owner X { char * owner name; };
int main() {
   struct X * owner p = new_x();    
}
</code></pre>

<p>p is a owner pointer to a owner object. In this case the pointer is the owner of the memory and the object. Moving the pointer will move the both responsibilities, destroy the object and the memory.</p>

<p>Consider this sample</p>

<pre><code class="language-c">
void x_delete([[implicit]] struct X * owner p) 
{
   if (p){
      p-&gt;free(name);
      free(p);
   }
}
int main() {
   struct X * owner p = new_x();
   x_delete(p);   
} 
</code></pre>

<p>and compare with</p>

<pre><code class="language-c">int main() {
   struct X * owner p = new_x();
   if (p){
      p-&gt;free(name);
      free(p);
   }   
} 
</code></pre>

<p>The checks necessary inside the <code>x_delete</code> are exactly the same of the checks necessary in <code>main</code>. This shows that there is nothing especial about the <em>destructors</em>.</p>

<p>What compiler will have to do check each of it&#39;s owner member separately.</p>

<pre><code class="language-c">int main() {
   struct X * owner p = new_x();
   if (p){
      free(p-&gt;name);
      free(p);
   }   
} 
</code></pre>

<p>Having this in a specialized function makes the life of the compiler much easier because the flow analysis is simpler. You have to help the compiler to let it help you.</p>

<p>One more detail, when we free the owner pointer using <code>void*</code> the compiler assumes we are destroying the memory not the pointed object. So it the pointed object is owner the compiler has to check the object is destroyed first. In this sample, <code>free(p-&gt;name);</code> was the only owner member of the struct, so it was safe to call <code>free</code> on p.  </p>

<h2 id="toc_5">destroying structs\unions</h2>

<p>Consider:</p>

<pre><code>struct owner X { char * owner name; };
void x_destroy([[implicit]] struct X x) 
{
   free(x.name);
}
int main() {
   struct X x;
   x_destroy(x);   
} 
</code></pre>

<p>This code is correct and works.   </p>

<p>But let&#39;s say you want to pass the struct using a pointer.</p>

<pre><code>void x_destroy([[implicit]] struct X * p) {
   free(p-&gt;name);
}
</code></pre>

<p>The problem is that if we pass a owner pointer the compiler will think we want to destroy the object and the memory. But the object is on the stack and we need to destroy only the object.</p>

<p>To fix this, we have a qualifier <code>obj_owner</code> that can be used only for pointers.   </p>

<pre><code>void x_destroy([[implicit]] struct X * obj_owner p) {
   free(p-&gt;name);
}
</code></pre>

<p>It means the pointer is the owner of the object but not the owner of the memory.</p>

<h2 id="toc_6">Returning owner type</h2>

<p>Returning a owner variable is the same of moving it. No need to use <code>move</code>;</p>

<pre><code class="language-c">struct list make()
{
  struct list {...};
  return list;
}
</code></pre>

<h2 id="toc_7">Owner arrays</h2>

<p>As expected arrays and pointer are related. 
We place owner inside together with the array size.</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X a[owner 100];
  array_destroy(100, a);
}
</code></pre>

<p>We can pass owner pointer.</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_destroy(100, p);
  free(p);
}
</code></pre>

<p>by convention passing owner pointer to array destructor will not transfer the memory ownership.</p>

<p>To destroy both we use:</p>

<pre><code class="language-c">void array_delete(int n, struct X * owner p)
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_delete(100, p);  
}
</code></pre>

<h2 id="toc_8">Reality check I</h2>

<p>Let&#39;s check if these rules can help us with <code>fopen/fclose</code>.</p>

<pre><code class="language-c">FILE* owner fopen(char const* name,char const* mode);
int fclose([[implicit]] FILE* owner f);
</code></pre>

<pre><code class="language-c">int main() {
  FILE * owner p = fopen(&quot;text.txt&quot;, &quot;r&quot;);
  if (p) {
    fclose(p);
  }
}
</code></pre>

<p>We have a problem, because the not all control paths are calling the destructor and the compiler will emit an warning.</p>

<p>However, the code is correct because we don&#39;t need, and we cannot, call fclose on null pointer.</p>

<p>To solve this problem we also need null-checks in your static analyzer.  </p>

<p>The compiler will not emit warning if it can prove that a owner variable is empty or uninitialized at the end of lifetime. </p>

<h2 id="toc_9">Reality check II</h2>

<pre><code class="language-c">int main()
{
  FILE * owner f = NULL;
  if (fopen_s( &amp;f,&quot;f.txt&quot;, &quot;r&quot;) == 0)  {
    fclose([[initialized]] f);
  }
  [[uninitialized]] f;
}
</code></pre>

<p>When the initialization must be checked using a result code, we don&#39;t have this semantics and the compiler does not know that. The solution is an annotation. [[initialized]]</p>

<h1 id="toc_10">What&#39;s next?</h1>

<p>Implement this in cake.
<a href="http://thradams.com/cake/index.html">http://thradams.com/cake/index.html</a>
The hard part is the flow analysis.</p>

<h2 id="toc_11">Motivation</h2>

<blockquote>
<p>I put the motivation at the end, because these memory safety guarantees are already a hot topic, and the motivation is already present when someone reads this.</p>
</blockquote>

<p>In C, resources such as memory are managed manually. For example, we utilize the <code>malloc</code> function to allocate memory and store the resulting address in a variable. When the memory is no longer needed, we need the address returned by <code>malloc</code> to be able to call <code>free</code>.  </p>

<p>Therefore, the variable holding the address is considered the owner of the memory, as this address cannot be simply discarded, otherwise we have a memory leak.</p>

<p>Resource leaks pose a significant challenge as they tend to be silent problems that don&#39;t immediately impact a program&#39;s behavior or cause immediate issues. Moreover, they can easily go unnoticed during unit tests, creating a false sense of security. Therefore, it is absolutely crucial to address and track these problems early on. By doing so, not only can potential complications be prevented, but it can also save valuable time and resources in the long run.</p>

<p>This checks also prevent double free, or use after free.   Both problems generally fail fast in runtime, but it is also good to have.</p>
</body></html>