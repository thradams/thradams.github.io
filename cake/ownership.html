<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
     <link rel="stylesheet" href="style.css" />
</head>
<body>
    <article style="max-width: 40em; margin:auto">
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake - C23 and Beyond</h1>
<ul>
<li>
<a href="#toc_0">Ownership checks for C</a>
<ul>
<li>
<a href="#toc_1">Part I - Type system changes</a>
<ul>
<li>
<a href="#toc_2">New qualifiers</a>
</li>
<li>
<a href="#toc_3">Semantics</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Part II - Flow analysis</a>
<ul>
<li>
<a href="#toc_5">malloc/calloc</a>
</li>
<li>
<a href="#toc_6">Disabling ownership checks</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">Grammar</a>
</li>
<li>
<a href="#toc_8">Checking your source code</a>
</li>
</ul>
</li>
</ul>
<p>** Under development.**</p>

<h1 id="toc_0">Ownership checks for C</h1>

<p>The static ownership check is an experimental feature for Cake.
It consists of two separate implementations. </p>

<p>Part I focuses on introducing the concept of an owner qualifier in the type system and does not requires flow analysis. </p>

<p>Part II requires flow analysis, ensuring that owned resources are appropriately released when necessary.   </p>

<p>By implementing the static ownership check, and using the feature on it&#39;s own source, Cake aims to explore and evaluate the effectiveness of this feature.  </p>

<h2 id="toc_1">Part I - Type system changes</h2>

<h3 id="toc_2">New qualifiers</h3>

<pre><code class="language-c">type-qualifier:
  ...
  owner
  view
  obj_owner
</code></pre>

<blockquote>
<p>The exactly name of the new qualifiers still not defined. It can be something like <code>_Owner</code> or just <code>owner</code>.   In any case, my suggestion is to have macros for each qualifier to to be able to compile the same source code in compilers that don&#39;t support ownership checks. </p>
</blockquote>

<p>The <strong>owner</strong> qualifier can be used when declaring a variable to indicate that its value represents a reference to a resource that must be released exclusively through that reference.</p>

<p>The <strong>view</strong> qualifier is the default for any variable, indicating that the variable is not responsible for releasing a resource, even if it has access to it.   </p>

<p>View qualified objects does not control the lifetime of the resource, which must exist beyond the lifespan of the view qualified object itself.</p>

<p>The <strong>owner</strong> qualifier, when used with a pointer, indicates that the pointer assumes ownership of the pointed object and its associated memory.   </p>

<p>For this reason, when converting a owner pointer to <code>void*</code>, only the ownership of the memory is moved.</p>

<p>For instance,  </p>

<pre><code class="language-c">void * owner f1(){
  struct X * owner p = malloc(sizeof (struct X));
  p-&gt;name = strdup(&quot;a&quot;);
  return p; 
}
</code></pre>

<p>Returning a <code>void *</code> may leak <code>p-&gt;name</code> so we need a explicit cast <code>return (void * owner) p</code> if we want to do that.</p>

<p>The <strong>obj_owner</strong> qualifier is exclusively applicable to pointers, meaning that the pointer owns the pointed object but not the memory it occupies. It is generally used in destructors.    </p>

<blockquote>
<p>It was not defined yet if this qualifier makes sense (is useful) in other scenarios other than function parameters.</p>
</blockquote>

<pre><code class="language-c">void x_destroy(struct X * obj_owner p) {  
  //p is the onwer of struct X but it is not 
  //the owner of the memory X occupies.
}  
int main() {  
  struct X x = {};
  x_destroy(&amp;x);  
}
</code></pre>

<p>For struct and unions, if at least one member has the <strong>owner</strong> qualifier, the entire type is considered to be an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">struct person {
  char * owner name;
};  

int main(){
  struct person p1 = {};  
  /*p1 is a owner type*/
}
</code></pre>

<p>Applying the <strong>view</strong> qualifier to an struct or union type designates the type as a view, regardless of whether it includes members owner qualified.</p>

<pre><code class="language-c">struct person {
  char * owner name;
};

int main(){
  view struct person p2;
   //p2      is view qualified  
   //p2.name is view qualified
}
</code></pre>

<p>Similarly of what happens with structs and unions, if the element of the array is owner qualified the entire array is treated as an owner qualified type.</p>

<p>Sample:</p>

<pre><code class="language-c">int main()
{
  struct person a[10] = {};  
  //a is the owner of 10 struct person
}
</code></pre>

<p>When array types are used in parameters the array is not considered owner qualified type. </p>

<pre><code class="language-c">void print_array(int n, struct person a[10]);

int main()
{
  struct person a[10] = {};
  print_array(10, a);
}
</code></pre>

<p>To qualify array parameters as owner we do:</p>

<pre><code class="language-c">void destroy_array(int n, struct person a[owner 10]);
</code></pre>

<p>The most common usage of <strong>owner</strong> will be pointers. However, ownership qualifiers can be applied for any type. One reason is because we can use other types as references to resources, for instance, we can use a integer.</p>

<pre><code class="language-c">owner int handle = make_resource();
release_resource(handle);
</code></pre>

<p>Pointers have the additional advantage of having a natural zero semantics.   </p>

<p>What is the empty value for handle for instance?</p>

<p>Obs:
owner pointer to function should be error.</p>

<p>The owner and obj_owner qualifiers should not be applicable to function objects.  </p>

<h3 id="toc_3">Semantics</h3>

<p>1 - When a owner object is copied to another owner object the ownership is always moved/transfered.</p>

<p>Copy happens when we return values, call functions, initialization and assignment.</p>

<p>Samples:</p>

<pre><code class="language-c">
T* owner make_owner() {  
   T* owner  p = ...
   return p; /*moved*/
}

T * owner b = make_owner(); /*moved*/
T * owner a = 0;
a = b; /*moved*/;  

void f(T * owner a);
f(a); /*moved*/
</code></pre>

<p>The object that receives the value must not hold any resource. This is natural in initialization and function arguments. </p>

<p>For assignment it needs to be checked with flow analysis (part II).</p>

<p>2 - A non owner object cannot be copied to a owner object.   </p>

<p>The only exception is the null pointer constant when copied to owner pointers.</p>

<pre><code class="language-c">T * owner f() {
  return 0; //OK
}
</code></pre>

<p>3 - An owner object can be copied to a non-owner object if its lifetime is longer than that of the non-owner object.  </p>

<p>We can the non-owner object a &quot;view&quot; in this case. </p>

<pre><code class="language-c">T F()
{
    owner T local;
    return local; /*error*/
} 
</code></pre>

<pre><code class="language-c">owner T global;
T F() {
   return global; //OK
}
</code></pre>

<pre><code class="language-c">T F(owner T arg) {
   return arg; //OK
}
</code></pre>

<pre><code class="language-c">  void F(T * p);
  F(make_owner()); //ERROR  
</code></pre>

<pre><code class="language-c">  T  *p = make_owner(); //ERROR
</code></pre>

<pre><code class="language-c">  T  *p = 0;  
  {
    T * owner p2 = make_owner();  
    p = p2; //error  
    free(p2);
  }
</code></pre>

<p>4 - Temporary owner objects cannot be discarded/ignored  </p>

<pre><code class="language-c">  make_owner(); //ERROR  
</code></pre>

<pre><code class="language-c">  void f(T * owner ) /*ERROR no name*/  
  {
  }  
</code></pre>

<h2 id="toc_4">Part II - Flow analysis</h2>

<p>The objective of flow analysis is to ensure that when an owning object goes out of scope or before its memory is overridden, it has released all of its resources.</p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = fopen(&quot;file&quot;, &quot;r&quot;);  
  if (f){  
      fclose(f);
  }
</code></pre>

<p>Flow analysis must know that when f goes of of scope it does not owns any resource. </p>

<blockquote>
<p>Note: In cake, we can print the object state   as seen by flow analysis using <strong>static_debug(expression)</strong>.
We also can assert some specific state using <strong>static_state(expression, &quot;state&quot;)</strong>.</p>
</blockquote>

<p>To track ownership fours states are used &quot;uninitialized&quot;, &quot;moved&quot;, &quot;null&quot; and &quot;not null&quot;.  </p>

<pre><code class="language-c">T * p;  
/* p is uninitialized*/  
</code></pre>

<p>Pointers can have the state &quot;null&quot; or &quot;not-null&quot;.  The combination of &quot;null or not-null&quot; is also called &quot;maybe-null&quot;.  </p>

<pre><code class="language-c">T * owner p = 0;  
/* p is null*/  

T * owner p2 = malloc(sizeof(T));  
/* p2 is maybe-null*/
</code></pre>

<p>When one owner object is copied to another the state of the source object is &quot;moved&quot;.  The state of the destination object is the same of the previous state of the source object.</p>

<pre><code class="language-c">T * owner p = 0;  
T * owner p2 = malloc(sizeof(T));  
  
/*p1 is null*/  
/*p2 is maybe-null*/
  
p = p2;  

/*p2 is moved*/  
/*p1 is maybe-null*/

</code></pre>

<p>The exception is when we move owner objects into functions, then the state is &quot;uninitialized&quot;. This prevents use after free or concurrency problems.</p>

<pre><code class="language-c">  T * owner p = malloc(sizeof(T));  
  free(p);
  /* p is uninitialized*/
</code></pre>

<p>The object state is a composition (set) of all possible states.  </p>

<p>Sample:  </p>

<pre><code class="language-c">  FILE * owner f = 0;  
  if (condition){    
      f = fopen(&quot;file&quot;, &quot;r&quot;);
      fclose(f);
  } /*f is &quot;null&quot; or &quot;moved&quot; */
</code></pre>

<p>When an owning pointer goes out of scope and before its memory is overridden it cannot have &quot;not-null&quot; in its set state.   </p>

<p>All others possibilities are permitted. For instance, the state can be &quot;null or uninitialized&quot; or &quot;null or moved&quot;.</p>

<p>When an owning object (non pointer) goes out of scope and before its memory is overridden it must be on &quot;uninitialized&quot; or &quot;moved&quot; or 
&quot;uninitialized or moved&quot; state otherwise we have a leak.</p>

<pre><code class="language-c">owner int handle = make_resource();
release_resource(handle);
</code></pre>

<p>We don&#39;t have semantics information to know for instance if handle 0 is valid or not.</p>

<p>Each member of aggregate objects is checked individually. </p>

<h3 id="toc_5">malloc/calloc</h3>

<p>A common initialization is.</p>

<pre><code class="language-c">struct X {    
    char * owner name;
};

int main() {
  struct X * owner p = malloc(sizeof (struct X));
  p-&gt;name =  strdup(&quot;hi&quot;);
}
</code></pre>

<p>We must track that object <code>p-&gt;name</code> does not have any resources before the strdup assignment. We know malloc returns an uninitialized memory but the compiler does not known.  For this particular case the semantics of malloc/calloc will be built-in; So the static analyzer will know malloc returns a uninitialized memory and calloc return a zeroed memory.</p>

<h3 id="toc_6">Disabling ownership checks</h3>

<p>Some functions can have a intricate logic of pointers and instead of trying to adapt the logic we know is correct, we can just annotate &quot;unchecked&quot; at function definition.  </p>

<pre><code class="language-c">void f() &quot;unchecked&quot; {  
}
</code></pre>

<blockquote>
<p>This is also expected to be used with a macro, so compiler without ownership checks will just ignore.</p>
</blockquote>

<p>assert can be used to override the static analysis state.</p>

<pre><code class="language-c">/* linked list sample */

struct node {
 struct node* owner next;
};

struct list {
  struct node * owner head;
  struct node * tail;
};

void node_delete(struct node* owner p) {
  if (p) {  
     /*  
       flow analysis will assume   
       p-&gt;next is null and safe to be   
       ignored  
     */
     assert(p-&gt;next == NULL);
     free(p);
  }
}

void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      p-&gt;next = NULL;
      node_delete(p);
      p = next;
  }
}
</code></pre>

<p>list_destroy can be implemented as follow:</p>

<pre><code class="language-c">void list_destroy(struct list* obj_owner list)
{
  struct node * owner p = list-&gt;head;
  while (p) {
      struct node *  owner next = p-&gt;next;
      free(p);
      p = next;
  }
}
</code></pre>

<p>We don&#39;t need assert here because compiler knows &quot;p-&gt;next&quot; has been moved. We don&#39;t have a way do override the static analysis state &quot;moved&quot; or &quot;uninitialized&quot; using assert.</p>

<p>TODO</p>

<pre><code class="language-c">void f(struct X *p){
  move(p-&gt;item);
} //error &#39;p-&gt;item&#39; was left uninitialized  
</code></pre>

<h2 id="toc_7">Grammar</h2>

<pre><code class="language-c"> 
 type-qualifier:
   ...
   &#39;owner&#39;
   &#39;view&#39;
   &#39;obj_owner&#39;

static_debug-declaration:
  &#39;static_debug&#39; (constant-expression) ;

static_state-declaration:
  &#39;static_state&#39; (constant-expression, literal ) ;

static-declaration:  /*where static-assert is used today*/
 static_assert-declaration
 static_debug-declaration
 static_state-declaration

TODO &quot;unchecked&quot;
</code></pre>

<h2 id="toc_8">Checking your source code</h2>

<p>I suggest the creation of a header file &quot;ownership.h&quot;</p>

<pre><code class="language-c">
#pragma once

#ifdef __CAKE__
#define owner owner
#define obj_owner obj_owner
#define view view
  
void* owner calloc(int nmemb, int size);
void free(implicit void* owner ptr);
void* owner malloc(int size);
void* owner realloc(void* owner ptr, int size);
char * owner strdup( const char *src );

#else
#define owner
#define obj_owner
#define view

#endif

</code></pre>

<p>Then include this header on the top of your files and just run cake.</p>

<p>The way I am thinking is..</p>

<p>I have variables, for instance  </p>

<p>int a = 1;<br>
int b = 2;
int c = 3;  </p>

<p>if (condition) {<br>
  a = 4;<br>
  b = 5;<br>
}
else {<br>
  a = 6;<br>
  c = 7;<br>
}    </p>

<p>// a is 4 or 6<br>
// b is 2 or 5<br>
// c is 3 or 7  </p>
</body></html>  msvc
   