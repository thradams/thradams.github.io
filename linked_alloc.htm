<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->

<h2> Linked malloc</h2>

<p>This code implements an allocator that accepts a destructor for each item.</p>

<p>It calls the destructor if not null before free.</p>

<p>Items can be removed using free (double linked list for this) but they alsowill be destroyed together with the allocator.</p>

<p>Removing allocator</p>


<p>Sample:</p>
<pre>

<span class="keyword">#include</span> &lt;stdio.h&gt;
<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>.h&gt;


<span class="keyword">union</span> header {
    <span class="keyword">struct</span> {
        <span class="keyword">union</span> header* prev; <span class="comment">/* next block*/</span>
        <span class="keyword">union</span> header* next; <span class="comment">/* next block*/</span>
        <span class="keyword">void</span> (*DTOR)(<span class="keyword">void</span>*);     <span class="comment">/* destructor */</span>
    } s;
    <span class="keyword">long</span> <span class="keyword">double</span> x;         <span class="comment">/* force alignment of blocks */</span>
};

<span class="keyword">struct</span> allocator
{
    <span class="keyword">union</span> header* head;
};

<span class="keyword">void</span>* alloc(<span class="keyword">struct</span> allocator* allocator, <span class="keyword">int</span> nbytes, <span class="keyword">void</span> (*F)(<span class="keyword">void</span>*))
{
    <span class="keyword">int</span> nunits = (nbytes + <span class="keyword">sizeof</span>(<span class="keyword">union</span> header) - <span class="number">1</span>) / <span class="keyword">sizeof</span>(<span class="keyword">union</span> header) + <span class="number">1</span>;
    <span class="keyword">union</span> header* p = malloc(nunits * <span class="keyword">sizeof</span>(<span class="keyword">union</span> header));
    <span class="keyword">if</span> (p)
    {
        p-&gt;s.prev = NULL;
        p-&gt;s.next = allocator-&gt;head;
        p-&gt;s.DTOR = F;
        <span class="keyword">if</span> (allocator-&gt;head != NULL)
        {
            allocator-&gt;head-&gt;s.prev = p;
        }
        allocator-&gt;head = p;


        <span class="keyword">return</span> (<span class="keyword">void</span>*)(p + <span class="number">1</span>);
    }
    <span class="keyword">return</span> NULL;
}
<span class="keyword">void</span> allocator_free(<span class="keyword">struct</span> allocator* allocator, <span class="keyword">void</span>* p)
{

    <span class="keyword">union</span> header* del = ((<span class="keyword">union</span> header*)p) - <span class="number">1</span>;

    <span class="comment">/* If node to be deleted is head node */</span>
    <span class="keyword">if</span> (allocator-&gt;head == del)
        allocator-&gt;head = del-&gt;s.next;

    <span class="comment">/* Change next only if node to be
    deleted is NOT the last node */</span>
    <span class="keyword">if</span> (del-&gt;s.next != NULL)
        del-&gt;s.next-&gt;s.prev = del-&gt;s.prev;

    <span class="comment">/* Change prev only if node to be
    deleted is NOT the first node */</span>
    <span class="keyword">if</span> (del-&gt;s.prev != NULL)
        del-&gt;s.prev-&gt;s.next = del-&gt;s.next;


    <span class="keyword">if</span> (del-&gt;s.DTOR)
    {
        <span class="keyword">void</span>* pobj = (<span class="keyword">void</span>*)((<span class="keyword">union</span> header*)p + <span class="number">1</span>);
        del-&gt;s.DTOR(pobj);
    }

    <span class="comment">/* Finally, free the memory occupied by del*/</span>
    free(del);
    <span class="keyword">return</span>;

}

<span class="keyword">void</span> allocator_destroy(<span class="keyword">struct</span> allocator* allocator)
{
    <span class="keyword">union</span> header* p = allocator-&gt;head;
    <span class="keyword">while</span> (p)
    {
        <span class="keyword">union</span> header* next = p-&gt;s.next;
        <span class="keyword">if</span> (p-&gt;s.DTOR)
        {
            <span class="keyword">void</span>* pobj = (<span class="keyword">void</span>*)((<span class="keyword">union</span> header*)p + <span class="number">1</span>);
            p-&gt;s.DTOR(pobj);
            free(p);
        }
        p = next;
    }
}

<span class="keyword">struct</span> X
{
    <span class="keyword">char</span>* name;
};

<span class="keyword">void</span> DestroyX(<span class="keyword">struct</span> X* p)
{
    printf(<span class="string">&quot;DestroyX&quot;</span>);
}

<span class="keyword">int</span> main()
{
    <span class="keyword">struct</span> allocator allocator = { <span class="number">0</span> };
    <span class="keyword">struct</span> X* pX = alloc(&amp;allocator, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X), DestroyX);
    <span class="keyword">if</span> (pX)
    {
        pX-&gt;name = alloc(&amp;allocator, strlen(<span class="string">&quot;teste&quot;</span>), NULL);
        strcpy(pX-&gt;name, <span class="string">&quot;teste&quot;</span>);
        allocator_free(&amp;allocator, pX-&gt;name);
    }

    allocator_free(&amp;allocator, pX);

    allocator_destroy(&amp;allocator);
}


</pre>



<p>Without free.</p>

<pre>

<span class="keyword">#include</span> &lt;stdio.h&gt;
<span class="keyword">#include</span> &lt;stdlib.h&gt;.
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>.h&gt;


<span class="keyword">union</span> header {
    <span class="keyword">struct</span> {
        <span class="keyword">union</span> header* next; <span class="comment">/* next block*/</span>
        <span class="keyword">void</span> (*DTOR)(<span class="keyword">void</span>*);     <span class="comment">/* destructor */</span>
    } s;
    <span class="keyword">long</span> <span class="keyword">double</span> x;         <span class="comment">/* force alignment of blocks */</span>
};

<span class="keyword">struct</span> allocator
{
    <span class="keyword">union</span> header* head;
};

<span class="keyword">void</span>* alloc(<span class="keyword">struct</span> allocator* allocator, <span class="keyword">int</span> nbytes, <span class="keyword">void</span> (*F)(<span class="keyword">void</span>*))
{
    <span class="keyword">int</span> nunits = (nbytes + <span class="keyword">sizeof</span>(<span class="keyword">union</span> header) - <span class="number">1</span>) / <span class="keyword">sizeof</span>(<span class="keyword">union</span> header) + <span class="number">1</span>;
    <span class="keyword">union</span> header* p = malloc(nunits * <span class="keyword">sizeof</span>(<span class="keyword">union</span> header));
    <span class="keyword">if</span> (p)
    {        
        p-&gt;s.next = allocator-&gt;head;
        p-&gt;s.DTOR = F;        
        allocator-&gt;head = p;


        <span class="keyword">return</span> (<span class="keyword">void</span>*)(p + <span class="number">1</span>);
    }
    <span class="keyword">return</span> NULL;
}

<span class="keyword">void</span> allocator_destroy(<span class="keyword">struct</span> allocator* allocator)
{
    <span class="keyword">union</span> header* p = allocator-&gt;head;
    <span class="keyword">while</span> (p)
    {
        <span class="keyword">union</span> header* next = p-&gt;s.next;
        <span class="keyword">if</span> (p-&gt;s.DTOR)
        {
            <span class="keyword">void</span>* pobj = (<span class="keyword">void</span>*)((<span class="keyword">union</span> header*)p + <span class="number">1</span>);
            p-&gt;s.DTOR(pobj);
            free(p);
        }
        p = next;
    }
}

<span class="keyword">struct</span> X
{
    <span class="keyword">char</span>* name;
};

<span class="keyword">void</span> DestroyX(<span class="keyword">struct</span> X* p)
{
    printf(<span class="string">&quot;DestroyX&quot;</span>);
}

<span class="keyword">int</span> main()
{
    <span class="keyword">struct</span> allocator allocator = { <span class="number">0</span> };
    <span class="keyword">struct</span> X* pX = alloc(&amp;allocator, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X), DestroyX);
    <span class="keyword">if</span> (pX)
    {
        pX-&gt;name = alloc(&amp;allocator, strlen(<span class="string">&quot;teste&quot;</span>), NULL);
        strcpy(pX-&gt;name, <span class="string">&quot;teste&quot;</span>);
        
    }
    

    allocator_destroy(&amp;allocator);
}


</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  