<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->

<h2>Almost generic member function pointer</h2>

<p>Motivation:</p>


<p>I have a class called MyDialog.\\Inside it, I have a Button that needs to send events to MyDialog.</p>

<p>For instance, button.OnClick should call &quot;MyDialog::ButtonClick&quot;.</p>

<p>of MyDialog and I want to use this pointer to call functions of MyDialog. (Button events)</p>

<p>In other words, the button needs to call functions in an unknown type. But he knows that it will be inserted inside a dialog or some class derived from dialog.</p>

<p>The simple solution is to use std::function and bind.</p>

<pre>

<span class="keyword">struct</span> Button {
 Dialog* parent;
 std::<span class="keyword2">function</span>&lt;<span class="keyword">void</span> (<span class="keyword">void</span>)&gt; onclick;
};

<span class="keyword">struct</span> MyDialog : <span class="keyword">public</span> Dialog {
 Button btn;
 MyDialog()  {
   btn.parent = <span class="keyword">this</span>;
   btn.onclick = &amp;std::bind(MyDialog::OnBtnClick, <span class="keyword">this</span>);
 }
 <span class="keyword">void</span> OnBtnClick() {}
};

</pre>


<p>The std::function will cost 24 bytes plus 24 bytes of bind dynamicallocation (using VC++).</p>


<p>Instead of to keep one pointer for each event I would like to use the pointer I already have in Button to call all events in MyDialog.</p>



<p>Solution:</p>

<p>The button class doesn't known &quot;MyDialog&quot;, but it knowns a function signature that can make the call casting from Dialog to MyDialog.</p>

<p>If the class Dialog is polimorphic we can use dynamic</p>

<p>For non polimorphic classes, the programmer must ensure that the pointer will point do some object of the type MyDialog. The static</p>

<pre>

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> KnownType, <span class="keyword">void</span> (T::*pmf)(<span class="keyword">void</span>)&gt;
<span class="keyword">void</span> call(KnownType* pobject)
{
 <span class="comment">// programer responsability
</span> T* p = <span class="keyword">static_cast</span>&lt;T*&gt;(pobject);

 <span class="comment">//runtime check if avaiable (polimorphic type)
</span> <span class="comment">//p = dynamic_cast&lt;T*&gt;(pobject);
</span>
 (p-&gt;*pmf)();
}

<span class="keyword">typedef</span> <span class="keyword">void</span> (*OnClickEvent)(Dialog*);

<span class="keyword">struct</span> Button {
 Dialog* parent;
 OnClickEvent onclick;
};

<span class="keyword">struct</span> MyDialog : <span class="keyword">public</span> Dialog {
 Button btn;
 MyDialog()  {
   btn.parent = <span class="keyword">this</span>;
   btn.onclick = &amp;call&lt;MyDialog, Dialog, &amp;MyDialog::OnBtnClick&gt;;
 }
 <span class="keyword">void</span> OnBtnClick() {}
};

Button::FireEvent()
{
  btn.onclick(parent);
}

</pre>


<p>This way, each event will cost 4 bytes with no dynamic memory allocation.</p>

<p>Using std::function I could call different objectsbut most of the time the call is just for parent.
<!-- Page content end --> 
</article> 
 
</body> 
</html>  