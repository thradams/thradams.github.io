
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<h2>Runtime function selection based on polimorphic arguments</h2>

<p><strong>Runtime function selection</strong> based on the runtime type of the argument.</p>



<p>Let's say you have:</p>

<pre>
<span class="keyword">void</span> Draw(box&amp; box);
<span class="keyword">void</span> Draw(circle&amp; circle);
</pre>


<p>...and a </p>
<pre>
vector&lt;unique_ptr&lt;Shape&gt;&gt; shapes;
</pre>
<p>Now, you want to select the correct function for circle or box depending of the type of &quot;shape&quot;.</p>

<p>You can do the correct selection using this library in this way.</p>

<pre>

 dynamic_select&lt;box, circle&gt;(shapes[<span class="number">0</span>].get(),
                             [](<span class="keyword">auto</span> a)
                             {
                               draw(a);            
                             });   
</pre>

<p>Works for 1 or 2 arguments. In other words, works for double dispatching.</p>

<h3>Why not virtual always?</h3>
<p>Virtual functions works fine in this case. Except for double dispathing.</p>

<p>The problem with interfaces (virtual functions) is the coupling caused by the interfaces. You cannot solve problems independently from each other; instead, you have to deal with the best set of interfaces that fits the algorithms you have so far. When you need to add or remove algorithms then you have to refactoring your interfaces for the best set again, and doing this, sometimes, can break code that is already working. It is very easy to increase coupling with interfaces, and it's hard to keep the interface sets correct. When you do it, probally the interfaces are usefull only in your especific project making your classes less reusable.</p>



<p>This is a prototype.</p>


<p>Complete sample</p>
<pre>

<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> &lt;memory&gt;
<span class="keyword">#include</span> &lt;iostream&gt;

<span class="keyword">#include</span> <span class="string">&quot;dynamic_select.h&quot;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> std;


<span class="keyword">class</span> object
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~object() {}
};

<span class="keyword">class</span> box : <span class="keyword">public</span> object
{
};

<span class="keyword">class</span> circle : <span class="keyword">public</span> object
{
};

<span class="keyword">void</span> draw(<span class="keyword">const</span> box &amp; a)
{
    std::cout &lt;&lt; <span class="string">&quot; draw &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; std::endl;
}

<span class="keyword">void</span> draw(<span class="keyword">const</span> circle &amp;a)
{
    std::cout &lt;&lt; <span class="string">&quot; draw &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; std::endl;
}

<span class="keyword">void</span> intercept(<span class="keyword">const</span> box &amp; a, <span class="keyword">const</span> circle&amp; b)
{
    std::cout &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="string">&quot; intercept &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; std::endl;
}

<span class="keyword">void</span> intercept(<span class="keyword">const</span> circle&amp; a, <span class="keyword">const</span> box &amp; b)
{
    std::cout &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="string">&quot; intercept &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; std::endl;
}

<span class="keyword">void</span> intercept(<span class="keyword">const</span> box &amp; a, <span class="keyword">const</span> box&amp; b)
{
    std::cout &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="string">&quot; intercept &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; std::endl;
}

<span class="keyword">void</span> intercept(<span class="keyword">const</span> circle &amp; a, <span class="keyword">const</span> circle&amp; b)
{
    std::cout &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="string">&quot; intercept &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; std::endl;
}

<span class="keyword">int</span> main()
{
    std::<span class="keyword2">vector</span>&lt;std::<span class="keyword2">unique_ptr</span>&lt;object&gt;&gt; v;
    v.emplace_back(<span class="keyword">new</span> box());
    v.emplace_back(<span class="keyword">new</span> circle());

    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : v)
    {
        dynamic_select&lt;box, circle&gt;(item.get(),
            [](<span class="keyword">auto</span> a)
        {
            draw(a);            
        });        
    }

    <span class="comment">//Double dispatch 
</span>    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : v)
    {
        dynamic_select&lt;box, circle&gt;(v[<span class="number">1</span>].get(),
            item.get(),
            [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)
        {
            intercept(a, b);
        });
    }

}

</pre>


<p>output</p>

<pre>
 draw class box
 draw class circle
class circle intercept class box
class circle intercept class circle
</pre>

<p>dynamic</p>
<pre>
<span class="keyword">#pragma</span> once

<span class="keyword">template</span>&lt; <span class="keyword">class</span>... Tn&gt;
<span class="keyword">struct</span> Gen2
{
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> F&gt;
    Gen2(<span class="keyword">const</span> A1 &amp; a1, <span class="keyword">const</span> A2&amp; a2, F)
    {
    }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> T1, <span class="keyword">class</span> ...Tn&gt;
<span class="keyword">struct</span> Gen2&lt;T, T1, Tn...&gt;
{
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> F&gt;
    Gen2(A1 * a1, A2* a2, F f)
    {
        <span class="keyword">if</span> (<span class="keyword">typeid</span>(T1) == <span class="keyword">typeid</span>(*a2))
        {
            f(<span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T&amp;&gt;(*a1),
              <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T1&amp;&gt;(*a2));
        }
        <span class="keyword">else</span>
        {
            Gen2&lt;T, Tn...&gt;(a1, a2, f);
        }
    }
};

<span class="keyword">template</span>&lt; <span class="keyword">class</span>... Tn&gt;
<span class="keyword">struct</span> Gen
{
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1,  <span class="keyword">class</span> F&gt;
    Gen(<span class="keyword">const</span> A1* a1,  F)
    {
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> F&gt;
    Gen(<span class="keyword">const</span> A1* a1, <span class="keyword">const</span> A2* a2, F)
    {
    }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> ...Tn&gt;
<span class="keyword">struct</span> Gen&lt;T1, Tn...&gt;
{
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1,<span class="keyword">class</span> F&gt;
    Gen(<span class="keyword">const</span> A1 * a1, F f)
    {
        <span class="keyword">if</span> (<span class="keyword">typeid</span>(T1) == <span class="keyword">typeid</span>(*a1))
        {
            f(<span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T1&amp;&gt;(*a1));
        }
        <span class="keyword">else</span>
        {
            Gen&lt;Tn...&gt;(a1, f);
        }
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> F&gt;
    Gen(<span class="keyword">const</span> A1 * a1, <span class="keyword">const</span> A2* a2, F f)
    {
        <span class="keyword">if</span> (<span class="keyword">typeid</span>(T1) == <span class="keyword">typeid</span>(*a1))
        {
            <span class="keyword">if</span> (<span class="keyword">typeid</span>(T1) == <span class="keyword">typeid</span>(*a2))
            {
                f(<span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T1&amp;&gt;(*a1),
                  <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T1&amp;&gt;(*a2));
            }
            <span class="keyword">else</span>
            {
                Gen2&lt;T1, Tn...&gt;(a1, a2, f);
            }
        }
        <span class="keyword">else</span>
        {
            Gen&lt;Tn...&gt;(a1, a2, f);
        }
    }
};


<span class="keyword">template</span>&lt;<span class="keyword">class</span> ...Tn&gt;
<span class="keyword">struct</span> dynamic_select
{
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> F&gt;
    dynamic_select(<span class="keyword">const</span> A1 * a1, F f)
    {
        Gen&lt;Tn...&gt;(a1, f);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> F&gt;
    dynamic_select(<span class="keyword">const</span> A1 * a1, <span class="keyword">const</span> A2* a2, F f)
    {
        Gen&lt;Tn..., Tn...&gt;(a1, a2, f);
    }
};


</pre>




<h2>See also</h2>

<p><a href="type ptr">type_ptr3.htm</a> Not using C++ rtti.</p>


<h2>Notes</h2>

<p>Compiled with:</p>

<p>Visual C++ Compiler Nov 2013 CTP (CTP</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  