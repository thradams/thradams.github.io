<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Local functions && Function literals</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <style>
        /* Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
        }

        body {
            background: white;
            color: black;
            overflow: hidden;
        }

        pre {
            background: #f3f3f3;
            padding: 1em;
            text-align: left;
        }

        /* Slide container */
        .presentation {
            width: 100vw;
            height: 100vh;
            position: relative;
            
        }

        /* Individual slide */
        section {
            width: 100%;
            height: 100%;
            padding: 60px;
            display: none;
            flex-direction: column;
            justify-content: center;
            max-width: 50em;
            margin: auto;
        }

        section.active {
            display: flex;
        }



        /* Titles */
        section h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            text-align: center;
        }

        section h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Text */
        section li {
            font-size: 1.3rem;
            line-height: 1.6;
        }

        ul {
            margin-left: 30px;
        }



        /* Footer */
        .footer {
            position: absolute;
            bottom: 20px;
            right: 30px;
            font-size: 0.9rem;
            opacity: 0.6;
        }

        .note {
            background-color: #ffffff;
            color: #222;
            border: 1px solid #e5e5e5;
            border-left: 4px solid #d0d0d0;

            padding: 8px 10px;
            margin: 8px 0;

            border-radius: 6px;

            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-size: smaller;
            line-height: 1.6;

            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        }


    </style>


</head>

<body>

    <div class="presentation">

        <!-------------------------------------------- Slide 1 -------------------------------------------------->
        <section class="slide active">
            <h1>Local functions <br>&&<br> Function literals</h1>
            <h2>N3678 and N3679</h2>
        </section>


        <!-------------------------------------------- Slide 2 -------------------------------------------------->
        <section>
            <h2>Motivation</h2>
            <pre><code class="language-c">
    void async(void* data, void (*callback)(int result, void* data));

    struct start_capture {
        int value;
    };

    static void start_callback(int result, void* data) {
        struct start_capture* capture = data;
        free(capture);
    }

    void start() {
       struct start_capture* capture = calloc(1, sizeof *capture);
       async(capture, start_callback);
    }
</code></pre>

        </section>

    <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>do this, then that...</h2>
            <pre><code style="font-size:10px" code class="language-c">
    void part1_async(void* data, void (*callback)(int result, void* data));
    void part2_async(void* data, void (*callback)(int result, void* data));

    struct part1_capture {
        int value;
    };

    struct part2_capture {
        char ch;
    };

    static void part2_complete(int result, void* data);

    static void part1_complete(int result, void* data) {
       struct part1_capture* capture1 = data;

        struct part2_capture* capture2 = calloc(1, sizeof *capture2);
        part2_async(capture2, part2_complete);

        free(capture2);
    }

    static void part2_complete(int result, void* data) {
       struct part2_capture* capture2 = data;
       free(capture2);
    }

    void start() {
       struct part1_capture* capture1 = calloc(1, sizeof *capture1);
       part1_async(capture1, part1_complete);
    }
</code></pre>

        </section>

        <!-------------------------------------------- Slide 3 -------------------------------------------------->
        <section>
            <h2>Local functions</h2>
            <pre><code code class="language-c">
    void async(void* data, void (*callback)(int result, void* data));

    void start() {
       
       struct capture {
            int value;
        };

       static void callback(int result, void* data) {
            struct capture* capture = data;
            free(capture);
       }
       
       struct capture* capture = calloc(1, sizeof * capture);
       async(capture, callback);
    }
</code></pre>

        </section>

        <!-------------------------------------------- Slide 4 -------------------------------------------------->
        <section>
            <h2>Literal functions</h2>
            <pre><code code class="language-c">
    void async(void* data, void (*callback)(int result, void* data));

    void start() {
       
       struct capture {
            int value;
       } capture = calloc(1, sizeof * capture);

       async(capture, (void (int result, void* data)) 
       {
          struct capture* capture = data;
          free(capture);
       });
    }
</code></pre>

        </section>



           <!-------------------------------------------- Slide -------------------------------------------------->
   <section>
       <h2>Local functions and function literals are about explicit, argument-passed captures.</h2>       
   </section>

                <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Reusing captures</h2>
            <pre><code code class="language-c">
int main()
{
    struct capture { int id; }* capture = calloc(1, sizeof * capture);
    login_async(capture,  (void (int id, void * p))
    {
        printf("login completed. id=%d\n", id);
        struct capture * cap1 = p;
        cap1->id = id;
        get_data_async(cap1 /*moved*/, (void (const char* email, void * data))
        {
            struct capture * cap2 = data;
            printf("your data='%s'  from id=%d\n", email, cap2->id);
            free(cap2);
        });
    });
}
</code></pre>
        </section>

        <!-------------------------------------------- Slide 5 -------------------------------------------------->
        <section>
            <h2>Local function syntax</h2>
            <pre>
       block-item:
           ...
            <span style="color:blue">function-definition</span>
       
       function-definition:
           attribute-specifier-sequence opt declaration-specifiers declarator function-body
     </pre>
        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Forward declarations</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   void f();
   f();
   void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code></pre>

        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>GCC Nested function solution</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   auto void f();
   f();
   void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code></pre>
            <div  class="note">See also: N3579 auto as a placeholder type specifier</div>
        </section>
        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>GCC Nested function solution</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   void f();
   f();
   /*error: static declaration of 'f' follows non-static declaration*/
   void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code></pre>

        </section>


        <!-------------------------------------------- Slide 7 -------------------------------------------------->
        <section>
            <h2>Alternative I</h2>
            <pre><code code class="language-c">
void f() { /*extern*/ }

int main() {
   
   /*local functions*/
   static void f(); /*local function declaration*/
   static void f() { }   

   /*GCC nested function*/
   auto int f2();
   int i = 1;              
   int f2() { return i; }
}
</code></pre>

        </section>

        <!-------------------------------------------- Slide 8 -------------------------------------------------->
        <section>
            <h2>Alternative II</h2>
            <pre><code code class="language-c">
void f() { /*extern*/ }

int main() {
   auto void f();
   /*auto*/ void f() { }

   auto int f2();
   int i = 1;              
   int f2() { return i; /*GCC extension*/ }   
}
</code></pre>


        </section>

                <!-------------------------------------------- Slide 8 -------------------------------------------------->
        <section>
            <h2>Alternative III</h2>
            <pre><code code class="language-c">
void f() { /*extern*/ }

int main() {
   static void f();
   void f() { }
      
   /*static*/ int f1() { return 0; }   

   int i = 1;              
   int f1() { return i; /*GCC extension*/ }   
}
</code></pre>
        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Function Literal syntax</h2>
            <pre>
      postfix-expression: 
            ...      
            <span style="color:blue">function-literal-definition</span>
  
      <span style="color:blue">function-literal-definition:
         ( attribute-specifier-sequence opt declaration-specifiers abstract-declarator ) 
              function-body 
       </span>

       function-definition:
          attribute-specifier-sequence opt declaration-specifiers declarator function-body
</pre>

       <div class="note">The abstract-declarator portion of a function literal definition must have a function type.</div>
       <div class="note">Extra attribute-specifier-sequence may be necessary for [[unsequenced]] and similar</div>
       
        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Semantics</h2>
            <ul>
                <li>The function literal is a function designator. (Behaves like a function, not a function pointer)
                </li>
            </ul>
            <pre><code code class="language-c">
void main()
{
    (void (*pf)(void)) = &(void (void)){}; /* ok */
    &(void (void)){} = 0;                  /* error: lvalue required */
}
</code></pre>
        </section>
                <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>File scope function literals</h2>
            <pre><code code class="language-c">
auto f = (int (int a)){ return a * 2; }; /* ok */
</code></pre>
        </section>
        

        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Labels</h2>
            <ul>
                <li>Labels are not shared</li>
                <li>Statements are not shared (break; continue)</li>
            </ul>
            <pre><code code class="language-c">
int main() {
    L1:;
    (void (void)) {    
        goto L1; /* error: label 'L1' used but not defined */
    }();

   void local() {     
       goto L1; /* error: label 'L1' used but not defined */
   };
}
</code></pre>

        </section>

                <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Returning VM types</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;
int main(){
    int n = 1;
    auto typeof(int [n])* local(void);
    n  = 2;
    typeof(int [n])* local(void)
    {
       printf("%d", n); //prints 3
       return 0;
    }    
    n = 3;
    local();
}
</code></pre>
            <div class="note">Following GCC implementation of nested functions</div>
        </section>

                        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Argument evaluation</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int n = 1;

    void local(typeof(int[n])* p) 
    {
         printf("%zu", sizeof(*p)); //prints 12
    }

    n = 2;
    int a[n];
    n = 3;
    local(&a);
}
</code></pre>
            <div class="note">Following GCC implementation of nested functions</div>
        </section>

                                <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Argument VM types</h2>
            <pre><code code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    
    void local(int i, typeof(int[i])* p) 
    {
         printf("%zu", sizeof(*p)); //ok
    }

    int n = 2;
    int a[n];
    local(n, &a);
}
</code></pre>
            <div class="note">Following GCC implementation of nested functions</div>
        </section>

        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2> __func__ </h2>
            <ul>
                <li>The value of the string returned by __func__ is implementation-defined.</li>
            </ul>

            <div class="note"> GCC returns the function name for nested functions</div>
            <div class="note"> C++ returns "operator ()"  in lambdas</div>
        </section>


        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Scope</h2>
            <ul>
                <li>Function literals and local functions have access to the enclosing scope at the point of its
                    definition.</li>
                </ul>

                <pre><code code class="language-c">
int main() {
    
    struct X {int i; };
    enum E {A};

    (void (void)) {    
        struct X x = {}; /* ok */
        x.i = A;         /* ok */
    }();

   void local() {     
     struct X x = {}; /* ok */
     x.i = A;         /* ok */
   };
}
</code></pre>


        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Automatic variables</h2>
            <ul>
                <li style="font-size: smaller;">
                    Identifiers referring to automatic variables of an enclosing function cannot
                    have their address resolved inside the body of a function literal or local function.
                    If they have VM types, this restriction also apply to resolving their type.
                </li>


                <pre><code code class="language-c">
int main() {    
    int i = 2;
    void local() {    
        int j = sizeof(i); /*ok*/
        int  k = i;        /* constraint violation */
        int *p = &amp;i;   /* constraint violation */
    };   
}

void start(int n) {
    int a[n];
    void local() {    
        typeof(a) k;       /* constrain violation */
        int m = sizeof(a); /* constrain violation */
    };   
}
</code></pre>                
        </section>

                <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Constants</h2>
            <pre><code code class="language-c">
int main() {
   constexpr int a = 1;
   const int b = 2;     /*N3693 Implicitly constexpr*/

   void local() {     
     int x = a;   /* ok */             
     int *p = &a; /*constrain violation*/
     
     n = b;       /* ok */             
     p = &b;      /*constrain violation*/
   };
}
</code></pre>
        </section>


        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Non-automatic variables</h2>
            <pre><code code class="language-c">
static int g = 1;

int main() {
   static int i = 1;
   
   void local() {     
     int j = sizeof(i); /* ok */
     int k = i;         /* ok */
     int m = g;         /* ok */     
   };
}
</code></pre>
                    <div class="note">For synchronous code, static variables can be an alternative to captures</div>
        </section>

<!-------------------------------------------- Slide 4 -------------------------------------------------->
        <section>
            <h2>Function literal emulation in GCC</h2>
            <pre><code code class="language-c">
int main() {
    ({int _(int a) { return a * 2; } _;})(2);
}
</code></pre>

        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Generic functions</h2>

            <pre><code code class="language-c">
#define SWAP(a, b)\
    (void (typeof(a)* arg1, typeof(b)* arg2)) { \
    typeof(a) temp = *arg1; *arg1 = *arg2; *arg2 = temp; \
    }(&(a), &(b))

int main() {
    int a = 1;
    int b = 2;

    SWAP(a, b);
    
    (void (typeof(a)* arg1, typeof(b)* arg2)) { 
        typeof(a) temp = *arg1;
        *arg1 = *arg2; 
        *arg2 = temp; 
    }(&(a), &(b));


    double da = 1.0;
    double db = 2.0;
    SWAP(da, db);
}
</code></pre>
        </section>


        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Functiol Literal address</h2>
            <ul>
            <li>Distinct function literals are not required to have unique addresses.</li>
            <li>local functions?</li>
            </ul>
            <pre><code code class="language-c">
        
int main(){
    auto pf1 = (void ()) { return 1 + 1; };
    auto pf2 = (void ()) { return 2; };
    auto pf3 = (void ()) { return 2; };
    /* pf1 and pf2 and pf3 can have the same address */
}
</code></pre>


        </section>

        <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Static variables inside function literals</h2>
            <ul>
                <li>static variables inside function literals will generate distinct functions</li>
            </ul>

            <pre><code code class="language-c">       
int main() {
    auto pf1 = (void ()) { static int i = 0; };
    auto pf2 = (void ()) { static int i = 0; };
    assert(pf1 != pf2);
}

</code></pre>


        </section>

                <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Why not C++ lambda syntax?</h2>
            <ul>
                <li>Keeps the grammar for functions and function literals in sync</li>
                <li>Keeps the scope rules for return type and parameters.</li>                
            </ul>
        </section>

        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Key points</h2>
            <ul>
                <li>Almost zero learning curve</li>
                <li>No new semantic model</li>
                <li>Existing practice</li>
                <li>Does not require trampolines or other hidden features.</li>
                <li>No forced capture strategy</li>
                <li>Works with existing APIs that use void* callbacks</li>                
            </ul>
        </section>

        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Next steps</h2>
            <ul>
                <li>Wording</li>
                <li>GCC feedback about nested functions.</li>
                <li>Experimental implementation (cake)</li>
            </ul>
        </section>

        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>Thank You</h2>
            <p>Press ← → or Space to navigate.</p>

        </section>


        <!-------------------------------------------- Slide  -------------------------------------------------->
        <section>
            <h2>References</h2>
            <ul>
                <li>N3724: Discarded, https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3724.pdf</li>
                <li>N3622  Allow calling static inline within extern inline</li>
                <li>N3579: auto as a placeholder type specifier, v2, https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3579.htm</li>
                <li>N2956: Unsequenced functions https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2956.htm</li>
                <li>N3693: Integer Constant Expression-Initialized const Integer-Typed Declarations are Implicitly constexpr https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3693.htm</li>
                <li>N3694: Functions with Data https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3694.htm</li>
                <li>N3654: Accessing the Context of Nested Functions https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3654.pdf</li>
                <li>Reddit: https://www.reddit.com/r/C_Programming/comments/1omrrra/closures_in_c_yes/</li>
                <li>http://cakecc.org/</li>
            </ul>
        </section>
        
        <div class="footer">Slide N/N</div>
    </div>



            <!-------------------------------------------- Slide -------------------------------------------------->
        <section>
            <h2>Sample async implementation</h2>            
            <pre><code code class="language-c">       
void async(void* data, void (*callback)(int result, void* data))
{
   struct capture {
    void * data;
    void (*callback)(int result, void* data);
   } = {data, callback};

   thread_pool(capture, sizeof capture, (void (int status, void* data)) {

       struct capture * ctx = data;
       /*...job...*/
       ctx->callback(status, ctx->data);
   });
}
</code></pre>


        </section>

    <script>
        const slides = document.querySelectorAll("section");
        let currentSlide = 0;

        function showSlide(index) {

            const total = slides.length;
            var footer = document.querySelector(".footer");
            if (footer) {
                footer.textContent = `Slide ${index + 1} / ${total}`;
            }

            slides.forEach((slide, i) => {
                slide.classList.remove("active");
            });

            slides[index].classList.add("active");
        }

        document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowRight" || e.key === " ") {
                currentSlide = Math.min(currentSlide + 1, slides.length - 1);
                showSlide(currentSlide);
            }

            if (e.key === "ArrowLeft") {
                currentSlide = Math.max(currentSlide - 1, 0);
                showSlide(currentSlide);
            }
        });

        // Initialize first slide
        showSlide(currentSlide);
    </script>
</body>

</html>