<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<p>V0.3 - 30/06/2023</p>

<h2 id="toc_0">Abstract</h2>

<p>In C, resources such as memory are managed manually. For example, we utilize the <code>malloc</code> function to allocate memory and store the resulting address in a variable. When the memory is no longer needed, we need the address returned by malloc to be able to call <code>free</code>.  </p>

<p>Therefore, the variable holding the address is considered the owner of the memory, as this address cannot be simply discarded, otherwise we have a memory leak.</p>

<p>Resource leaks pose a significant challenge as they tend to be silent problems that don&#39;t immediately impact a program&#39;s behavior or cause immediate issues. Moreover, they can easily go unnoticed during unit tests, creating a false sense of security. Therefore, it is absolutely crucial to address and track these problems early on. By doing so, not only can potential complications be prevented, but it can also save valuable time and resources in the long run.</p>

<p>I propose we add new type qualifiers <code>owner</code>, <code>view</code>, <code>obj_owner</code>.</p>

<p>The owner qualifier will qualify the variable as the <code>owner</code> and <code>view</code> can be used to override (negate) owner.</p>

<p>Owner variables cannot be discarded, they must be moved or destroyed.</p>

<p>The <code>obj_owner</code> is unfortunately a special case of <code>owner</code> and it will be explained later.</p>

<p>These qualifiers will not change the program behavior in any way.</p>

<h2 id="toc_1">Syntax</h2>

<p>The syntax of owner qualifier is similar of const and others. </p>

<pre><code class="language-c">typedef owner int handle; 
handle a;

void * owner p = malloc(1);

int a[owner 10];
</code></pre>

<p>structs/unions/enuns can be qualified at declaration.</p>

<pre><code class="language-c">owner struct X { ... };
</code></pre>

<p>The compiler will emit a warning in case this variable goes out of scope without being moved or destroyed.</p>

<pre><code class="language-c">int main() {
  void * owner p = malloc(1);
} //warning variable p not moved/destroyed

</code></pre>

<p><code>view</code> qualifier is the default. It can be used to override the owner qualifier used at the struct declaration.</p>

<pre><code>owner struct X { ... };
int main()
{
 struct X x1;
 view struct X x2;
 x2 = x1;
}
</code></pre>

<h2 id="toc_2">Owner pointer to owner object</h2>

<p>When we have owner pointer to a owner object, the compiler will check if both, pointer and pointed object are moved/destroyed.  </p>

<pre><code class="language-c">owner struct X { ... };
</code></pre>

<pre><code class="language-c">int main()
{
 struct X * owner p = calloc(1, sizeof(*p)); 
} //warning owner variable p not destroyed/moved
</code></pre>

<pre><code class="language-c">int main()
{
 struct X * owner p = calloc(1, sizeof(*p));
 free(p);
} //warning object pointed by p, not moved/destroyed
</code></pre>

<pre><code class="language-c">int main()
{
 struct X * owner p = calloc(1, sizeof(*p));
 x_destroy(p);
} //warning memory pointed by p not destroyed/moved
</code></pre>

<pre><code class="language-c">owner struct X { ... };
int main()
{
 struct X * owner p = calloc(1, sizeof(*p));
 x_destroy(p);
 free(p);
}//ok
</code></pre>

<h2 id="toc_3">Move assignment</h2>

<p>The move assignment is used to transfer the ownership. After this assignment the source variable became uninitialized. The uninitialized state is not something in runtime, it is just conceptual state. If we try to use p2 after move, we receive a warning &quot;using a uninitialized variable&quot;.</p>

<pre><code class="language-c">void * owner p1 = malloc(1);
void * owner p2 = nullptr;
p2 = move p1;
free(p2);
</code></pre>

<p>Assignment a non owner variable creates a &quot;view&quot;. </p>

<pre><code class="language-c">void * owner p1 = malloc(1);
void * p2 = nullptr;
p1 = p2;
free(p1);
</code></pre>

<p>We also can use move at initialization</p>

<pre><code class="language-c">void * owner p1 = malloc(1);
void * p2 = move p1;
free(p2);
</code></pre>

<p>Only types qualified with owner can be on the right side of the move assignment. </p>

<h2 id="toc_4">Moving to function arguments</h2>

<p>Passing a variable to a function is very similar of assignment. The same rules apply.</p>

<pre><code class="language-c">owner struct list {...};
owner struct node {...};

struct list list = {0};
struct node node = {0}
...
list_add(&amp;list, move node);
</code></pre>

<h2 id="toc_5">Implicit move</h2>

<p>Some moves are so obvious that we can make them optional. For instance, free, close, destroy and delete are good candidates.
For this job we can use the attribute.</p>

<pre><code class="language-c">void list_destroy([[implicit]] struct list l) { }

int main()
{
  owner struct list {...};
  list_destroy(list);
}
</code></pre>

<h2 id="toc_6">Returning owner type</h2>

<p>Returning a owner variable is the same of moving it and it is implicit.</p>

<pre><code class="language-c">struct list make()
{
  struct list {...};
  return list;
}
</code></pre>

<h2 id="toc_7">obj_owner qualifier</h2>

<p>We can create destructors like this</p>

<pre><code class="language-c">void x_destroy([[implicit]] struct list list) {
}

int main()
{
  struct list list = {};
  x_destroy(list);
}
</code></pre>

<p>But we may want to create destructor passing pointers.
The problem is that a owner pointer is owner of both memory and the object but for objects allocated on the stack we want to destroy only the object.</p>

<p>The obj_owner qualifier was created basically to allow destructors to be implemented as:</p>

<pre><code class="language-c">void x_destroy([[implicit]] struct list* obj_owner list) {
}

int main()
{
  struct list list = {};
  x_destroy(&amp;list);
}
</code></pre>

<p>Taking the address of some owner variable does not result in a owner pointer, but in a obj_owner pointer.</p>

<h2 id="toc_8">Owner arrays</h2>

<p>As expected arrays and pointer are related.</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X a[owner 100];
  array_destroy(100, a);
}
</code></pre>

<p>But the array syntax is similar of owner of the objects not the memory.</p>

<pre><code class="language-c">void array_destroy(int n, struct X a[owner n])
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_destroy(100, p);
  free(p);
}
</code></pre>

<p>or</p>

<pre><code class="language-c">void array_delete(int n, struct X * owner p)
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_delete(100, p);  
}
</code></pre>

<p>or</p>

<pre><code class="language-c">void array_delete(int n, struct X (* owner) [onwer n])
{
}

int main()
{
  struct X * owner p = calloc(100, sizeof(struct X));
  array_delete(100, p);  
}
</code></pre>

<h2 id="toc_9">Reality check I</h2>

<p>Let&#39;s check if these rules can help us with <code>fopen/fclose</code>.</p>

<pre><code class="language-c">FILE* owner fopen(char const* name,char const* mode);
int fclose([[implicit]] FILE* owner f);
</code></pre>

<pre><code class="language-c">int main() {
  FILE * owner p = fopen(&quot;text.txt&quot;, &quot;r&quot;);
  if (p) {
    fclose(p);
  }
}
</code></pre>

<p>We have a problem, because the not all control paths are calling the destructor and the compiler will emit an warning.</p>

<p>However, the code is correct because we don&#39;t need, and we cannot, call fclose on null pointer.</p>

<p>To solve this problem we also need null-checks in your static analyzer.  </p>

<p><strong>Rule</strong>:  if we can prove that a pointer with destructor is null or uninitialized at the end of scope we don&#39;t need to destroy the object.</p>

<h2 id="toc_10">Reality check II</h2>

<pre><code class="language-c">onwer struct book {
    char * owner title;
};

void book_destroy(struct book * obj_owner book) { 
  free(book-&gt;title);
}

void book_delete(struct book* owner book) {
    if (book) {
       book_destroy(book);
       free(book);
    }
}

struct books {
    struct book * owner * owner data;
    int size;
    int capacity;
};

void books_destroy(struct books * obj_owner books) {
   for (int i = 0; i &lt; books-&gt;size; i++) {
     book_delete(books-&gt;data[i]);
   }
   free(books-&gt;data);
}

int main() 
{
   struct books books = {};
   struct book* owner book = calloc(1, sizeof (struct book));
   if (book == NULL) goto continuation;
   
   book-&gt;title = strdup(&quot;book1&quot;);
   if (book-&gt;title == NULL) goto continuation;
   
   if (books_push_back(&amp;books, move book) == 0) {
     book = NULL;
   }
 continuation:
  book_delete(book);
  books_destroy(&amp;books);
}
</code></pre>

<h2 id="toc_11">Checking the rules III</h2>

<pre><code class="language-c">int main()
{
  FILE * owner f = NULL;
  if (fopen_s( &amp;f,&quot;f.txt&quot;, &quot;r&quot;) == 0)  {
    fclose(f);
  }
}
</code></pre>

<p>The problem here is that in previous fopen we could check for null to decide if we need or not a warning if the destructor is not called.</p>

<p>One way we could fix this is adding assert(f == NULL) for the else path.</p>

<pre><code class="language-c">int main()
{
  FILE * auto f = NULL;
  if (fopen_s( &amp;f,&quot;f.txt&quot;, &quot;r&quot;) == 0)  {
    fclose(f);
  }
  else
    assert(f == NULL);
}
</code></pre>
</body></html>