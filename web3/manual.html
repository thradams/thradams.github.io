<!DOCTYPE html>
<html>
<head>
  
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
     <link rel="stylesheet" href="style.css" />
</head>
<body>
<p><a href="index.html">Home</a> | <a href="manual.html">Manual</a> | <a href="playground.html">Playground</a></p>
<h1>Cake</h1>
<ul>
<li>
<a href="#toc_0">Command line</a>
</li>
<li>
<a href="#toc_1">C99 Transformations</a>
</li>
<li>
<a href="#toc_2">C11 Transformations</a>
</li>
<li>
<a href="#toc_3">C23 Transformations</a>
</li>
<li>
<a href="#toc_4">Extensions (Not in C23)</a>
</li>
</ul>
<h2 id="toc_0">Command line</h2>

<pre><code>cake [options] source1.c source2.c ...

Options
  -I                Adds a directory to the list of directories searched for include files.
                    (On windows, if you run cake at the visual studio command prompt cake 
                     uses the same include files used by msvc.)

  -D                Defines a preprocessing symbol for a source file.

  -E                Copies preprocessor output to standard output.

  -r                Remove all comments from the ouput file.

  -rm               Outputs preprocessed code after compilation.

  -target=standard  Output target C standard (c89, c99, c11, c2x, cxx).
                    C99 is the default and C89 (ANSI C) is the minimum target.

  -std=standard     Assume that the input sources are for standard (c89, c99, c11, c2x, cxx).
                    (not implented yet, input is considered C23)                    

  -n                Check naming conventions (it is hardcoded for its own naming convention)

  -fi               Format input (format before language convertion)

  -fo               Format output (format after language convertion, result parsed again)
</code></pre>

<p>The ouput dir is <strong>./out</strong></p>

<h2 id="toc_1">C99 Transformations</h2>

<h3>restrict pointers</h3>

<p>Yes. restrict is commented.</p>

<h3>Variable-length array (VLA)</h3>

<p>TODO</p>

<h3>Flexible array members</h3>

<p>TODO</p>

<h3>static and type qualifiers in parameter array declarators</h3>

<p>TODO</p>

<h3>The long long int type and library functions</h3>

<p>TODO ?</p>

<h3>Universal character names (\u and \U)</h3>

<p>TODO</p>

<h3>Hexadecimal floating constants</h3>

<p>TODO</p>

<h3>Compound literals</h3>

<p>TODO</p>

<pre><code class="language-c">//EXAMPLE 8 Each compound literal creates only a single object in a given scope:
struct s {
  int i;
};
int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    q = p, p = &amp; ((struct s) { j++ });
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">//EXAMPLE 8 Each compound literal creates only a single object in a given scope:
struct s {
  int i;
};
int f(void) {
  struct s * p = 0, * q;
  int j = 0;
  again:
    struct s compound_literal_1 = { j++ };
    q = p, p = &amp; compound_literal_1;
  if (j &lt; 2) goto again;
  return p == q &amp;&amp; q -&gt; i == 1;
}
</code></pre>

<h3>designated initializers</h3>

<p>TODO</p>

<h3>//Comments</h3>

<p>Yes. Converted to <code>/*comments*/</code></p>

<h3>mixed declarations and code</h3>

<p>TODO</p>

<h3>inline functions</h3>

<h3>_Pragma preprocessing operator</h3>

<p>TODO </p>

<h3><code>__func__</code> predefined identifier</h3>

<p>TODO</p>

<h3>init-statement in for loops</h3>

<p>TODO</p>

<pre><code class="language-c">int main()
{
    for (int i = 0; i &lt; 10; i++)
    {
    }
}
</code></pre>

<p>becomes</p>

<pre><code class="language-c">int main()
{
    {
       int i = 0;
       for (;i &lt; 10; i++)
       {
       }
    }
}
</code></pre>

<h3>Variadic macros</h3>

<p>TODO</p>

<h3>Trailing comma in enumerator-list</h3>

<h3>_Bool</h3>

<p>Yes, convert to int.</p>

<h2 id="toc_2">C11 Transformations</h2>

<h3>C11 static assertions</h3>

<p>When compiling to versions &lt; C11 static_assert is removed</p>

<h3>C11 Anonymous structures and unions</h3>

<p>TODO</p>

<h3>no-return functions</h3>

<p>Parsed just need to comment. TODO</p>

<h3>C11 Thread_local/Atomic</h3>

<p>Parsed but not transformed.</p>

<h3>C11 type-generic expressions</h3>

<p>When compiling to versions &lt; C11 we keep the expression that matches the type.</p>

<p>For instance:</p>

<p>The expression that matches the argument 1.0 is <strong>cbrtl</strong>.</p>

<p>The result of _Generic in C99 will be cbrtl. Because this is inside
a macro we need to tell the transpiler to expand that macro using 
pragma expand.</p>

<pre><code class="language-c">#include &lt;math.h&gt;

#define cbrt(X) _Generic((X), \
                  double: cbrtl, \
                  float: cbrtf ,\
                  default: cbrtl  \
              )(X)

#pragma expand cbrt


int main(void)
{
    cbrt(1.0);
}

</code></pre>

<p>Then the resulting C99 code is:</p>

<pre><code class="language-c">
#include &lt;math.h&gt;

#define cbrt(X) _Generic((X), \
                  double: cbrtl, \
                  float: cbrtf ,\
                  default: cbrtl  \
              )(X)

#pragma expand cbrt


int main(void)
{
     cbrtl(1.0);
}

</code></pre>

<h3>C11 u8&quot;literals&quot;</h3>

<p>u8 literals are converted to escape sequecences. (I don&#39;t recomend u8&quot;&quot;)</p>

<h3>C11 Noreturn</h3>

<p>Parsed. Todo needs to be replaced by <strong>[[_Noreturn]]</strong> in C23</p>

<h2 id="toc_3">C23 Transformations</h2>

<h3>C23 Decimal32, Decimal64, and Decimal128</h3>

<p>Not implemented (maybe parsed?)</p>

<h3>static<em>assert / single-argument Static</em>assert</h3>

<p>In C23 <strong>static_assert</strong> can be used as keyword and the message is optional.
Compiling to C11 we add some dumy message is necessary and we use the previous keyword <strong><em>Static</em>assert</strong></p>

<h3>C23 u8 char literal</h3>

<p>not implemented yet.</p>

<h3>C23 Digit separators</h3>

<p>When compiling to versions &lt; 23 the compiler removes the &#39; delimiter from tokens. </p>

<h3>C23 Binary literals</h3>

<p>When compiling to versions &lt; 23 the compiler translater the binary literal to a hexadecimal constant.</p>

<h3>C23 nullptr</h3>

<p>When compiling to version &lt; 23 nullptr is replaced with <strong>((void*)0)</strong>
Semantics of nullptr is not implemented yet.</p>

<h3>C23 bool true false</h3>

<p>When compiling to version &lt; 23 bool is replaced with <strong>_Bool</strong>, true is replaced with <code>((_Bool)1)</code> and false
with <strong>(_Bool)0)</strong></p>

<h3>C23 {} empty initializer</h3>

<p>Cake transform {} into {0}. </p>

<h3>C23 auto</h3>

<p>not implemented yet</p>

<h3>C23 typeof / typeof_unqual</h3>

<p>When compiling to versions &lt; 23 we replace typeof by the equivalent type. 
This can be a little complex in some cases.</p>

<h3>C23 constexpr</h3>

<p>Not implemented yet (maybe parsed?)</p>

<h3>C23 enuns with type</h3>

<p>Parsed. Translation to C99 not implemented.</p>

<pre><code class="language-c">enum X : short {
  A
};

int main() {
   enum X x = A;   
}
</code></pre>

<h3>C23 Attributes</h3>

<p>Attributes are being parsed and removed in some places. More work is necessary.</p>

<h3>C23 has_attribute</h3>

<p>Yes but need work/review.</p>

<h3>C23 has_include</h3>

<p>Yes. But this does not make sense unless for direct compilation -mr.
Transpiling to 1 or 0 would represent the machine where the code
was transpiled but not where generated code will be compiled.</p>

<h3>C23 warning</h3>

<p>When compiling to versions &lt; 23 it is commented</p>

<h3>C23 embed</h3>

<p>When compiling to versions &lt; 23 the line is replaces by the numbers.</p>

<p>One alternative for C99 is to generate an auxiliary file then
use normal <code>#include</code> instead of <code>#embed</code>.</p>

<p>This cannot be showed at web playground becase we dont have an option to 
create files there.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #embed &quot;stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);

}

</code></pre>

<p>becomes in C99</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
  static const char file_txt[] = {
   #include &quot;embed_stdio.h&quot;
   ,0
  };

  printf(&quot;%s\n&quot;, file_txt);

}

</code></pre>

<h3>C23 VAOPT</h3>

<p>Yes but need work.</p>

<h3>C23 BitInt(N))</h3>

<p>Not implemented</p>

<h3>C23 constexpr</h3>

<p>Parsed but not implemented</p>

<pre><code class="language-c">constexpr int K = 47;
enum {
 A = K, // valid, constant initialization
};
constexpr int L = K; // valid, constexpr initialization
static int b = K + 1; // valid, static initialization
int array[K]; // not a VL
</code></pre>

<h3>C23 auto</h3>

<p>Parsed but not implemented</p>

<pre><code class="language-c">static auto a = 3.5;
auto p = &amp;a;
</code></pre>

<h3>C23 elifdef elifndef</h3>

<p>Are implemented</p>

<h2 id="toc_4">Extensions (Not in C23)</h2>

<h3>try catch throw</h3>

<p>try catch is a external block that we can jump off.</p>

<p>try catcn is a LOCAL jump only and this is on purpose not a limitation.</p>

<pre><code>   try-statement:
      try secondary-block
      try secondary-block catch secondary-block   
</code></pre>

<p>catch block is optional.</p>

<pre><code class="language-c">try
{
   for (int i = 0 ; i &lt; 10; i++) {
      for (int j = 0 ; j &lt; 10; j++) {
        ... 
        if (error) throw;
        ...
      }
   }
}
catch
{
}
</code></pre>

<h3>defer</h3>

<p><em>defer</em> will call the defer statement before the block exit at inverse orden of declaration.</p>

<pre><code>     defer-statement:
        defer secondary-block
</code></pre>

<p>For instance:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  do {
     FILE* f = fopen(&quot;in.txt&quot;, &quot;r&quot;);
     if (f == NULL) break;
     defer fclose(f);

     FILE* f2 = fopen(&quot;out.txt&quot;, &quot;w&quot;);
     if (f2 == NULL) break;
     defer fclose(f2);
     //...    
  }
  while(0);
}
</code></pre>

<p>Becomes:</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
  do {
     FILE* f = fopen(&quot;in.txt&quot;, &quot;r&quot;);
     if (f == ((void*)0)) break;

     FILE* f2 = fopen(&quot;out.txt&quot;, &quot;w&quot;);
     if (f2 == ((void*)0)) {  fclose(f); break;}
     
     fclose(f2); fclose(f);
   }
  while(0);
}
</code></pre>

<p>I guess everthing is working including <strong>goto</strong> jumps.</p>

<h3>if with initializer</h3>

<p>No idea why C++ 17 if with initializer was not proposed for C23!
But in cake it is implemented.</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
   int size = 10;
   if (FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;); f)
   {
     /*...*/
     fclose(f);
   }
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
   int size = 10;
   {FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;);if ( f)
   {
     /*...*/
     fclose(f);
   }}
}
</code></pre>

<p>An extension if + initializer + defer expression was considered but not implemented yet.</p>

<h3>lambdas</h3>

<p>Lambdas without capture where implemented using a syntax similar of 
compound literal for function pointer.</p>

<p>Lambdas are the most complex code transformation so far because sometimes function scope 
types needs to be transformed to file scope. This is important because manual lambda capture
is something we want to use in function scope.</p>

<p>For instance:</p>

<pre><code class="language-c">extern char* strdup(const char* s);
void create_app(const char* appname)
{
  struct capture {
     char * name;
  } capture = { .name = strdup(appname) };

  (void (void* p)) {
    struct capture* capture = p;    
  }(&amp;capture); 
}
</code></pre>

<p>Because struct capture was in function scope and the lambda function will be created
at file scope the type <strong>struct capture</strong> had to be moved from function scope to file scope.</p>

<pre><code class="language-c">extern char* strdup(const char* s);

struct _capture0 {
     char * name;
  };
  
void _lit_func_0(void *p) {
    struct _capture0* capture = p;    
  }

void create_app(const char* appname)
{
  struct _capture0  capture = { .name = strdup(appname) };
  _lit_func_0(&amp;capture);  
}
</code></pre>

<h3>typeid</h3>

<p>syntax:</p>

<pre><code class="language-c">  typeid (expression)
  typeid (type-name)
</code></pre>

<p>typeid returns a <strong>type object</strong> that can be used with == and !=.
If any left or right side of the ==/!= contains a <strong>type object</strong> then
the evaluation is based on type comparison not value.</p>

<p>Sample:</p>

<pre><code class="language-c">static_assert(1 == typeid(int));
static_assert(typeid(1) == typeid(int));
</code></pre>

<h3>Repeat</h3>

<pre><code class="language-c">  repeat {
       if (condition) 
         break;
  }
</code></pre>

<p>Repeat is equivalent of for(;;) </p>

<h3>pragma expand</h3>

<p>pragma expand tells the back end to not hide macro expansions.</p>

<p>Sample: </p>

<pre><code class="language-c">
#define SWAP(a, b) \
    do { \
      typeof(a) temp = a; a = b; b = temp; \
    } while(0)

#pragma expand SWAP

int main()
{
   int a = 1;
   typeof(a) b = 2;
   SWAP(a, b);
   return 1;
}
</code></pre>

<p>Becomes</p>

<pre><code class="language-c">#define SWAP(a, b) \
    do { \
      typeof(a) temp = a; a = b; b = temp; \
    } while(0)

#pragma expand SWAP

int main()
{
   int a = 1;
   int b = 2;
    do {int temp = a; a = b; b = temp; } while(0);
   return 1;
}

</code></pre>

<h3>_Hashof</h3>

<p>_Hashof is a compile time function that returns a hash of the parsing tokens
of some struct enum etc.</p>

<pre><code class="language-c">
struct X {
    int a[10];
  
    /*uncomment the next line*/
    //char * text;
};

void x_destroy(struct X* p);

int main()
{
    struct X x = {};
    x_destroy(&amp;x);
}

void x_destroy(struct X* p)
{
    /*In a far away galaxy*/
    static_assert(_Hashof(p) == 283780300, &quot;check this function x_destroy&quot;);
}

</code></pre>
</body></html>