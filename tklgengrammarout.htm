
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<p>{{{cpp// Generated by tkgen and llgen - Version 2012-03-02// llgen was developed by Thiago Adams// www.thradams.com//// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)// <a href="http://www.thradams.com/">http://www.thradams.com/</a>// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.//</p>
<h1>pragma once</h1>

<h1>include <string></h1>
<h1>include "tokenizer.h"</h1>
<h1>include "Sample1DFA.h"</h1>


<p>namespace Sample1{    template &lt;class TokenizerStreamT&gt;    class Context    {        typedef Tokenizer&lt;Sample1::DFA, TokenizerStreamT&gt; Scanner;        Scanner m</p>

<p>        Sample1::Tokens m        std::wstring m</p>

<p>    public:        Context(TokenizerStreamT&amp; s) : m        {            if (            {            }        }</p>

<p>        Sample1::Tokens Token() const        {             return m        }</p>

<p>        void Match(Sample1::Tokens tk)        {             if (tk              {                 throw std::runtime             }             if (             {             }        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>        void Action        {        }</p>

<p>    };</p>




<p>  void Parse</p>

<p>} //namespace </p>

<p>}}}{{{cpp// Generated by tkgen and llgen - Version 2012-03-02// llgen was developed by Thiago Adams// www.thradams.com//// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)// <a href="http://www.thradams.com/">http://www.thradams.com/</a>// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.//</p>
<h1>pragma once</h1>

<h1>include <string></h1>
<h1>include "tokenizer.h"</h1>
<h1>include "Sample1DFA.h"</h1>


<p>namespace Sample1{    //forward declarations     void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse</p>


<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkLiteralChar)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkIdentifier)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkSemicolonCharacter)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkVerticalLineCharacter)        {            //ZeroOrMoreOrF =&gt; OrF ZeroOrMoreOrF             Parse            Parse        }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkRightParenthesisCharacter)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else if (ctx.Token() == tkStringLiteral)        {            //ZeroOrMoreOrF =&gt; Epsilon         }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkVerticalLineCharacter)        {            //OrF =&gt; VerticalLineCharacter F             ctx.Match(tkVerticalLineCharacter);            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordModule)        {            //ModuleBody =&gt; KeywordModule Identifier LeftCurlyBracketCharacter LanguageBody RightCurlyBracketCharacter             ctx.Match(tkKeywordModule);            ctx.Match(tkIdentifier);            ctx.Match(tkLeftCurlyBracketCharacter);            Parse            ctx.Match(tkRightCurlyBracketCharacter);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordLanguage)        {            //LanguageBody =&gt; KeywordLanguage Identifier LeftCurlyBracketCharacter Declarations RightCurlyBracketCharacter             ctx.Match(tkKeywordLanguage);            ctx.Match(tkIdentifier);            ctx.Match(tkLeftCurlyBracketCharacter);            Parse            ctx.Match(tkRightCurlyBracketCharacter);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordInterleave)        {            //Declaration =&gt; InterleaveDeclaration             Parse        }        else if (ctx.Token() == tkKeywordToken)        {            //Declaration =&gt; TokenDeclaration             Parse        }        else if (ctx.Token() == tkKeywordSyntax)        {            //Declaration =&gt; SyntaxDeclaration             Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordInterleave)        {            //Declarations =&gt; Declaration Declarations             Parse            Parse        }        else if (ctx.Token() == tkKeywordToken)        {            //Declarations =&gt; Declaration Declarations             Parse            Parse        }        else if (ctx.Token() == tkKeywordSyntax)        {            //Declarations =&gt; Declaration Declarations             Parse            Parse        }        else if (ctx.Token() == tkRightCurlyBracketCharacter)        {            //Declarations =&gt; Epsilon         }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordInterleave)        {            //InterleaveDeclaration =&gt; KeywordInterleave Identifier EqualsCharacter TokenExpression SemicolonCharacter             ctx.Match(tkKeywordInterleave);            ctx.Match(tkIdentifier);            ctx.Match(tkEqualsCharacter);            Parse            ctx.Match(tkSemicolonCharacter);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //TokenExpression =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //TokenExpression =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //TokenExpression =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //TokenExpression =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //TokenExpression =&gt; T ZeroOrMoreT             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordToken)        {            //TokenDeclaration =&gt; KeywordToken Identifier EqualsCharacter TokenExpression SemicolonCharacter             ctx.Match(tkKeywordToken);            ctx.Match(tkIdentifier);            ctx.Match(tkEqualsCharacter);            Parse            ctx.Match(tkSemicolonCharacter);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //T =&gt; F ZeroOrMoreOrF             Parse            Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //T =&gt; F ZeroOrMoreOrF             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //T =&gt; F ZeroOrMoreOrF             Parse            Parse        }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //T =&gt; F ZeroOrMoreOrF             Parse            Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //T =&gt; F ZeroOrMoreOrF             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //ZeroOrMoreT =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //ZeroOrMoreT =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //ZeroOrMoreT =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkSemicolonCharacter)        {            //ZeroOrMoreT =&gt; Epsilon         }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //ZeroOrMoreT =&gt; T ZeroOrMoreT             Parse            Parse        }        else if (ctx.Token() == tkRightParenthesisCharacter)        {            //ZeroOrMoreT =&gt; Epsilon         }        else if (ctx.Token() == tkStringLiteral)        {            //ZeroOrMoreT =&gt; T ZeroOrMoreT             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordEmpty)        {            //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle             Parse            Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle             Parse            Parse        }        else if (ctx.Token() == tkLeftCurlyBracketCharacter)        {            //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle             Parse            Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordSyntax)        {            //SyntaxDeclaration =&gt; KeywordSyntax Identifier EqualsCharacter SyntaxExpression SemicolonCharacter             ctx.Match(tkKeywordSyntax);            ctx.Match(tkIdentifier);            ctx.Match(tkEqualsCharacter);            Parse            ctx.Match(tkSemicolonCharacter);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //F =&gt; P OptOperator             Parse            Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //F =&gt; P OptOperator             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //F =&gt; P OptOperator             Parse            Parse        }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //F =&gt; P OptOperator             Parse            Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //F =&gt; P OptOperator             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordModule)        {            //Main =&gt; ModuleBody             Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //P =&gt; V             Parse        }        else if (ctx.Token() == tkLiteralChar)        {            //P =&gt; V             Parse        }        else if (ctx.Token() == tkIdentifier)        {            //P =&gt; V             Parse        }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //P =&gt; LeftParenthesisCharacter TokenExpression RightParenthesisCharacter             ctx.Match(tkLeftParenthesisCharacter);            Parse            ctx.Match(tkRightParenthesisCharacter);        }        else if (ctx.Token() == tkStringLiteral)        {            //P =&gt; V             Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkPlusCharacter)        {            //OptOperator =&gt; PlusCharacter             ctx.Match(tkPlusCharacter);        }        else if (ctx.Token() == tkLiteralChar)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkIdentifier)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkSemicolonCharacter)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkQuestionMarkCharacter)        {            //OptOperator =&gt; QuestionMarkCharacter             ctx.Match(tkQuestionMarkCharacter);        }        else if (ctx.Token() == tkAsteriskCharacter)        {            //OptOperator =&gt; AsteriskCharacter             ctx.Match(tkAsteriskCharacter);        }        else if (ctx.Token() == tkVerticalLineCharacter)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkRightParenthesisCharacter)        {            //OptOperator =&gt; Epsilon         }        else if (ctx.Token() == tkStringLiteral)        {            //OptOperator =&gt; Epsilon         }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //V =&gt; KeywordAny             ctx.Match(tkKeywordAny);        }        else if (ctx.Token() == tkLiteralChar)        {            //V =&gt; LiteralChar RangeOpt             ctx.Match(tkLiteralChar);            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //V =&gt; Identifier             ctx.Match(tkIdentifier);        }        else if (ctx.Token() == tkStringLiteral)        {            //V =&gt; StringLiteral             ctx.Match(tkStringLiteral);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordAny)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkRangeSeparator)        {            //RangeOpt =&gt; RangeSeparator LiteralChar             ctx.Match(tkRangeSeparator);            ctx.Match(tkLiteralChar);        }        else if (ctx.Token() == tkPlusCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkLiteralChar)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkIdentifier)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkSemicolonCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkQuestionMarkCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkAsteriskCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkVerticalLineCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkLeftParenthesisCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkRightParenthesisCharacter)        {            //RangeOpt =&gt; Epsilon         }        else if (ctx.Token() == tkStringLiteral)        {            //RangeOpt =&gt; Epsilon         }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkKeywordEmpty)        {            //SyntaxExpressionSingle =&gt; KeywordEmpty             ctx.Match(tkKeywordEmpty);        }        else if (ctx.Token() == tkLiteralChar)        {            //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkLeftCurlyBracketCharacter)        {            //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkSemicolonCharacter)        {            //SyntaxExpressionMoreSingle =&gt; Epsilon         }        else if (ctx.Token() == tkVerticalLineCharacter)        {            //SyntaxExpressionMoreSingle =&gt; VerticalLineCharacter SyntaxExpressionSingle SyntaxExpressionMoreSingle             ctx.Match(tkVerticalLineCharacter);            Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkLiteralChar)        {            //SyntaxExpressionItem =&gt; LiteralChar             ctx.Match(tkLiteralChar);        }        else if (ctx.Token() == tkIdentifier)        {            //SyntaxExpressionItem =&gt; Identifier             ctx.Match(tkIdentifier);        }        else if (ctx.Token() == tkLeftCurlyBracketCharacter)        {            //SyntaxExpressionItem =&gt; SyntaxExpressionAction             Parse        }        else if (ctx.Token() == tkStringLiteral)        {            //SyntaxExpressionItem =&gt; StringLiteral             ctx.Match(tkStringLiteral);        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkLiteralChar)        {            //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkIdentifier)        {            //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkLeftCurlyBracketCharacter)        {            //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else if (ctx.Token() == tkSemicolonCharacter)        {            //SyntaxExpressionSingleFollow =&gt; Epsilon         }        else if (ctx.Token() == tkVerticalLineCharacter)        {            //SyntaxExpressionSingleFollow =&gt; Epsilon         }        else if (ctx.Token() == tkStringLiteral)        {            //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow             Parse            Parse        }        else        {            assert(false);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == tkLeftCurlyBracketCharacter)        {            //SyntaxExpressionAction =&gt; LeftCurlyBracketCharacter Identifier RightCurlyBracketCharacter             ctx.Match(tkLeftCurlyBracketCharacter);            ctx.Match(tkIdentifier);            ctx.Match(tkRightCurlyBracketCharacter);        }        else        {            assert(false);        }    }} //namespace Sample1</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  