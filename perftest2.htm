
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<p>{{{cpp</p>
<h1>include "stdafx.h"</h1>

<h1>include <stdlib.h></h1>
<h1>include <string.h></h1>
<h1>include <time.h></h1>
<h1>include <string.h></h1>


<h1>include <vector></h1>
<h1>include <functional></h1>
<h1>include <string></h1>

<p>typedef void(typedef void(</p>

<p>typedef struct clsr{    clsr    void    clsr    void } clsr</p>

<h1>define CLSR_VOID_INIT(f) { f , 0 }</h1>

<p>inline void clsr{    if (p-&gt;destroy)        p-&gt;destroy(p);}</p>

<p>inline void clsr{    if (p)    {        clsr        free(p);    }}</p>

<p>inline void clsr    clsr    clsr{    closure-&gt;call = call;    closure-&gt;destroy = destroy;    //closure-&gt;data}</p>

<p>inline void clsr{    p-&gt;call(p);}</p>


<p>typedef clsrtypedef struct clsr{    size    size    clsr} clsr</p>

<h1>define CLSR_VOID_STACK_INIT { 0, 0, 0 }</h1>

<p>inline clsr{    return &amp;p-&gt;data}</p>

<p>inline void clsr{    clsr    p-&gt;size -= 1;}</p>

<p>inline void clsr{    for (size    {        clsr    }    free(p-&gt;data);    p-&gt;size = 0;    p-&gt;data = 0;    p-&gt;capacity = 0;}</p>

<p>size{    if (nelements &gt; p-&gt;capacity)    {        size</p>

<p>        if (p-&gt;data == NULL)        {            p-&gt;data = (clsr        }        else        {            p-&gt;data = (clsr        }        p-&gt;capacity = nelements;    }</p>

<p>    return (p-&gt;data }</p>

<p>static size{    const size    const size    if (nelements &gt; p-&gt;capacity)    {        size        while (newCap &lt; nelements)        {            newCap </p>

<p>            if (newCap &lt; nelements ||                newCap &gt; MAX            {                /                newCap = MAX            }        }        return clsr    }    return p-&gt;capacity;}</p>

<p>inline clsr{    size</p>

<p>    if (result == 0)    {        return 0;    }</p>

<p>    return &amp;p-&gt;data}</p>

<p>inline int clsr    clsr{    clsr    clsr    p-&gt;size += 1;    return 1;}</p>

<p>static void freetext(void{    clsr    free((void}</p>

<p>typedef void(</p>

<p>static void textf(void{    clsr    callstr  pf = (callstr)p-&gt;finalCall;    char     pf(ps);}</p>

<p>clsr                                 const char{    clsr    clsr    pNew.finalCall = (void    char     strcpy(p2, text);    pNew.data    return pNew;}</p>

<p>int clsr    void(    const char{    clsr</p>


<p>    clsr    pNew-&gt;finalCall = (void    char     strcpy(p2, text);    pNew-&gt;data</p>


<p>    p-&gt;size += 1;    return 1;}</p>

<p>inline int clsr    clsr{    clsr    </p>

<p>    p-&gt;size += 1;    return 1;}</p>

<p>inline void clsr{    clsr    clsr}</p>

<p>void clsr{    for (size    {        clsr    }    p-&gt;size = 0;}</p>

<h1>define MAX_COUNT 10000000</h1>

<p>static int counter = 0;</p>

<p>static void f(void{    counter++;}</p>

<p>static void f2(char{    counter +=  strlen(text);}</p>

<p>void Test1(){</p>


<p>    for (int i = 0; i &lt; MAX    {        clsr</p>

<p>        clsr        clsr</p>

<p>        while (stack.size)        {            clsr        }</p>

<p>        clsr    }</p>

<p>}</p>

<h1>define HAS_MOVE_CAPTURE</h1>

<p>void Test2(){</p>


<p>    for (int i = 0; i &lt; MAX    {        std::vector&lt;std::function&lt;void(void)&gt;&gt; st;        st.reserve(4);</p>


<p>        st.emplace        {            counter++;        });</p>

<p>        std::string s2 = &quot;thiago&quot;;</p>
<h1>ifdef HAS_MOVE_CAPTURE</h1>
<p>        st.emplace</p>
<h1>else</h1>
<p>        st.emplace</p>
<h1>endif		</h1>
<p>        {            counter += s2.size();        });</p>

<p>        while (st.size())        {            st.back()();            st.pop        }    }}</p>

<p>void RunTest(const char{    counter = 0;    time    test();    printf(&quot;%s %d %d\n&quot;, message, int(clock() - start), counter);}</p>

<p>int main(int argc, char{    RunTest(&quot;C++&quot;, &amp;Test2);    RunTest(&quot;C  &quot;, &amp;Test1);    return 0;}}}}</p>

<p>{{{C++ 1901 70000000C   1810 70000000}}}</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  