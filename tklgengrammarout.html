<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<a class = "linkbox" href = "codeblog.html">CODE-BLOG</a>
<a class = "linkbox" href = "about.html">ABOUT </a>
<p>{{{cpp
// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Copyright (C) 2009, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com/">http://www.thradams.com/</a>
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//</p>

<h1 id="toc_0">pragma once</h1>

<h1 id="toc_1">include <string></h1>

<h1 id="toc_2">include &quot;tokenizer.h&quot;</h1>

<h1 id="toc_3">include &quot;Sample1DFA.h&quot;</h1>

<p>namespace Sample1
{
    template <class TokenizerStreamT>
    class Context
    {
        typedef Tokenizer<Sample1::DFA, TokenizerStreamT> Scanner;
        Scanner m_scanner;</p>

<pre><code>    Sample1::Tokens m_CurrentToken;
    std::wstring m_lexeme;

public:
    Context(TokenizerStreamT&amp; s) : m_scanner(s)
    {
        if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
        {
        }
    }

    Sample1::Tokens Token() const
    {
         return m_CurrentToken;
    }

    void Match(Sample1::Tokens tk)
    {
         if (tk != m_CurrentToken)
         {
             throw std::runtime_error(&quot;token not expected&quot;);
         }
         if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
         {
         }
    }

    void Action_ModuleName()
    {
    }

    void Action_LanguageName()
    {
    }

    void Action_teste()
    {
    }

    void Action_TokenName()
    {
    }

    void Action_TokenEnd()
    {
    }

    void Action_SyntaxName()
    {
    }

    void Action_PrintAnd()
    {
    }

    void Action_PrintOr()
    {
    }

    void Action_PrintOptional()
    {
    }

    void Action_PrintZeroOrMore()
    {
    }

    void Action_PrintOneOrMore()
    {
    }

    void Action_PrintChar()
    {
    }

    void Action_PrintName()
    {
    }

    void Action_PrintAny()
    {
    }

    void Action_PrintString()
    {
    }

    void Action_PrintRange()
    {
    }

    void Action_CloseProduction()
    {
    }

    void Action_PrintEmptyProduction()
    {
    }

    void Action_PrintAction()
    {
    }

};
</code></pre>

<p>void Parse_Main(Context&amp;);</p>

<p>} //namespace </p>

<p>}}}
{{{cpp
// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Copyright (C) 2009, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com/">http://www.thradams.com/</a>
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//</p>

<h1 id="toc_4">pragma once</h1>

<h1 id="toc_5">include <string></h1>

<h1 id="toc_6">include &quot;tokenizer.h&quot;</h1>

<h1 id="toc_7">include &quot;Sample1DFA.h&quot;</h1>

<p>namespace Sample1
{
    //forward declarations 
    void Parse<em>ZeroOrMoreOrF(Context&amp;);
    void Parse</em>OrF(Context&amp;);
    void Parse<em>ModuleBody(Context&amp;);
    void Parse</em>LanguageBody(Context&amp;);
    void Parse<em>Declaration(Context&amp;);
    void Parse</em>Declarations(Context&amp;);
    void Parse<em>InterleaveDeclaration(Context&amp;);
    void Parse</em>TokenExpression(Context&amp;);
    void Parse<em>TokenDeclaration(Context&amp;);
    void Parse</em>T(Context&amp;);
    void Parse<em>ZeroOrMoreT(Context&amp;);
    void Parse</em>SyntaxExpression(Context&amp;);
    void Parse<em>SyntaxDeclaration(Context&amp;);
    void Parse</em>F(Context&amp;);
    void Parse<em>Main(Context&amp;);
    void Parse</em>P(Context&amp;);
    void Parse<em>OptOperator(Context&amp;);
    void Parse</em>V(Context&amp;);
    void Parse<em>RangeOpt(Context&amp;);
    void Parse</em>SyntaxExpressionSingle(Context&amp;);
    void Parse<em>SyntaxExpressionMoreSingle(Context&amp;);
    void Parse</em>SyntaxExpressionItem(Context&amp;);
    void Parse<em>SyntaxExpressionSingleFollow(Context&amp;);
    void Parse</em>SyntaxExpressionAction(Context&amp;);</p>

<pre><code>void Parse_ZeroOrMoreOrF(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkSemicolonCharacter)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkVerticalLineCharacter)
    {
        //ZeroOrMoreOrF =&gt; OrF ZeroOrMoreOrF 
        Parse_OrF(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkRightParenthesisCharacter)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //ZeroOrMoreOrF =&gt; Epsilon 
    }
    else
    {
        assert(false);
    }
}

void Parse_OrF(Context&amp; ctx)
{
    if (ctx.Token() == tkVerticalLineCharacter)
    {
        //OrF =&gt; VerticalLineCharacter F 
        ctx.Match(tkVerticalLineCharacter);
        Parse_F(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_ModuleBody(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordModule)
    {
        //ModuleBody =&gt; KeywordModule Identifier LeftCurlyBracketCharacter LanguageBody RightCurlyBracketCharacter 
        ctx.Match(tkKeywordModule);
        ctx.Match(tkIdentifier);
        ctx.Match(tkLeftCurlyBracketCharacter);
        Parse_LanguageBody(ctx);
        ctx.Match(tkRightCurlyBracketCharacter);
    }
    else
    {
        assert(false);
    }
}

void Parse_LanguageBody(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordLanguage)
    {
        //LanguageBody =&gt; KeywordLanguage Identifier LeftCurlyBracketCharacter Declarations RightCurlyBracketCharacter 
        ctx.Match(tkKeywordLanguage);
        ctx.Match(tkIdentifier);
        ctx.Match(tkLeftCurlyBracketCharacter);
        Parse_Declarations(ctx);
        ctx.Match(tkRightCurlyBracketCharacter);
    }
    else
    {
        assert(false);
    }
}

void Parse_Declaration(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordInterleave)
    {
        //Declaration =&gt; InterleaveDeclaration 
        Parse_InterleaveDeclaration(ctx);
    }
    else if (ctx.Token() == tkKeywordToken)
    {
        //Declaration =&gt; TokenDeclaration 
        Parse_TokenDeclaration(ctx);
    }
    else if (ctx.Token() == tkKeywordSyntax)
    {
        //Declaration =&gt; SyntaxDeclaration 
        Parse_SyntaxDeclaration(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_Declarations(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordInterleave)
    {
        //Declarations =&gt; Declaration Declarations 
        Parse_Declaration(ctx);
        Parse_Declarations(ctx);
    }
    else if (ctx.Token() == tkKeywordToken)
    {
        //Declarations =&gt; Declaration Declarations 
        Parse_Declaration(ctx);
        Parse_Declarations(ctx);
    }
    else if (ctx.Token() == tkKeywordSyntax)
    {
        //Declarations =&gt; Declaration Declarations 
        Parse_Declaration(ctx);
        Parse_Declarations(ctx);
    }
    else if (ctx.Token() == tkRightCurlyBracketCharacter)
    {
        //Declarations =&gt; Epsilon 
    }
    else
    {
        assert(false);
    }
}

void Parse_InterleaveDeclaration(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordInterleave)
    {
        //InterleaveDeclaration =&gt; KeywordInterleave Identifier EqualsCharacter TokenExpression SemicolonCharacter 
        ctx.Match(tkKeywordInterleave);
        ctx.Match(tkIdentifier);
        ctx.Match(tkEqualsCharacter);
        Parse_TokenExpression(ctx);
        ctx.Match(tkSemicolonCharacter);
    }
    else
    {
        assert(false);
    }
}

void Parse_TokenExpression(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //TokenExpression =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //TokenExpression =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //TokenExpression =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //TokenExpression =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //TokenExpression =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_TokenDeclaration(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordToken)
    {
        //TokenDeclaration =&gt; KeywordToken Identifier EqualsCharacter TokenExpression SemicolonCharacter 
        ctx.Match(tkKeywordToken);
        ctx.Match(tkIdentifier);
        ctx.Match(tkEqualsCharacter);
        Parse_TokenExpression(ctx);
        ctx.Match(tkSemicolonCharacter);
    }
    else
    {
        assert(false);
    }
}

void Parse_T(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //T =&gt; F ZeroOrMoreOrF 
        Parse_F(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //T =&gt; F ZeroOrMoreOrF 
        Parse_F(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //T =&gt; F ZeroOrMoreOrF 
        Parse_F(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //T =&gt; F ZeroOrMoreOrF 
        Parse_F(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //T =&gt; F ZeroOrMoreOrF 
        Parse_F(ctx);
        Parse_ZeroOrMoreOrF(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_ZeroOrMoreT(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //ZeroOrMoreT =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //ZeroOrMoreT =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //ZeroOrMoreT =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkSemicolonCharacter)
    {
        //ZeroOrMoreT =&gt; Epsilon 
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //ZeroOrMoreT =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else if (ctx.Token() == tkRightParenthesisCharacter)
    {
        //ZeroOrMoreT =&gt; Epsilon 
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //ZeroOrMoreT =&gt; T ZeroOrMoreT 
        Parse_T(ctx);
        Parse_ZeroOrMoreT(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpression(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordEmpty)
    {
        //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else if (ctx.Token() == tkLeftCurlyBracketCharacter)
    {
        //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //SyntaxExpression =&gt; SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxDeclaration(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordSyntax)
    {
        //SyntaxDeclaration =&gt; KeywordSyntax Identifier EqualsCharacter SyntaxExpression SemicolonCharacter 
        ctx.Match(tkKeywordSyntax);
        ctx.Match(tkIdentifier);
        ctx.Match(tkEqualsCharacter);
        Parse_SyntaxExpression(ctx);
        ctx.Match(tkSemicolonCharacter);
    }
    else
    {
        assert(false);
    }
}

void Parse_F(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //F =&gt; P OptOperator 
        Parse_P(ctx);
        Parse_OptOperator(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //F =&gt; P OptOperator 
        Parse_P(ctx);
        Parse_OptOperator(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //F =&gt; P OptOperator 
        Parse_P(ctx);
        Parse_OptOperator(ctx);
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //F =&gt; P OptOperator 
        Parse_P(ctx);
        Parse_OptOperator(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //F =&gt; P OptOperator 
        Parse_P(ctx);
        Parse_OptOperator(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_Main(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordModule)
    {
        //Main =&gt; ModuleBody 
        Parse_ModuleBody(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_P(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //P =&gt; V 
        Parse_V(ctx);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //P =&gt; V 
        Parse_V(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //P =&gt; V 
        Parse_V(ctx);
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //P =&gt; LeftParenthesisCharacter TokenExpression RightParenthesisCharacter 
        ctx.Match(tkLeftParenthesisCharacter);
        Parse_TokenExpression(ctx);
        ctx.Match(tkRightParenthesisCharacter);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //P =&gt; V 
        Parse_V(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_OptOperator(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkPlusCharacter)
    {
        //OptOperator =&gt; PlusCharacter 
        ctx.Match(tkPlusCharacter);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkSemicolonCharacter)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkQuestionMarkCharacter)
    {
        //OptOperator =&gt; QuestionMarkCharacter 
        ctx.Match(tkQuestionMarkCharacter);
    }
    else if (ctx.Token() == tkAsteriskCharacter)
    {
        //OptOperator =&gt; AsteriskCharacter 
        ctx.Match(tkAsteriskCharacter);
    }
    else if (ctx.Token() == tkVerticalLineCharacter)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkRightParenthesisCharacter)
    {
        //OptOperator =&gt; Epsilon 
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //OptOperator =&gt; Epsilon 
    }
    else
    {
        assert(false);
    }
}

void Parse_V(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //V =&gt; KeywordAny 
        ctx.Match(tkKeywordAny);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //V =&gt; LiteralChar RangeOpt 
        ctx.Match(tkLiteralChar);
        Parse_RangeOpt(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //V =&gt; Identifier 
        ctx.Match(tkIdentifier);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //V =&gt; StringLiteral 
        ctx.Match(tkStringLiteral);
    }
    else
    {
        assert(false);
    }
}

void Parse_RangeOpt(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordAny)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkRangeSeparator)
    {
        //RangeOpt =&gt; RangeSeparator LiteralChar 
        ctx.Match(tkRangeSeparator);
        ctx.Match(tkLiteralChar);
    }
    else if (ctx.Token() == tkPlusCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkSemicolonCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkQuestionMarkCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkAsteriskCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkVerticalLineCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkLeftParenthesisCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkRightParenthesisCharacter)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //RangeOpt =&gt; Epsilon 
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpressionSingle(Context&amp; ctx)
{
    if (ctx.Token() == tkKeywordEmpty)
    {
        //SyntaxExpressionSingle =&gt; KeywordEmpty 
        ctx.Match(tkKeywordEmpty);
    }
    else if (ctx.Token() == tkLiteralChar)
    {
        //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkLeftCurlyBracketCharacter)
    {
        //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //SyntaxExpressionSingle =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpressionMoreSingle(Context&amp; ctx)
{
    if (ctx.Token() == tkSemicolonCharacter)
    {
        //SyntaxExpressionMoreSingle =&gt; Epsilon 
    }
    else if (ctx.Token() == tkVerticalLineCharacter)
    {
        //SyntaxExpressionMoreSingle =&gt; VerticalLineCharacter SyntaxExpressionSingle SyntaxExpressionMoreSingle 
        ctx.Match(tkVerticalLineCharacter);
        Parse_SyntaxExpressionSingle(ctx);
        Parse_SyntaxExpressionMoreSingle(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpressionItem(Context&amp; ctx)
{
    if (ctx.Token() == tkLiteralChar)
    {
        //SyntaxExpressionItem =&gt; LiteralChar 
        ctx.Match(tkLiteralChar);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //SyntaxExpressionItem =&gt; Identifier 
        ctx.Match(tkIdentifier);
    }
    else if (ctx.Token() == tkLeftCurlyBracketCharacter)
    {
        //SyntaxExpressionItem =&gt; SyntaxExpressionAction 
        Parse_SyntaxExpressionAction(ctx);
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //SyntaxExpressionItem =&gt; StringLiteral 
        ctx.Match(tkStringLiteral);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpressionSingleFollow(Context&amp; ctx)
{
    if (ctx.Token() == tkLiteralChar)
    {
        //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkIdentifier)
    {
        //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkLeftCurlyBracketCharacter)
    {
        //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else if (ctx.Token() == tkSemicolonCharacter)
    {
        //SyntaxExpressionSingleFollow =&gt; Epsilon 
    }
    else if (ctx.Token() == tkVerticalLineCharacter)
    {
        //SyntaxExpressionSingleFollow =&gt; Epsilon 
    }
    else if (ctx.Token() == tkStringLiteral)
    {
        //SyntaxExpressionSingleFollow =&gt; SyntaxExpressionItem SyntaxExpressionSingleFollow 
        Parse_SyntaxExpressionItem(ctx);
        Parse_SyntaxExpressionSingleFollow(ctx);
    }
    else
    {
        assert(false);
    }
}

void Parse_SyntaxExpressionAction(Context&amp; ctx)
{
    if (ctx.Token() == tkLeftCurlyBracketCharacter)
    {
        //SyntaxExpressionAction =&gt; LeftCurlyBracketCharacter Identifier RightCurlyBracketCharacter 
        ctx.Match(tkLeftCurlyBracketCharacter);
        ctx.Match(tkIdentifier);
        ctx.Match(tkRightCurlyBracketCharacter);
    }
    else
    {
        assert(false);
    }
}
</code></pre>

<p>} //namespace Sample1</p>

<p>}}}</p>
</body></html>