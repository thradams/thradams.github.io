<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h1>Decomposição como forma de desacoplamento</h1>

<h2>Introdução</h2>
<p>Uma das métricas existentes para medir a qualidade de um software é o acoplamento entre classes.\\Um alto acoplamento entre classes cria um software difícil de manter e estender.\\Com isso, qualquer pequena mudança inicia uma cascata de mudanças em partes dependentes.\\Quando o tamanho desta cascata não é identificado pelos mantedores e designers o custo de uma mudança não pode ser estimado.\\Além disso, é criada uma fragilidade, pois pequenas mudanças podem ter um efeito inesperado em diversas partes do software.\\Devido a esta dificuldade, mudanças benéficas ao usuário são aprovadas com muito mais dificuldade e depois de aprovadas requerem um grande esforço e tempo para serem concluídas.\\No final, esta complexidade pode se refletir em custos e até em insatisfação de clientes.</p>

<p>O que eu quero mostrar aqui é que a idéia da decomposição de classes pode ser usada para se ver melhor o acoplamento e assim ser adotada uma estratégia para diminuí-lo.</p>


<h2>Medida de acoplamento</h2>
<p>Existem várias formas de acoplamento. Uma métrica de acoplamento pode ser definida pelo número de tipos utilizados por uma classe ou função.</p>

<p>Tipos básicos como inteiros não são levados em consideração.</p>

<p>Por exemplo:</p>


<pre>
<span class="keyword">void</span> F(X x, Y y)
{
  <span class="keyword">int</span> i = <span class="number">0</span>;
  Z z = x.z;
  ...
}
</pre>

<p>Neste caso o número de acoplamento de F é 3 pois usa os tipos X, Y e Z.</p>

<p>O valor de acoplamento para cada classe também deve ser levado em consideração. Neste exemplo e nos próximo o acoplamento indireto é 0 somente para facilitar.</p>

<p>Nota 1:\\Como medida de facilidade de reuso outros fatores também poderiam ser levados em consideração. Por exemplo, classes não relacionadas no mesmo header dificultam o reuso e criam uma dependência de compilação.</p>

<p>Nota 2:\\No VC++ 2008, 2010 existem métricas para código managed. Uma delas é justamente o Class Coupling que é calculado da seguinte maneira:</p>

<p>Class Coupling - Measures the coupling to unique classes through parameters, local variables, return types, method calls, generic or template instantiations, base classes, interface implementations, fields defined on external types, and attribute decoration. </p>



<h2>Acoplamento de funções membro</h2>
<p>Quando se trata de funções membro o &quot;this&quot; é um argumento implícito do tipo da classe.\\Com funções estáticas não existe dependência do argumento this, porém ainda existe dependência do tipo.</p>

<p>Exemplo:</p>
<pre>
<span class="keyword">class</span> Y;

<span class="keyword">class</span> X
{
};

<span class="keyword">class</span> Z
{
  X x;
<span class="keyword">public</span>:
  Z(Y&amp; y)
  {
  }
  <span class="keyword">static</span> <span class="keyword">void</span> F(<span class="keyword">int</span> i)
  {
  }

  <span class="keyword">void</span> F2(<span class="keyword">int</span> i)
  {
  }
}

</pre>


<p>Se a função F está na classe Z, então para usar F será preciso incluir Z e tudo o que Z necessita.\\Por exemplo, para usar F vou depender de Z que depende de X. O acoplamento de F neste caso é Z X.</p>

<p>Já no caso da função não estática F2 também é preciso uma instância de Z, ou seja tudo o que é preciso para criar Z. Como o construtor usa Y o acoplamento de F2 é X Y Z.</p>

<p>Com isso é possível ver que funções estáticas podem ter um menor acoplamento do que as não estáticas.\\E funções não membro (soltas) podem ter ainda menos acoplamento, pois se F não depende de Z o seu acoplamento poderia ser 0.</p>

<p>Com acoplamento zero F poderia ser reutilizada em qualquer parte do software sem precisar levar Z.</p>



<h2>A composição e decomposição de tipos </h2>
<p>Geralmente quando criamos classes estamos fazendo uma <strong>composição</strong> de tipos básicos.</p>

<p>Por exemplo:</p>
<pre>
<span class="keyword">class</span> Date
{
  <span class="keyword">int</span> day;
  <span class="keyword">int</span> month;
  <span class="keyword">int</span> year;
  <span class="keyword">public</span>:
...
};
</pre>


<p>No exemplo acima, a classe <strong>Date</strong> é formada por 3 dados fundamentais do tipo <strong>int</strong>.\\A métrica acoplamento da classe Date é zero, pois os tipos básicos não são levados em consideração.</p>



<p>Classes também podem ser uma composição de outras classes.</p>

<p>Exemplo:</p>

<pre>
<span class="keyword">class</span> Person
{
  <span class="keyword">int</span> id;
  Date birthday;
}
</pre>



<p>A classe <strong>Person</strong> é formada por um tipo básico <strong>int</strong> que é um identificador único da pessoa, e também possui sua data de nascimento com o tipo <strong>Date</strong>.\\Com isso a métrica de acoplamento da classe Person é 1, pois utiliza a classe Date.</p>



<p>Agora podemos fazer o caminho inverso e decompor a classe <strong>Person</strong>. \\Então é feita a explosão da classe que se quebra em tipos menores.</p>

<p>Uma primeira decomposição de Person poderia gerar:</p>
<pre>
 <span class="keyword">int</span> id;
 Date birthday;
</pre>

<p>E a decomposição completa:</p>
<pre>
 <span class="keyword">int</span> id;

 <span class="keyword">int</span> day;
 <span class="keyword">int</span> month;
 <span class="keyword">int</span> year;
</pre>




<h2>Como podemos usar essa explosão de tipos para diminuir o acoplamento?</h2>

<p>Para exemplificar vou utilizar a uma função &quot;GetAge&quot; que calcula a idade da pessoa representada pela classe Person, baseada no seu dia de nascimento.</p>

<pre>
<span class="keyword">int</span> GetAge(<span class="keyword">const</span> Person&amp; person)
{
  Date birthday = person.birthday;
  ...
}
</pre>

<p>A função GetAge recebe o parâmetro Person do qual vai perguntar a data de nascimento.</p>

<p>A métrica de acoplamento de da função acima é 2. Pois utiliza a classe Person e a classe Date através da data de nascimento.</p>

<p>Fazendo uma decomposição em <strong>Person</strong> poderíamos ter:</p>

<pre>
<span class="keyword">int</span> GetAge(<span class="keyword">int</span> id, Date&amp;)
{
  ...
  <span class="keyword">return</span> years;
}
</pre>

<p>Neste caso o acoplamento é um, pois utiliza somente a classe Date.</p>

<p>Se decompormos <strong>Date</strong> temos:</p>

<pre>
<span class="keyword">int</span> GetAge(<span class="keyword">int</span> id, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)
{
  ...
  <span class="keyword">return</span> years;
}
</pre>

<p>Agora o acoplamento é zero.</p>


<p>Com estes exemplos é possível ver que explodindo classes em tipos básicos o acoplamento vai diminuindo.\\Por outro lado, o encapsulamento e a lógica dos dados é perdida.\\Na função GetAge que não recebe nenhuma classe, a validação de year, month e day deveria ser feita na função afinal nada garante a origem dos dados.\\Caso outras funções de data fossem escritas esta lógica de validação iria ficar duplicada ou uma função de validação seria compartilhada. Mas de qualquer forma o encapsulamento dos dados seria perdida.</p>

<p>Moral da história: </p>

<h1> Decompondo classes o acoplamento vai diminuindo</h1>
<h1> Quando fazemos a decomposição fica mais fácil perceber que nem todas as partes da classe são usadas em determinada função.</h1>
<h1> Não adianta decompor a classe a tal ponto que se perca o encapsulamento</h1>
<h1> Acoplamento menor não significa que é melhor</h1>


<p>Então a melhor forma de escrever GetAge seria:</p>

<pre>
  <span class="keyword">int</span> GetAge(<span class="keyword">const</span> Date&amp; date)
  { 
    ...
    <span class="keyword">return</span> years;
  }
</pre>


<p>Pois tem o menor acoplamento sem perder o encapulamento.</p>

<p>A solução genérica seria uma função que calcula o número de anos entre Datas.\\A GetAge poderia ser apenas uma interpretação desta função e poderia ser membro da classe Person ou não membro. \\O reuso da função não seria através de person mas através da Função DifferenceInYears por exemplo.Como &quot;DifferenceInYears&quot; depende de Date ela pode ficar no mesmo header.</p>

<h2>Então qual seria a melhor ponto de decomposição?</h2>
<p>O melhor ponto é aquele em que não se perde o encapsulamento para efeitos daquela operação e se tem os tipos fundamentais para aquela função</p>

<h2>Conclusão</h2>
<p>Espero que esta visão mostrada aqui de decompor a classe seja útil para demonstrar a idéia de que funções podem ter um menor acoplamento e uma maior clareza se elas utilizarem os dados e tipos mínimos necessários para funcionar mantendo o encapsulamento naquele contexto.</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  