<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->


<p>Functions to print the equivalent uniform initialization expression of a value.</p>

<p>Implemented so far for these types:</p>

<ul>
<li> vector</li>
<li> set</li>
<li> map</li>
<li> basic</li>
<li> integral types</li>
<li> bool</li>
</ul>


<pre>
<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;
<span class="keyword">#include</span> &lt;set&gt;
<span class="keyword">#include</span> &lt;map&gt;
<span class="keyword">#include</span> &lt;type_traits&gt;


<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> YourType&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os, <span class="keyword">const</span> YourType&amp; v)
{
    <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="string">&quot;especialize this function for your type!&quot;</span>);
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> T&gt;
<span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="keyword">void</span>&gt;::type
PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os, <span class="keyword">const</span> T&amp; v)
{
    os &lt;&lt; v;
}

<span class="keyword">char</span> PrintL(<span class="keyword">char</span>){  <span class="keyword">return</span> <span class="string">'\0'</span>;}
<span class="keyword">char</span> PrintL(<span class="keyword">wchar_t</span>) { <span class="keyword">return</span> <span class="string">'L'</span>; }

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;<span class="keyword">char</span>, CharTraits&gt; &amp; os, <span class="keyword">const</span> std::basic_string&lt;CharType&gt;&amp; v)
{
    os &lt;&lt; PrintL((CharType) <span class="number">0</span>) &lt;&lt; <span class="string">'&quot;'</span>;

    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; v.size(); i++)
    {
        os &lt;&lt; (<span class="keyword">char</span>) v[i]; <span class="comment">//TODO ranges
</span>    }

    os &lt;&lt; <span class="string">'&quot;'</span>;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;<span class="keyword">wchar_t</span>, CharTraits&gt; &amp; os, <span class="keyword">const</span> std::basic_string&lt;CharType&gt;&amp; v)
{
    os &lt;&lt; PrintL((CharType) <span class="number">0</span>) &lt;&lt; <span class="string">'&quot;'</span>;

    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; v.size(); i++)
    {
        os &lt;&lt; (<span class="keyword">wchar_t</span>) v[i]; <span class="comment">//TODO ranges
</span>    }

    os &lt;&lt; L<span class="string">'&quot;'</span>;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharTraits&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;<span class="keyword">char</span>, CharTraits&gt; &amp; os, <span class="keyword">bool</span> v)
{
    os &lt;&lt; (v ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharTraits&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;<span class="keyword">wchar_t</span>, CharTraits&gt; &amp; os, <span class="keyword">bool</span> v)
{
    os &lt;&lt; (v ? L<span class="string">&quot;true&quot;</span> : L<span class="string">&quot;false&quot;</span>);
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> Iterator&gt;
<span class="keyword">void</span> PrintSequence(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os,
                   Iterator beginIt,
                   Iterator endIt)
{
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type T;
    os &lt;&lt; (CharType)<span class="string">'{'</span>;
    <span class="keyword">auto</span> it = beginIt;

    <span class="keyword">if</span> (it != endIt)
    {
        PrintUniformInitialization(os, *it);
        ++it;
    }

    <span class="keyword">for</span> (; it != endIt; it++)
    {
        os &lt;&lt; (CharType) <span class="string">','</span> &lt;&lt; (CharType) <span class="string">' '</span>;
        PrintUniformInitialization(os, *it);
    }

    os &lt;&lt; (CharType)<span class="string">'}'</span>;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> T, <span class="keyword">class</span> TAllocator&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os,
                                <span class="keyword">const</span> std::<span class="keyword2">vector</span>&lt;T, TAllocator&gt;&amp; v)
{
    PrintSequence(os, v.cbegin(), v.cend());
}


<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> T, <span class="keyword">class</span> TComp, <span class="keyword">class</span> TAllocator&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os,
                                <span class="keyword">const</span> std::set&lt;T, TComp, TAllocator&gt;&amp; v)
{
    PrintSequence(os, v.cbegin(), v.cend());
}

<span class="keyword">template</span> &lt; <span class="keyword">class</span> CharType,
         <span class="keyword">class</span> CharTraits,
         <span class="keyword">class</span> _Kty,
         <span class="keyword">class</span> _Ty,
         <span class="keyword">class</span> _Pr,
         <span class="keyword">class</span> _Alloc &gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os,
                                <span class="keyword">const</span> std::map&lt;_Kty, _Ty, _Pr, _Alloc&gt;&amp; m)
{
    os &lt;&lt; (CharType)<span class="string">'{'</span>;
    <span class="keyword">auto</span> it = m.cbegin();

    <span class="keyword">if</span> (it != m.cend())
    {
        os &lt;&lt; (CharType)<span class="string">'{'</span>;
        PrintUniformInitialization(os, it-&gt;first);
        os &lt;&lt; (CharType)<span class="string">','</span> &lt;&lt; (CharType)<span class="string">' '</span>;
        PrintUniformInitialization(os, it-&gt;second);
        os &lt;&lt; (CharType)<span class="string">'}'</span>;
        ++it;
    }

    <span class="keyword">for</span> (; it != m.cend(); it++)
    {
        os &lt;&lt; (CharType)<span class="string">','</span> &lt;&lt; (CharType)<span class="string">' '</span>;
        os &lt;&lt; (CharType)<span class="string">'{'</span>;
        PrintUniformInitialization(os, it-&gt;first);
        os &lt;&lt; (CharType)<span class="string">','</span> &lt;&lt; (CharType)<span class="string">' '</span>;
        PrintUniformInitialization(os, it-&gt;second);
        os &lt;&lt; (CharType)<span class="string">'}'</span>;
    }

    os &lt;&lt; (CharType)<span class="string">'}'</span>;
}

<span class="comment">//Printing the type name
</span>
<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; , T*)
{
  <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="string">&quot;overload for your type&quot;</span>); 
}

<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, std::<span class="keyword2">wstring</span>*) {  os &lt;&lt; <span class="string">&quot;std::wstring&quot;</span>;}
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, std::<span class="keyword2">string</span>*) {  os &lt;&lt; <span class="string">&quot;std::string&quot;</span>;}
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, <span class="keyword">int</span>*) { os &lt;&lt; <span class="string">&quot;int&quot;</span>; }
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, <span class="keyword">double</span>*) {  os &lt;&lt; <span class="string">&quot;double&quot;</span>; }
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, <span class="keyword">bool</span>*) {  os &lt;&lt; <span class="string">&quot;bool&quot;</span>; }
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, <span class="keyword">char</span>*) {  os &lt;&lt; <span class="string">&quot;char&quot;</span>; }

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, std::<span class="keyword2">vector</span>&lt;T&gt;*) 
{
  os &lt;&lt; <span class="string">&quot;std::vector&lt;&quot;</span>;
  PrintTypeName(os, (T*)<span class="keyword">nullptr</span>);
  os &lt;&lt; <span class="string">&quot;&gt;&quot;</span>; 
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, std::set&lt;T&gt;*) 
{
  os &lt;&lt; <span class="string">&quot;std::set&lt;&quot;</span>;
  PrintTypeName(os, (T*)<span class="keyword">nullptr</span>);
  os &lt;&lt; <span class="string">&quot;&gt;&quot;</span>; 
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> K, <span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, std::map&lt;T, K&gt;*) 
{
  os &lt;&lt; <span class="string">&quot;std::map&lt;&quot;</span>;
  PrintTypeName(os, (K*)<span class="keyword">nullptr</span>);
  os &lt;&lt; <span class="string">&quot;, &quot;</span>;
  PrintTypeName(os, (T*)<span class="keyword">nullptr</span>);
  os &lt;&lt; <span class="string">&quot;&gt;&quot;</span>; 
}


</pre>


<p>Sample:</p>

<pre>

<span class="keyword">struct</span> MyType
{
    std::<span class="keyword2">wstring</span> x;
    <span class="keyword">bool</span> v;
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits&gt;
<span class="keyword">void</span> PrintUniformInitialization(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os, <span class="keyword">const</span> MyType&amp; v)
{
    os &lt;&lt; (CharType)<span class="string">'{'</span>;
    PrintUniformInitialization(os, v.x);
    os &lt;&lt; (CharType)<span class="string">','</span> &lt;&lt; (CharType)<span class="string">' '</span>;
    PrintUniformInitialization(os, v.v);
    os &lt;&lt; (CharType)<span class="string">'}'</span>;
}

<span class="keyword">void</span> PrintTypeName(std::ostream&amp; os, MyType*) 
{
  os &lt;&lt; <span class="string">&quot;MyType&quot;</span>; 
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> CharType, <span class="keyword">class</span> CharTraits, <span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintUniformInitializationLn(std::basic_ostream&lt;CharType, CharTraits&gt; &amp; os, <span class="keyword">const</span> T&amp; v)
{
    PrintTypeName(os, (T*)<span class="keyword">nullptr</span>);     
    os &lt;&lt; std::endl;
    PrintUniformInitialization(os, v);
    os &lt;&lt; std::endl;
    os &lt;&lt; std::endl;
}

  
<span class="keyword">int</span> main()
{
    <span class="keyword">using</span> <span class="keyword">namespace</span> std;
    <span class="keyword2">vector</span>&lt;MyType&gt; vx;
    MyType x;
    x.v = <span class="keyword">false</span>;
    vx.push_back(x);
    PrintUniformInitializationLn(cout, vx);
    map&lt;std::<span class="keyword2">wstring</span>, <span class="keyword">bool</span>&gt; m;
    m[L<span class="string">&quot;a&quot;</span>] = <span class="keyword">true</span>;
    m[L<span class="string">&quot;b&quot;</span>] = <span class="keyword">false</span>;
    PrintUniformInitializationLn(cout, m);
    std::<span class="keyword2">vector</span>&lt;std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;
    v.push_back(std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));
    v.push_back(std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));
    PrintUniformInitializationLn(cout, m);
    std::set&lt;std::<span class="keyword2">wstring</span>&gt; st;
    st.insert(L<span class="string">&quot;aa&quot;</span>);
    st.insert(L<span class="string">&quot;bb&quot;</span>);
    PrintUniformInitializationLn(cout, st);
    std::<span class="keyword2">vector</span>&lt;<span class="keyword">bool</span>&gt; vb;
    vb.push_back(<span class="keyword">false</span>);
    vb.push_back(<span class="keyword">true</span>);
    PrintUniformInitializationLn(cout, vb);
}

</pre>


<p>Output:</p>
<pre>

std::vector&lt;MyType&gt;
{{L&quot;&quot;, false}}

std::map&lt;bool, std::wstring&gt;
{{L&quot;a&quot;, true}, {L&quot;b&quot;, false}}

std::map&lt;bool, std::wstring&gt;
{{L&quot;a&quot;, true}, {L&quot;b&quot;, false}}

std::set&lt;std::wstring&gt;
{L&quot;aa&quot;, L&quot;bb&quot;}

std::vector&lt;bool&gt;
{false, true}

</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  