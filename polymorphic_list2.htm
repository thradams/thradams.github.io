
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<p>Sample</p>
<pre>
<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">#include</span> <span class="string">&quot;polymorphic_list.h&quot;</span>
<span class="keyword">#include</span> &lt;cassert&gt;

<span class="keyword">using</span> <span class="keyword">namespace</span> std;

<span class="keyword">struct</span> Box
{
    <span class="keyword">int</span> i;
    Box(<span class="keyword">int</span> x) : i(x)
    {
    }

    <span class="keyword">void</span> Draw()
    {
        cout &lt;&lt; <span class="string">&quot;I am Box class&quot;</span> &lt;&lt; endl;
    }
};

<span class="keyword">struct</span> Circle
{
    <span class="keyword">int</span> radius;
    Circle(<span class="keyword">int</span> r) : radius(r)
    {
    }

    <span class="keyword">void</span> Draw()
    {
        cout &lt;&lt; <span class="string">&quot;I am Circle class&quot;</span> &lt;&lt; endl;
    }
};



<span class="keyword">void</span> Sample1()
{
    polymorphic_list <span class="keyword2">list</span>;
    
    emplace_back&lt;Box&gt;(<span class="keyword2">list</span>, <span class="number">2</span>);
    emplace_back&lt;Circle&gt;(<span class="keyword2">list</span>, <span class="number">1</span>);
    
    <span class="comment">//Option 1
</span>    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : <span class="keyword2">list</span>)
    {
        <span class="keyword">switch</span> (is_index&lt;Box, Circle&gt;(item))
        {
        <span class="keyword">case</span> <span class="number">1</span>:
            ref&lt;Box&gt;(item).Draw();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">2</span>:
            ref&lt;Circle&gt;(item).Draw();
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            assert(<span class="keyword">false</span>);
        }
    }

    <span class="comment">//Option 2
</span>    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : <span class="keyword2">list</span>)
    {
        <span class="keyword">if</span> (<span class="keyword">auto</span> p = is_ptr&lt;Box&gt;(item))
        {
            p-&gt;Draw();
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> p = is_ptr&lt;Circle&gt;(item))
        {
            p-&gt;Draw();
        }
        <span class="keyword">else</span>
        {
            assert(<span class="keyword">false</span>);
        }
    }
}

<span class="keyword">int</span> main()
{
    Sample1();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre>



<p>Code</p>
<pre>
<span class="keyword">#pragma</span> once
<span class="keyword">#include</span> &lt;algorithm&gt;
<span class="keyword">#include</span> &lt;cassert&gt;
<span class="keyword">#include</span> &lt;memory&gt;

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">static</span> size_t type_id()
{
    <span class="keyword">static</span> size_t id = <span class="keyword">sizeof</span>(T);
    <span class="keyword">return</span> (size_t) &amp;id;
}

<span class="keyword">class</span> type_pointer
{
    size_t m_id = <span class="number">0</span>;
    <span class="keyword">void</span> * m_pObject = <span class="keyword">nullptr</span>;
    <span class="keyword">const</span> type_info * m_ti;
<span class="keyword">protected</span>:

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
    <span class="keyword">void</span> set_pointer(T* p)
    {
        m_ti = &amp;<span class="keyword">typeid</span>(T);
        m_pObject = p;
        m_id = type_id&lt;T&gt;();
    }

<span class="keyword">public</span>:

    <span class="keyword">friend</span> size_t id(<span class="keyword">const</span> type_pointer&amp; tp)
    {
        <span class="keyword">return</span> tp.m_id;
    }

    <span class="keyword">friend</span> <span class="keyword">void</span>* ptr(<span class="keyword">const</span> type_pointer&amp; tp)
    {
        <span class="keyword">return</span> tp.m_pObject;
    }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
T* ptr(<span class="keyword">const</span> type_pointer&amp; tp)
{
    assert(is&lt;T&gt;(tp));
    <span class="keyword">return</span> (T*) ptr(tp);
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
T&amp; ref(<span class="keyword">const</span> type_pointer&amp; tp)
{
    assert(is&lt;T&gt;(tp));
    <span class="keyword">return</span> *((T*) ptr(tp));
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
T* is_ptr(<span class="keyword">const</span> type_pointer&amp; tp)
{
    <span class="keyword">return</span> is&lt;T&gt;(tp) ? ptr&lt;T&gt;(tp) : <span class="keyword">nullptr</span>;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">bool</span> is(<span class="keyword">const</span> type_pointer&amp; tp)
{
    <span class="keyword">return</span> id(tp) == type_id&lt;T&gt;();
}

<span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;
<span class="keyword">int</span> is_index_imp(<span class="keyword">const</span> type_pointer&amp;)
{
    <span class="keyword">return</span> <span class="number">-1</span>;
}

<span class="keyword">template</span>&lt;<span class="keyword">int</span> N, <span class="keyword">class</span> T1, <span class="keyword">typename</span>... TN&gt;
<span class="keyword">int</span> is_index_imp(<span class="keyword">const</span> type_pointer&amp; tp)
{
    <span class="keyword">if</span> (is&lt;T1&gt;(tp))
    {
        <span class="keyword">return</span> N;
    }

    <span class="keyword">return</span> is_index_imp&lt;N + <span class="number">1</span>, TN...&gt;(tp);
}

<span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TN&gt;
<span class="keyword">int</span> is_index(<span class="keyword">const</span> type_pointer&amp; tp)
{
    <span class="keyword">return</span> is_index_imp&lt;<span class="number">1</span>, TN...&gt;(tp);
}

<span class="keyword">struct</span> polymorphic_list_node_base : <span class="keyword">public</span> type_pointer
{
    polymorphic_list_node_base* m_next;
    polymorphic_list_node_base* m_prev;
    polymorphic_list_node_base(polymorphic_list_node_base* p,
        polymorphic_list_node_base* n)
        : m_next(n)
        , m_prev(p)
    {
    }

    <span class="keyword">friend</span> polymorphic_list_node_base* next(polymorphic_list_node_base&amp; node)
    {
        <span class="keyword">return</span> node.m_next;
    }

    <span class="keyword">friend</span> polymorphic_list_node_base* prev(polymorphic_list_node_base&amp; node)
    {
        <span class="keyword">return</span> node.m_prev;
    }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">struct</span> polymorphic_list_node : <span class="keyword">public</span> polymorphic_list_node_base
{
    T m_data;
    <span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;
    polymorphic_list_node(polymorphic_list_node_base* p,
        polymorphic_list_node_base* n,
        Args&amp;&amp;... args)
        : polymorphic_list_node_base(p, n)
        , m_data(args...)

    {
        set_pointer&lt;T&gt;(&amp;m_data);
    }
};

<span class="keyword">struct</span> polymorphic_list_iterator
{
    <span class="keyword">typedef</span> polymorphic_list_iterator iterator;
    <span class="keyword">typedef</span> polymorphic_list_iterator const_iterator;
    <span class="keyword">typedef</span> type_pointer              value_type;
    <span class="keyword">typedef</span> value_type*               pointer;
    <span class="keyword">typedef</span> value_type&amp;               reference;
    <span class="keyword">typedef</span> size_t                    size_type;
    <span class="keyword">typedef</span> ptrdiff_t                 difference_type;

    polymorphic_list_node_base* m_pNode;

    polymorphic_list_iterator(polymorphic_list_node_base* x) : m_pNode(x)
    {
    }

    polymorphic_list_iterator(<span class="keyword">const</span> iterator&amp; x)
        : m_pNode(x.m_pNode)
    {
    }

    polymorphic_list_iterator()
    {
    }

    <span class="keyword">void</span> Increment()
    {
        m_pNode = next(*m_pNode);
    }

    <span class="keyword">void</span> Decrement()
    {
        m_pNode = prev(*m_pNode);
    }

    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> polymorphic_list_iterator&amp; x) <span class="keyword">const</span>
    {
        <span class="keyword">return</span> m_pNode == x.m_pNode;
    }

    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> polymorphic_list_iterator&amp; x) <span class="keyword">const</span>
    {
        <span class="keyword">return</span> m_pNode != x.m_pNode;
    }

    reference <span class="keyword">operator</span>*() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> *(m_pNode);
    }

    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());
    }

    polymorphic_list_iterator&amp; <span class="keyword">operator</span>++()
    {
        <span class="keyword">this</span>-&gt;Increment();
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    polymorphic_list_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)
    {
        <span class="keyword">auto</span> tmp = *<span class="keyword">this</span>;
        <span class="keyword">this</span>-&gt;Increment();
        <span class="keyword">return</span> tmp;
    }

    polymorphic_list_iterator&amp; <span class="keyword">operator</span>--()
    {
        <span class="keyword">this</span>-&gt;Decrement();
        <span class="keyword">return</span> *<span class="keyword">this</span>;
    }

    polymorphic_list_iterator <span class="keyword">operator</span>--(<span class="keyword">int</span>)
    {
        <span class="keyword">auto</span> tmp = *<span class="keyword">this</span>;
        <span class="keyword">this</span>-&gt;Decrement();
        <span class="keyword">return</span> tmp;
    }
};

<span class="keyword">class</span> polymorphic_list
{
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> type_pointer              value_type;
    <span class="keyword">typedef</span> value_type*               pointer;
    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type*         const_pointer;
    <span class="keyword">typedef</span> value_type&amp;               reference;
    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp;         const_reference;
    <span class="keyword">typedef</span> size_t                    size_type;
    <span class="keyword">typedef</span> ptrdiff_t                 difference_type;
    <span class="keyword">typedef</span> polymorphic_list_iterator iterator;
    <span class="keyword">typedef</span> polymorphic_list_iterator const_iterator;

    <span class="keyword">explicit</span> polymorphic_list()
    {
        m_pNode = <span class="keyword">new</span> polymorphic_list_node&lt;Empty&gt;(<span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);
        m_pNode-&gt;m_next = m_pNode;
        m_pNode-&gt;m_prev = m_pNode;
    }

    ~polymorphic_list()
    {
        clear();
    }

<span class="keyword">private</span>:
    polymorphic_list_node_base* m_pNode;

    <span class="keyword">struct</span> Empty
    {
    };

    iterator insert_node(iterator position, polymorphic_list_node_base* tmp)
    {
        tmp-&gt;m_next = position.m_pNode;
        tmp-&gt;m_prev = prev(*position.m_pNode);
        position.m_pNode-&gt;m_prev-&gt;m_next = tmp;
        position.m_pNode-&gt;m_prev = tmp;
        <span class="keyword">return</span> tmp;
    }

    std::<span class="keyword2">unique_ptr</span>&lt;polymorphic_list_node_base&gt; remove(iterator position)
    {
        <span class="keyword">auto</span>* next_node = next(*position.m_pNode);
        <span class="keyword">auto</span>* prev_node = prev(*position.m_pNode);
        <span class="keyword">auto</span>* n = position.m_pNode;
        prev_node-&gt;m_next = next_node;
        next_node-&gt;m_prev = prev_node;

        n-&gt;m_next = <span class="keyword">nullptr</span>;
        n-&gt;m_prev = <span class="keyword">nullptr</span>;
        <span class="keyword">return</span> std::<span class="keyword2">unique_ptr</span>&lt;polymorphic_list_node_base&gt;(n);
    }

    polymorphic_list&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> polymorphic_list&amp; x) = <span class="keyword">delete</span>;
    polymorphic_list(polymorphic_list&amp;) = <span class="keyword">delete</span>;

    <span class="keyword">void</span> clear()
    {
        <span class="keyword">auto</span>* cur = next(*m_pNode);
        <span class="keyword">while</span> (cur != m_pNode)
        {
            <span class="keyword">auto</span>* tmp = cur;
            cur = next(*cur);
            <span class="keyword">delete</span> tmp;
        }
        m_pNode-&gt;m_next = m_pNode;
        m_pNode-&gt;m_prev = m_pNode;
    }

    <span class="keyword">friend</span> iterator begin(polymorphic_list&amp; lst)
    {
        <span class="keyword">return</span> next(*lst.m_pNode);
    }

    <span class="keyword">friend</span> const_iterator cbegin(<span class="keyword">const</span> polymorphic_list&amp; lst)
    {
        <span class="keyword">return</span> next(*lst.m_pNode);
    }

    <span class="keyword">friend</span> iterator end(polymorphic_list&amp; lst)
    {
        <span class="keyword">return</span> lst.m_pNode;
    }

    <span class="keyword">friend</span> const_iterator cend(<span class="keyword">const</span> polymorphic_list&amp; lst)
    {
        <span class="keyword">return</span> lst.m_pNode;
    }

    <span class="keyword">friend</span> <span class="keyword">bool</span> empty(<span class="keyword">const</span> polymorphic_list&amp; lst)
    {
        <span class="keyword">return</span> next(*lst.m_pNode) == lst.m_pNode;
    }

    <span class="keyword">friend</span> <span class="keyword">void</span> swap(polymorphic_list&amp; a, polymorphic_list&amp; b)
    {
        std::swap(a.m_pNode, b.m_pNode);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;
    <span class="keyword">friend</span> iterator emplace_insert(polymorphic_list&amp; <span class="keyword2">list</span>, iterator position, Args&amp;&amp;... args)
    {
        <span class="keyword">auto</span>* tmp = <span class="keyword">new</span> polymorphic_list_node&lt;T&gt;(<span class="keyword">nullptr</span>,
            <span class="keyword">nullptr</span>,
            std::forward&lt;Args&gt;(args)...);
        <span class="keyword">return</span> <span class="keyword2">list</span>.insert_node(position, tmp);
    }

    <span class="keyword">friend</span> <span class="keyword">void</span> move_to(polymorphic_list&amp; from, iterator position, polymorphic_list&amp; into)
    {
        <span class="keyword">auto</span> sp = from.remove(position);
        into.insert_node(end(into), sp.release());
    }

    <span class="keyword">friend</span> polymorphic_list::iterator erase(polymorphic_list&amp; <span class="keyword2">list</span>, polymorphic_list::iterator position)
    {
        <span class="keyword">auto</span>* next_node = next(*position.m_pNode);
        <span class="keyword">auto</span>* prev_node = prev(*position.m_pNode);
        <span class="keyword">auto</span>* n = position.m_pNode;
        prev_node-&gt;m_next = next_node;
        next_node-&gt;m_prev = prev_node;
        <span class="keyword">delete</span> n;
        <span class="keyword">return</span> iterator(next_node);
    }

    <span class="keyword">friend</span> <span class="keyword">void</span> clear(polymorphic_list&amp; <span class="keyword2">list</span>)
    {
        <span class="keyword2">list</span>.clear();
    }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span>... Args&gt;
<span class="keyword">void</span> emplace_back(polymorphic_list&amp; <span class="keyword2">list</span>, Args&amp;&amp;... args)
{
    emplace_insert&lt;T&gt;(<span class="keyword2">list</span>, end(<span class="keyword2">list</span>), std::forward&lt;Args&gt;(args)...);
}

<span class="keyword">inline</span> polymorphic_list::iterator erase(polymorphic_list&amp; <span class="keyword2">list</span>,
    polymorphic_list::iterator first,
    polymorphic_list::iterator last)
{
    <span class="keyword">while</span> (first != last)
        erase(<span class="keyword2">list</span>, first++);
    <span class="keyword">return</span> last;
}

<span class="keyword">inline</span> polymorphic_list::reference front(polymorphic_list&amp; lst)
{
    <span class="keyword">return</span> *begin(lst);
}

<span class="keyword">inline</span> polymorphic_list::const_reference  cfront(<span class="keyword">const</span> polymorphic_list&amp; lst)
{
    <span class="keyword">return</span> *cbegin(lst);
}

<span class="keyword">inline</span> <span class="keyword">void</span> pop_front(polymorphic_list&amp; <span class="keyword2">list</span>)
{
    erase(<span class="keyword2">list</span>, begin(<span class="keyword2">list</span>));
}

<span class="keyword">inline</span> <span class="keyword">void</span> pop_back(polymorphic_list&amp; <span class="keyword2">list</span>)
{
    <span class="keyword">auto</span> tmp = end(<span class="keyword2">list</span>);
    erase(<span class="keyword2">list</span>, --tmp);
}

<span class="keyword">inline</span> polymorphic_list::reference back(polymorphic_list&amp; lst)
{
    <span class="keyword">return</span> *(--end(lst));
}

<span class="keyword">inline</span> polymorphic_list::const_reference cback(<span class="keyword">const</span> polymorphic_list&amp; lst)
{
    <span class="keyword">return</span> *(--cend(lst));
}


</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  