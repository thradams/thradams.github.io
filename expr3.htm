<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->

<pre>

<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> &lt;cassert&gt;
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> <span class="string">&quot;Array2D.h&quot;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> std;

<span class="keyword">bool</span> IsOperator(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'N'</span>:
        <span class="keyword">case</span> L<span class="string">'^'</span>:
        <span class="keyword">case</span> L<span class="string">'*'</span>:
        <span class="keyword">case</span> L<span class="string">'/'</span>:
        <span class="keyword">case</span> L<span class="string">'-'</span>:
        <span class="keyword">case</span> L<span class="string">'+'</span>:
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="keyword">int</span> OperatorPop(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'N'</span>:
            <span class="keyword">return</span> <span class="number">1</span>;

        <span class="keyword">case</span> L<span class="string">'^'</span>:
            <span class="keyword">return</span> <span class="number">2</span>;

        <span class="keyword">case</span> L<span class="string">'*'</span>:
        <span class="keyword">case</span> L<span class="string">'/'</span>:
            <span class="keyword">return</span> <span class="number">2</span>;

        <span class="keyword">case</span> L<span class="string">'-'</span>:
        <span class="keyword">case</span> L<span class="string">'+'</span>:
            <span class="keyword">return</span> <span class="number">2</span>;
    }

    <span class="comment">//letras
</span>    <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)
    {
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    assert(<span class="keyword">false</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
<span class="keyword">int</span> GetPrecedence(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'P'</span>:
        <span class="keyword">case</span> L<span class="string">'N'</span>:
            <span class="keyword">return</span> <span class="number">20</span>;

        <span class="keyword">case</span> L<span class="string">'^'</span>:
            <span class="keyword">return</span> <span class="number">10</span>;

        <span class="keyword">case</span> L<span class="string">'*'</span>:
        <span class="keyword">case</span> L<span class="string">'/'</span>:
            <span class="keyword">return</span> <span class="number">30</span>;

        <span class="keyword">case</span> L<span class="string">'-'</span>:
        <span class="keyword">case</span> L<span class="string">'+'</span>:
            <span class="keyword">return</span> <span class="number">40</span>;
    }

    <span class="comment">//letras
</span>    <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)
    {
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    assert(<span class="keyword">false</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="keyword">bool</span> IsUnary(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'N'</span>:
            <span class="keyword">return</span> <span class="keyword">true</span>;
        <span class="keyword">case</span> L<span class="string">'P'</span>:
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">//letras
</span>    <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)
    {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="keyword">bool</span> IsBinaryOperator(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'-'</span>:
        <span class="keyword">case</span> L<span class="string">'+'</span>:
        <span class="keyword">case</span> L<span class="string">'*'</span>:
        <span class="keyword">case</span> L<span class="string">'/'</span>:
        <span class="keyword">case</span> L<span class="string">'^'</span>:
            <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="keyword">wchar_t</span> Unary(<span class="keyword">wchar_t</span> ch)
{
    <span class="keyword">switch</span> (ch)
    {
        <span class="keyword">case</span> L<span class="string">'-'</span>:
            <span class="keyword">return</span> L<span class="string">'N'</span>;

        <span class="keyword">case</span> L<span class="string">'+'</span>:
            <span class="keyword">return</span> L<span class="string">'P'</span>;
    }

    assert(<span class="keyword">false</span>);
}

<span class="keyword">void</span> Generate(std::<span class="keyword2">vector</span>&lt;std::<span class="keyword2">wstring</span>&gt;&amp; result, <span class="keyword">wchar_t</span> ch)
{
    <span class="comment">////////////////////////////////////////////////////////////
</span>    <span class="keyword">if</span> (IsBinaryOperator(ch))
    {
        std::<span class="keyword2">wstring</span> strA = result.back();
        result.pop_back();
        std::<span class="keyword2">wstring</span> strB = result.back();
        result.pop_back();
        result.push_back(strB + L<span class="string">&quot; &quot;</span> + strA + L<span class="string">&quot; &quot;</span> + ch) ;
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (IsUnary(ch))
    {
        std::<span class="keyword2">wstring</span> strA = result.back();
        result.pop_back();
        result.push_back(strA + L<span class="string">&quot; &quot;</span> + ch);
    }

    <span class="comment">////////////////////////////////////////////////////////////
</span>}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<span class="keyword">void</span> F(Iterator&amp; it,
       Iterator end,
       <span class="keyword">wchar_t</span> close,
       std::<span class="keyword2">wstring</span>&amp; out)
{
    std::<span class="keyword2">vector</span>&lt;<span class="keyword">wchar_t</span>&gt; stack;
    std::<span class="keyword2">vector</span>&lt;std::<span class="keyword2">wstring</span>&gt; result;
    <span class="keyword">bool</span> doNext = <span class="keyword">true</span>;
    <span class="keyword">bool</span> previousWorksLikeIndentifier = <span class="keyword">false</span>;

    <span class="keyword">for</span> (; it  != end &amp;&amp; *it != close;)
    {
        <span class="keyword">wchar_t</span> ch = *it;

        <span class="keyword">if</span> (ch == L<span class="string">'('</span>)
        {
            std::<span class="keyword2">wstring</span> outtemp;
            it++;
            F(it, end, L<span class="string">')'</span>, outtemp);
            result.push_back(outtemp);
            previousWorksLikeIndentifier = <span class="keyword">true</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (IsOperator(ch))
        {
            <span class="keyword">if</span> (!previousWorksLikeIndentifier)
            {
                <span class="comment">//unario
</span>                stack.push_back(Unary(ch));
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (!stack.empty() &amp;&amp; GetPrecedence(stack.back()) &lt;= GetPrecedence(ch))
            {
                Generate(result, ch);
                stack.pop_back();
                stack.push_back(ch);
            }
            <span class="keyword">else</span>
            {
                stack.push_back(ch);
            }

            previousWorksLikeIndentifier = <span class="keyword">false</span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)
        {
            <span class="comment">//tem que ver se o prox eh (
</span>            <span class="comment">//se for eh operator se nao for eh indentificador
</span>            it++;
            <span class="keyword">wchar_t</span> ch2 = *it;

            <span class="keyword">if</span> (ch2 == L<span class="string">'('</span>)
            {
                previousWorksLikeIndentifier = <span class="keyword">false</span>;
                <span class="comment">//operator
</span>                stack.push_back(ch);
            }
            <span class="keyword">else</span>
            {
                previousWorksLikeIndentifier = <span class="keyword">true</span>;
                <span class="comment">//identificador
</span>                std::<span class="keyword2">wstring</span> s;
                s = ch;
                result.push_back(s);
            }

            doNext = <span class="keyword">false</span>;
        }
        <span class="keyword">else</span>
        {
            previousWorksLikeIndentifier = <span class="keyword">true</span>;
            <span class="comment">//numero
</span>            std::<span class="keyword2">wstring</span> s;
            s = ch;
            result.push_back(s);
        }

        <span class="keyword">if</span> (doNext)
        {
            it++;
        }

        doNext = <span class="keyword">true</span>;
    }

    <span class="keyword">while</span> (!stack.empty())
    {
        <span class="keyword">wchar_t</span> ch = stack.back();
        Generate(result, ch);
        stack.pop_back();
    };

    <span class="keyword">if</span> (result.empty())
    {
        out = L<span class="string">&quot;&quot;</span>;
    }
    <span class="keyword">else</span>
    {
        out  = result.back();
    }

    <span class="comment">//  result.pop_back();
</span>}


<span class="keyword">void</span> Print(Array&lt;<span class="keyword">wchar_t</span>&gt;&amp; a)
{
    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span> ; r &lt; a.Rows(); r++)
    {
        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span> ; c &lt; a.Cols(); c++)
        {
            std::wcout &lt;&lt; a.At(r, c);
        }

        std::wcout &lt;&lt; std::endl;
    }
}

<span class="keyword">void</span> Print(std::<span class="keyword2">wstring</span>&amp; ws)
{
    std::<span class="keyword2">vector</span>&lt;Array&lt;<span class="keyword">wchar_t</span>&gt;&gt; stack;
    std::<span class="keyword2">wstring</span>::iterator it = ws.begin();

    <span class="keyword">for</span> (; it != ws.end();     it++)
    {
        <span class="keyword">wchar_t</span> ch = *it;

        <span class="keyword">if</span> (ch == L<span class="string">' '</span>)
        {
            <span class="keyword">continue</span>;
        }

        <span class="keyword">if</span> (IsOperator(ch))
        {
            <span class="keyword">if</span> (IsBinaryOperator(ch))
            {
                Array&lt;<span class="keyword">wchar_t</span>&gt; arLeft;
                stack.back().Swap(arLeft);
                stack.pop_back();
                Array&lt;<span class="keyword">wchar_t</span>&gt; arRigh;
                stack.back().Swap(arRigh);
                stack.pop_back();

                <span class="keyword">if</span> (ch == L<span class="string">'+'</span> || ch == L<span class="string">'-'</span> || ch == L<span class="string">'*'</span>)
                {
                    Array&lt;<span class="keyword">wchar_t</span>&gt; r;
                    <span class="keyword">int</span> h = arLeft.Rows() &gt; arRigh.Rows() ? arLeft.Rows() : arRigh.Rows() ;
                    <span class="keyword">int</span> w = arLeft.Cols() + arRigh.Cols() + <span class="number">3</span>; <span class="comment">//&quot; + &quot;
</span>                    r.Resize(w, h);
                    <span class="keyword">int</span> h1 = (h - arLeft.Rows()) / <span class="number">2</span>;
                    <span class="keyword">int</span> h2 = (h - arRigh.Rows()) / <span class="number">2</span>;
                }
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (IsUnary(ch))
            {
            }
        }
        <span class="keyword">else</span>
        {
            Array&lt;<span class="keyword">wchar_t</span>&gt; ar(<span class="number">1</span>, <span class="number">1</span>);
            ar.At(<span class="number">0</span>, <span class="number">0</span>) = ch;
            Print(ar);
            stack.push_back(ar);
        }
    }
}

<span class="keyword">void</span> Test(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* pszIn, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* pszOut)
{
    std::<span class="keyword2">wstring</span> s = pszIn;
    std::<span class="keyword2">wstring</span> out;
    F(s.begin(), s.end(), L<span class="string">''</span>, out);
    assert(out == pszOut);
   <span class="comment">// Print(out);
</span>}

<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    Test(L<span class="string">&quot;&quot;</span>, L<span class="string">&quot;&quot;</span>);
    Test(L<span class="string">&quot;+1&quot;</span>, L<span class="string">&quot;1 P&quot;</span>);
    Test(L<span class="string">&quot;++1&quot;</span>, L<span class="string">&quot;1 P P&quot;</span>);
    Test(L<span class="string">&quot;1&quot;</span>, L<span class="string">&quot;1&quot;</span>);
    Test(L<span class="string">&quot;--1&quot;</span>, L<span class="string">&quot;1 N N&quot;</span>);
    Test(L<span class="string">&quot;(1+2)^3&quot;</span>, L<span class="string">&quot;1 2 + 3 ^&quot;</span>);
    Test(L<span class="string">&quot;(1+2)^(3+4)&quot;</span>, L<span class="string">&quot;1 2 + 3 4 + ^&quot;</span>);
    Test(L<span class="string">&quot;1+2&quot;</span>, L<span class="string">&quot;1 2 +&quot;</span>);
    Test(L<span class="string">&quot;1*-(2+3)&quot;</span>, L<span class="string">&quot;1 2 3 + N *&quot;</span>);
    Test(L<span class="string">&quot;()&quot;</span>, L<span class="string">&quot;&quot;</span>);
    Test(L<span class="string">&quot;-1&quot;</span>, L<span class="string">&quot;1 N&quot;</span>);
    Test(L<span class="string">&quot;-e^(2+1)&quot;</span>, L<span class="string">&quot;e 2 1 + ^ N&quot;</span>);
    Test(L<span class="string">&quot;1+2*3&quot;</span>, L<span class="string">&quot;1 2 3 * +&quot;</span>);
    Test(L<span class="string">&quot;-s(2+1)&quot;</span>, L<span class="string">&quot;2 1 + s N&quot;</span>);
    Test(L<span class="string">&quot;2+6*8^2&quot;</span>, L<span class="string">&quot;2 6 8 2 ^ * +&quot;</span>);
    Test(L<span class="string">&quot;(2+1)*3&quot;</span>, L<span class="string">&quot;2 1 + 3 *&quot;</span>);
    Test(L<span class="string">&quot;3*(2+1)&quot;</span>, L<span class="string">&quot;3 2 1 + *&quot;</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  