<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Local functions && Function literals</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="default.min.css">
    <script src="highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <style>
        /* Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
        }

        body {
            background: white;
            color: black;
            overflow: hidden;
        }

        pre {
            background: #f3f3f3;
            padding: 1em;
            text-align: left;
        }

        /* Slide container */
        .presentation {
            width: 100vw;
            height: 100vh;
            position: relative;
            
        }

        /* Individual slide */
        section {
            width: 100%;
            height: 100%;
            padding: 60px;
            display: none;
            flex-direction: column;
            justify-content: center;
            max-width: 50em;
            margin: auto;
        }

        section.active {
            display: flex;
        }



        /* Titles */
        section h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            text-align: center;
        }

        section h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Text */
        section li {
            font-size: 1.3rem;
            line-height: 1.6;
        }

        ul {
            margin-left: 30px;
        }



        /* Footer */
        .footer {
            position: absolute;
            bottom: 20px;
            right: 30px;
            font-size: 0.9rem;
            opacity: 0.6;
        }

        .note {
            background-color: #ffffff;
            color: #222;
            border: 1px solid #e5e5e5;
            border-left: 4px solid #d0d0d0;

            padding: 8px 10px;
            margin: 8px 0;

            border-radius: 6px;

            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-size: smaller;
            line-height: 1.6;

            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        }


    </style>


</head>

<body>

    <div class="presentation"><!---------------------------------------------------------------------------------------------->
<section>
  <h1>Local functions <br> && <br> Function literals</h1>
  <h3> N3678 and N3679</h3>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Motivation</h2>
<pre><code class="language-c">
void async(void* data, void (*callback)(int result, void* data));

struct start_capture {
   int value;
};

static void start_callback(int result, void* data) {
   struct start_capture* capture = data;
   free(capture);
}

void start() {
   struct start_capture* capture = calloc(1, sizeof *capture);
   async(capture, start_callback);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> do this, then that...</h2>
<pre><code class="language-c" style="font-size:10px">
void part1_async(void* data, void (*callback)(int result, void* data));
void part2_async(void* data, void (*callback)(int result, void* data));

struct part1_capture {
   int value;
};

struct part2_capture {
   char ch;
};

static void part2_complete(int result, void* data);

static void part1_complete(int result, void* data) {
   struct part1_capture* capture1 = data;

   struct part2_capture* capture2 = calloc(1, sizeof *capture2);
   part2_async(capture2, part2_complete);

   free(capture2);
}

static void part2_complete(int result, void* data) {
   struct part2_capture* capture2 = data;
   free(capture2);
}

void start() {
   struct part1_capture* capture1 = calloc(1, sizeof *capture1);
   part1_async(capture1, part1_complete);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Local functions</h2>
<pre><code class="language-c">
void async(void* data, void (*callback)(int result, void* data));

void start() {
       
   struct capture {
      int value;
   };

   static void callback(int result, void* data) {
      struct capture* capture = data;
      free(capture);
   }
       
   struct capture* capture = calloc(1, sizeof * capture);
   async(capture, callback);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Literal functions</h2>
<pre><code class="language-c">
void async(void* data, void (*callback)(int result, void* data));

void start() {
       
   struct capture {
      int value;
   } capture = calloc(1, sizeof * capture);

   async(capture, (void (int result, void* data)) 
   {
      struct capture* capture = data;
      free(capture);
   });
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Reusing captures</h2>
<pre><code class="language-c">
int main()
{
    struct capture { int id; }* capture = calloc(1, sizeof * capture);
    login_async(capture,  (void (int id, void * p))
    {
        printf("login completed. id=%d\n", id);
        struct capture * cap1 = p;
        cap1-&gt;id = id;
        get_data_async(cap1 /*moved*/, (void (const char* email, void * data))
        {
            struct capture * cap2 = data;
            printf("your data='%s'  from id=%d\n", email, cap2-&gt;id);
            free(cap2);
        });
    });
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Captures on Stack</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

void for_each_file(const char* path, 
                   void* data,
                   void (*f)(void* data, const char* filename)){}

int main(){
   
   struct { 
      enum { ALL, SMALL } filter;
      bool more_data;
    } capture = { ALL, false };

   for_each_file("c:", &amp;capture, (void (void* p, const char* file_name)) 
   {
     typeof(capture) * captured = p;
     if (captured-&gt;filter == ALL) {}
   });
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Static captures</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

void for_each_file(const char* path, 
                   void* data,
                   void (*f)(void* data, const char* filename));

int main()
{   
   static int filter = 1;
   for_each_file("c:", 0, (void (void* data, const char* file_name)) 
   {   
       if (filter == 1) {}
   });
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Local function syntax</h2>
<pre>
block-item:
    ...
    <span style="color:blue">function-definition</span>
       
function-definition:
   attribute-specifier-sequence opt declaration-specifiers declarator function-body
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Forward declarations</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   void f();
   f();
   void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> GCC Nested function solution</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   auto void f();
   f();
   /*auto*/ void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code>
</pre>
  <div class="note">See also: N3579 auto as a placeholder type specifier</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> GCC Nested function solution</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
   void f();
   f();
   /*error: static declaration of 'f' follows non-static declaration*/
   void f() { printf("local"); } 
}

void f() { printf("extern"); }
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Alternative I (static)</h2>
<pre><code class="language-c">
void f() { /*extern*/ }

int main() {
   
   /*local functions*/
   static void f(); /*local function declaration*/
   static void f() { }   

   /*GCC nested function*/
   auto int f2();
   int i = 1;              
   int f2() { return i; }
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Alternative II (hybrid)</h2>
<pre><code class="language-c">
void f() { /*extern*/ }

int main() {
   static void f();
   void f() { }
      
   /*static*/ int f1() { return 0; }   

   int i = 1;              
   int f1() { return i; /*GCC extension*/ }   
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Alternative III (same as gcc)</h2>
<pre><code class="language-c">
void f() { /*extern*/ }

int main() {
   auto void f();
   /*auto*/ void f() { }

   auto int f2();
   int i = 1;              
   int f2() { return i; /*GCC extension*/ }   
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Multiple forward declarations/definitions</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main()
{
    int n = 1;
    auto typeof(int [n])* f();
    printf("%zu\n", _Countof(*f())); //1
    
    n = 2;
    auto typeof(int [n])* f();
    printf("%zu\n", _Countof(*f())); //2
    
    n = 3;
    auto typeof(int [n])* f(){
    }
    printf("%zu\n", _Countof(*f())); //3
}
</code>
</pre>
  <p> </p>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> GCC Curiosity I</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main()
{
    auto void local();

    // error: nested function 'local' declared but never defined
    void local() {
        printf("1 ");        
    }

    local();

    auto void local();

}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> GCC Curiosity II</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main()
{
    auto void local();

    void local() { printf("1 "); }

    local(); //prints 2

    auto void local();

    void local() { printf("2 "); }
    local(); //prints 2
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2>  Minimizing problems</h2>
  <ul>
    <li>We cannot have a forward declaration after the definition</li>
    <li>We should have only one forward declaration for each function definition or none</li>
    <li>A local function must have only one definition per scope </li>
  </ul>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Function Literal syntax</h2>
  <p> </p>
<pre>
postfix-expression: 
   ...      
   <span style="color:blue">function-literal-definition</span>
  
<span style="color:blue">function-literal-definition:
   ( attribute-specifier-sequence opt declaration-specifiers abstract-declarator ) 
         function-body</span>       

function-definition:
   attribute-specifier-sequence opt declaration-specifiers declarator function-body
</pre>
  <div class="note">The abstract-declarator portion of a function literal definition must have a function type.</div>
  <div class="note">Extra attribute-specifier-sequence may be necessary for [[unsequenced]] and similar</div>
  <div class="note">Compound literals cannot have a function type.</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Function literal emulation in GCC</h2>
<pre><code class="language-c">
int main() {
    ({int _(int a) { return a * 2; } _;})(2);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Why not C++ lambda syntax?</h2>
  <ul>
    <li>Keeps the grammar for functions and function literals in sync.</li>
    <li>Keeps the existing scope rules for return types and parameters.</li>
    <li>Return type deduction not required.</li>
  </ul>
  <p> </p>
<pre><code class="language-c">
/*   C++   */
int main() {
    //error: return type 'struct main()::X' is incomplete
    [] () -&gt;  struct X { int i; } * { 
        return 0; 
    }();
}
</code>
</pre>
  <div class="note">Return type deduction could be added using auto</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Why not C++ lambda syntax?</h2>
  <ul>
    <li>Fits well with the existing concept of compound literals.</li>
    <li>Do not create the expectation that the C and C++ features are identical.</li>
  </ul>
<pre><code class="language-c">
/*   C   */
int main() {
    (struct X { int i; } *(void)) { 
        return 0; 
    }();
    struct X x;    
}
</code>
</pre>
  <div class="note">This could be necessary for someone using <code>vec(int)</code> with struct tag compatibility.</div>
  <div class="note">It does not create problems that were not considered before.</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Semantics</h2>
  <ul>
    <li>The function literal is a function designator. </li>
  </ul>
<pre><code class="language-c">
void main()
{
    (void (*pf1)(void)) = (void (void)){}; /* ok */
    (void (*pf2)(void)) = &amp;(void (void)){}; /* ok */
    &amp;(void (void)){} = 0;                  /* error: lvalue required */
}
</code>
</pre>
  <div class="note">Behaves like a function, not a function pointer</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> File scope function literals</h2>
<pre><code class="language-c">
auto f = (int (int a)){ return a * 2; }; /* ok */

int main()
{
}
</code>
</pre>
  <div class="note">I don't have a use case for that at the moment.</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Labels</h2>
  <ul>
    <li>Labels are not shared</li>
    <li>Statements are not shared (break; continue)</li>
  </ul>
<pre><code class="language-c">
int main() {
    L1:;
    (void (void)) {    
        goto L1; /* error: label 'L1' used but not defined */
    }();

   void local() {     
       goto L1; /* error: label 'L1' used but not defined */
   };
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Returning VM types</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;
int main() {
    int n = 1;
    auto typeof(int [n])* local(void);

    n = 2;
    typeof(int [n])* local(void) {
       return 0;
    }    
    
    n = 3;
    auto r = local();

    n = 4;
    printf("%zu", _Countof(*r)); //returns 2
}
</code>
</pre>
  <div class="note">Following GCC implementation of nested functions</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Argument evaluation</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int n = 1;

    void local(typeof(int[n])* p) 
    {
         //does it need address of n?
         printf("%zu", _Countof(*p)); 
    }
    n = 2;
    int a[n]; 
    local(&amp;a);

    //void (*pf) (typeof(int[n])* p) = local;
    //pf(&amp;a);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Argument evaluation</h2>
<pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int n = 1;

    void local(int n, typeof(int [n])* a) 
    {
         printf("%zu", _Countof(*a)); //prints 2
    }
    
    int a[2] = {1, 2}; 
    local(2, &amp;a);    
}
</code>
</pre>
  <div class="note">Following GCC implementation of nested functions</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> __func__</h2>
  <ul>
    <li>The value of the string returned by __func__ is implementation-defined.</li>
  </ul>
  <div class="note">GCC returns the function name for nested functions</div>
  <div class="note">C++ returns "operator ()" in lambdas</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Scope</h2>
  <ul>
    <li>Function literals and local functions have access to the enclosing scope at the point of its definition.</li>
  </ul>
<pre><code class="language-c">
int main() {
    
    struct X {int i; };
    enum E {A};

    (void (void)) {    
        struct X x = {}; /* ok */
        x.i = A;         /* ok */
    }();

   void local() {     
     struct X x = {}; /* ok */
     x.i = A;         /* ok */
   };
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Automatic variables</h2>
  <ul>
    <li>Identifiers referring to automatic variables of an enclosing function cannot have their address resolved inside the body of a function literal or local function. <span style="color:gray">If they have VM types, this restriction also apply to resolving their type.</span>  </li>
  </ul>
<pre><code class="language-c">
int main() {    
    int i = 2;
    void local() {    
        int j = sizeof(i); /* ok */
        int  k = i;        /* constraint violation */
        int *p = &amp;i;   /* constraint violation */
    };   
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Automatic variables</h2>
  <ul>
    <li><span style="color:gray">Identifiers referring to automatic variables of an enclosing function cannot have their address resolved inside the body of a function literal or local function. </span> If they have VM types, this restriction also apply to resolving their type. </li>
  </ul>
<pre><code class="language-c">
void start(int n) {
    int a[n];
    void local() {    
        typeof(a) k;       /* constrain violation */
        int m = sizeof(a); /* constrain violation */
    };   
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Constants</h2>
  <ul>
    <li>The same restrictions apply to constants. However their values can be read without accessing memory.</li>
  </ul>
<pre><code class="language-c">
int main() {
   constexpr int a = 1;
   const int b = 2;     /*N3693 Implicitly constexpr*/
   const int j = get();

   void local() {     
     int x = a;   /* ok */             
     int *p = &amp;a; /*constrain violation*/
     
     x = b;       /* ok */             
     p = &amp;b;      /*constrain violation*/

     x = j;       /*constrain violation*/
   };
}
</code>
</pre>
  <div class="note">Originally left as a possible option, it can be included</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Non-automatic variables</h2>
<pre><code class="language-c">
static int g = 1;

int main() {
   static int i = 1;
   
   void local() {     
     int j = sizeof(i); /* ok */
     int k = i;         /* ok */
     int m = g;         /* ok */     
   };
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Generic functions</h2>
<pre><code class="language-c">
#define SWAP(a, b)\
    (void (typeof(a)* arg1, typeof(b)* arg2)) { \
    typeof(a) temp = *arg1; *arg1 = *arg2; *arg2 = temp; \
    }(&amp;(a), &amp;(b))

int main() {
    int a = 1;
    int b = 2;

    SWAP(a, b);
    
    (void (typeof(a)* arg1, typeof(b)* arg2)) { 
        typeof(a) temp = *arg1;
        *arg1 = *arg2; 
        *arg2 = temp; 
    }(&amp;(a), &amp;(b));


    double da = 1.0;
    double db = 2.0;
    SWAP(da, db);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Function Literal address</h2>
  <ul>
    <li>Distinct function literals are not required to have unique addresses.</li>
    <li>Extend this to local functions?</li>
  </ul>
<pre><code class="language-c">
int main(){
    auto pf1 = (void ()) { return 1 + 1; };
    auto pf2 = (void ()) { return 2; };
    auto pf3 = (void ()) { return 2; };
    /* pf1 and pf2 and pf3 can have the same address */
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2>  Static variables inside function literals</h2>
  <ul>
    <li>static variables inside function literals will generate distinct functions</li>
  </ul>
<pre><code class="language-c">
int main() {
    auto pf1 = (void ()) { static int i = 0; };
    auto pf2 = (void ()) { static int i = 0; };
    assert(pf1 != pf2);
}
</code>
</pre>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Key points</h2>
  <ul>
    <li>Almost zero learning curve</li>
    <li>Existing practice</li>
    <li>Does not require trampolines or other hidden features.</li>
    <li>If it looks like a function, then it is a function.</li>
    <li>No forced capture strategy (by reference, by copy, stack, heap, etc.).</li>
    <li>Works with existing APIs that use <code>void *</code> callbacks</li>
    <li>No new problems. Lifetime issues may exist, but they are not new.</li>
    <li>We are adding convenience improving safety and maintainability.</li>
    <li>Keeps the compiler simple</li>
  </ul>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Positive feedback on reddit</h2>
  <div class="note"> Anyone else just want to be able to define anonymous functions/lambdas without capturing data? I feel like for callbacks this would already greatly improve convenience without adding the complexity full blown closures need. If I need to capture some data I'll gladly do it manually through a user pointer.</div>
  <div class="note">This would make some libraries relying on callbacks (like my own sm.h library) way more convenient and tidy to use. </div>
  <div class="note"> it really does match what I've been hoping for for a while! I think it's a very intuitive approach that really does not change the nature of the language at all while adding a lot of convenience. </div>
  <div class="note">This is exactly what most C community wants. Provide some convenient syntax for functions which usage is very localized and delegate all issues with passing captures and ensuring their lifetime are delegated to the programmer. </div>
  <div class="note">Lambdas with no captures would be a simple and very convenient addition to C. It's quite frustrating that this feature did not land in C23. </div>
  <div class="note">Keep the language small and simple. Keep the spirit of C.</div>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> Road map</h2>
  <ul>
    <li> Improving the proposal, add wording maybe merge in one proposal?</li>
    <li> Deciding on forward-declaration syntax</li>
    <li> Experimental implementation http://cakecc.org/ (missing VM types)</li>
  </ul>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h2> References</h2>
  <ul>
    <li>   N3724: Discarded</li>
    <li>   N3622 Allow calling static inline within extern inline</li>
    <li>   N3579: auto as a placeholder type specifier</li>
    <li>   N2956: Unsequenced functions </li>
    <li>   N3693: Integer Constant Expression</li>
    <li>   N3694: Functions with Data </li>
    <li>   N3654: Accessing the Context of Nested Functions</li>
    <li>   Reddit: https://www.reddit.com/r/C_Programming/comments/1omrrra/closures_in_c_yes/</li>
    <li>   http://cakecc.org/</li>
  </ul>
</section>
<!---------------------------------------------------------------------------------------------->
<section>
  <h1>Thank You</h1>
  <p>Press ← → or Space to navigate.</p>
</section>



        <div class="footer">Slide N/N</div>
    </div>

    <script>
        const start_time = Date.now();
        const slides = document.querySelectorAll("section");
        let currentSlide = 0;

        function showSlide(index)
        {

            const end_time = Date.now();
            const duration_minutes = Math.round((end_time - start_time) / 60000);
            const total = slides.length;
            var footer = document.querySelector(".footer");
            if (footer)
            {
                footer.textContent = `Slide ${index + 1} / ${total}`;
            }

            slides.forEach((slide, i) =>
            {
                slide.classList.remove("active");
            });

            slides[index].classList.add("active");
        }
        function nextSlide()
        {
            currentSlide = Math.min(currentSlide + 1, slides.length - 1);
            showSlide(currentSlide);

        }
        function previousSlide()
        {
            currentSlide = Math.max(currentSlide - 1, 0);
            showSlide(currentSlide);

        }

        function handleInput(x)
        {
            const width = window.innerWidth;

            if (x < width / 2)
            {
                previousSlide();
            } else
            {
                nextSlide();
            }
        }

        // Mouse click
        document.addEventListener("click", (e) =>
        {
            handleInput(e.clientX);
        });

        // Touch
        document.addEventListener("touchstart", (e) =>
        {
            if (e.touches.length > 0)
            {
                handleInput(e.touches[0].clientX);
            }
        });

        document.addEventListener("keydown", (e) =>
        {
            if (e.key === "ArrowRight" || e.key === " ")
            {
                nextSlide();
            }

            if (e.key === "ArrowLeft")
            {
                previousSlide();
            }
        });

        // Initialize first slide
        showSlide(currentSlide);
    </script>
</body>

</html>