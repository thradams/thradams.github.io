
[[tklgen.htm|TKLGEN HOME]]

==Tutorial and sample==

This sample parse expressions.

This **is not the tklgen grammar** but it helps to think how to build LL1 grammars.


The brackets [ and ] enclose an optional part of the production. 
The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. 
The unquoted parentheses ( and ) serve only to group elements in a production.)

{{{
  E --> T {( "+" | "-" ) T}
  T --> F {( "*" | "/" ) F}
  F --> P ["^" F]
  P --> v | "(" E ")" | "-" T
}}}


Now lets see how to build a tklgen LL1 grammar:

===grammar.txt===

{{{cpp

module Sample2
{
  language Sample2
   {
    token Plus = '+';
    token Minus = '-';
    token Multi = '*';
    token Div = '/';
    token Power = '^';
    token Open = '(';
    token Close = ')';
    token End = ';';
    token EndMark = '\0';
    token Integer   = ('0'..'9')+;
    token Identifier   = ('a'..'z' | 'A'..'Z' | '_' | '$') +
                       ('0'..'9' + ('a'..'z' | 'A'..'Z' | '_' | '$') +) ?;
    
    interleave Blanks  = (" " | "\n" | "\t" | "\r") +;

    
    syntax Main = Expressions;
    syntax Expression = E ';' {PrintNewLine};
    syntax Expressions = Expression Expressions | empty;

    // E --> T {( "+" | "-" ) T}
    syntax E = T E2;
    syntax E2 = '+' T {PrintPlus} E2 |
                '-' T {PrintMinus} E2 |
                empty;

    // T --> F {( "*" | "/" ) F}
    syntax T = F T2;
    syntax T2 = '*' F {PrintMulti} T2|
                '/' F {PrintDiv}T2|
                empty;

    // F --> P ["^" F]
    syntax F = P FOpt;
    syntax FOpt = '^' F {PrintPower} | empty;

    // P --> v | "(" E ")" | "-" T
    syntax P = {PrintLexeme} Integer |
               {PrintLexeme} Identifier | 
               '(' E ')' | 
               '-' T {PrintNeg};
      }
}

}}}

Use this command line:

{{{
 tklgen grammar.txt
}}}

The files below will be generated:

{{{
 Sample2Parser.h
 Sample2Parser.cpp
 Sample2DFA.h
}}}


The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.

{{{
Tokenizer.h
FileStream.h
StringStream.h
SampleProgram.txt
}}}


===Sample2Parser.h===

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "Sample2DFA.h"

//Select the input stream type
#include "FileStream.h"
//#include "StringStream.h"
//#include "YourStream.h"


namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    
    };


    class ParserException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ErrorCode m_Error;
        ParserException(int line,
                        int col,
                        ErrorCode error)
            : m_Line(line)
            , m_Col(col)
            , m_Error(error)
    {
    }
    };


    class Context
    {
        public:
        //Select
        typedef FileStream   InputStream;
        //typedef StringStream InputStream;
        //typedef YourStream   InputStream;
        
        typedef Tokenizer<Sample2::DFA, InputStream> Scanner;
        
        private:
        Scanner& m_scanner;
        
        Sample2::Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
    public:
        Context(Scanner& s) : m_scanner(s)
        {
            if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
            {
                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);
            }
        }

        //returns the current token
        Sample2::Tokens Token() const
        {
             return m_CurrentToken;
        }
        
        //checks if Token() == tk and then move the current token
        void Match(Sample2::Tokens tk)
        {
             if (tk != m_CurrentToken)
             {
                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);
             }
             if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
             {
             }
        }
        
        int GetLine() const
        {
            return m_scanner.m_InputStream.GetLine();
        }
        
        int GetCol() const
        {
            return m_scanner.m_InputStream.GetCol();
        }
        void Action_PrintNewLine() {}
        void Action_PrintPlus() {}
        void Action_PrintMinus() {}
        void Action_PrintMulti() {}
        void Action_PrintDiv() {}
        void Action_PrintPower() {}
        void Action_PrintLexeme() {}
        void Action_PrintNeg() {}
    };
    


    void Parse_Main(Context&);
} //namespace


}}}

===Sample2Parser.cpp===

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "Sample2DFA.h"
#include "Sample2Parser.h"


namespace Sample2
{
    //forward declarations 
    void Parse_Main(Context&);
    void Parse_Expressions(Context&);
    void Parse_Expression(Context&);
    void Parse_E(Context&);
    void Parse_T(Context&);
    void Parse_E2(Context&);
    void Parse_F(Context&);
    void Parse_T2(Context&);
    void Parse_P(Context&);
    void Parse_FOpt(Context&);


    void Parse_Main(Context& ctx)
    {
        if (ctx.Token() == TKEndMark ||
            ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //Main => Expressions 
            Parse_Expressions(ctx);
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expressions(Context& ctx)
    {
        if (ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //Expressions => Expression Expressions 
            Parse_Expression(ctx);
            Parse_Expressions(ctx);
        }
        else if (ctx.Token() == TKEndMark)
        {
            //Expressions => Epsilon 
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expression(Context& ctx)
    {
        if (ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //Expression => E End 
            Parse_E(ctx);
            ctx.Match(TKEnd);
            ctx.Action_PrintNewLine();
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E(Context& ctx)
    {
        if (ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //E => T E2 
            Parse_T(ctx);
            Parse_E2(ctx);
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T(Context& ctx)
    {
        if (ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //T => F T2 
            Parse_F(ctx);
            Parse_T2(ctx);
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E2(Context& ctx)
    {
        if (ctx.Token() == TKPlus)
        {
            //E2 => Plus T E2 
            ctx.Match(TKPlus);
            Parse_T(ctx);
            ctx.Action_PrintPlus();
            Parse_E2(ctx);
        }
        else if (ctx.Token() == TKMinus)
        {
            //E2 => Minus T E2 
            ctx.Match(TKMinus);
            Parse_T(ctx);
            ctx.Action_PrintMinus();
            Parse_E2(ctx);
        }
        else if (ctx.Token() == TKClose ||
            ctx.Token() == TKEnd)
        {
            //E2 => Epsilon 
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_F(Context& ctx)
    {
        if (ctx.Token() == TKMinus ||
            ctx.Token() == TKOpen ||
            ctx.Token() == TKInteger ||
            ctx.Token() == TKIdentifier)
        {
            //F => P FOpt 
            Parse_P(ctx);
            Parse_FOpt(ctx);
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T2(Context& ctx)
    {
        if (ctx.Token() == TKMulti)
        {
            //T2 => Multi F T2 
            ctx.Match(TKMulti);
            Parse_F(ctx);
            ctx.Action_PrintMulti();
            Parse_T2(ctx);
        }
        else if (ctx.Token() == TKDiv)
        {
            //T2 => Div F T2 
            ctx.Match(TKDiv);
            Parse_F(ctx);
            ctx.Action_PrintDiv();
            Parse_T2(ctx);
        }
        else if (ctx.Token() == TKPlus ||
            ctx.Token() == TKMulti ||
            ctx.Token() == TKMinus ||
            ctx.Token() == TKDiv ||
            ctx.Token() == TKPower ||
            ctx.Token() == TKClose ||
            ctx.Token() == TKEnd)
        {
            //T2 => Epsilon 
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_P(Context& ctx)
    {
        if (ctx.Token() == TKInteger)
        {
            //P => Integer 
            ctx.Action_PrintLexeme();
            ctx.Match(TKInteger);
        }
        else if (ctx.Token() == TKIdentifier)
        {
            //P => Identifier 
            ctx.Action_PrintLexeme();
            ctx.Match(TKIdentifier);
        }
        else if (ctx.Token() == TKOpen)
        {
            //P => Open E Close 
            ctx.Match(TKOpen);
            Parse_E(ctx);
            ctx.Match(TKClose);
        }
        else if (ctx.Token() == TKMinus)
        {
            //P => Minus T 
            ctx.Match(TKMinus);
            Parse_T(ctx);
            ctx.Action_PrintNeg();
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

    void Parse_FOpt(Context& ctx)
    {
        if (ctx.Token() == TKPower)
        {
            //FOpt => Power F 
            ctx.Match(TKPower);
            Parse_F(ctx);
            ctx.Action_PrintPower();
        }
        else if (ctx.Token() == TKPlus ||
            ctx.Token() == TKMulti ||
            ctx.Token() == TKMinus ||
            ctx.Token() == TKDiv ||
            ctx.Token() == TKPower ||
            ctx.Token() == TKClose ||
            ctx.Token() == TKEnd)
        {
            //FOpt => Epsilon 
        }
        else
        {
            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
        }
    }

} //namespace Sample2

}}}

===Sample2DFA.h===

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef __SAMPLE2DFA_H__
#define __SAMPLE2DFA_H__

namespace Sample2
{

enum Tokens
{
    TKPlus,
    TKMinus,
    TKMulti,
    TKDiv,
    TKPower,
    TKOpen,
    TKClose,
    TKEnd,
    TKEndMark,
    TKInteger,
    TKIdentifier,
    TKBlanks,
};

inline const wchar_t* TokensToString(Tokens e)
{
    switch(e)
    {
    case TKPlus: return L"Plus";
    case TKMinus: return L"Minus";
    case TKMulti: return L"Multi";
    case TKDiv: return L"Div";
    case TKPower: return L"Power";
    case TKOpen: return L"Open";
    case TKClose: return L"Close";
    case TKEnd: return L"End";
    case TKEndMark: return L"EndMark";
    case TKInteger: return L"Integer";
    case TKIdentifier: return L"Identifier";
    case TKBlanks: return L"Blanks";
    default:break;
    }
    return L"";
}

struct DFA
{
    typedef Tokens TokenType;

    static int GetNext(int state, wchar_t ch)
    {
        switch (state)
        {
            case 0:
            if (ch == L'\0')
                return 1;
        else if (ch >= L'\t' && ch <= L'\n')
          return 2;
            else if (ch == L'\r')
                return 2;
            else if (ch == L' ')
                return 2;
            else if (ch == L'$')
                return 3;
            else if (ch == L'(')
                return 4;
            else if (ch == L')')
                return 5;
            else if (ch == L'*')
                return 6;
            else if (ch == L'+')
                return 7;
            else if (ch == L'-')
                return 8;
            else if (ch == L'/')
                return 9;
        else if (ch >= L'0' && ch <= L'9')
          return 10;
            else if (ch == L';')
                return 11;
        else if (ch >= L'A' && ch <= L'Z')
          return 3;
            else if (ch == L'^')
                return 12;
            else if (ch == L'_')
                return 3;
        else if (ch >= L'a' && ch <= L'z')
           return 3;
    break; // 
            case 1:
        //TKEndMark
    break; // 
            case 2:
        if (ch >= L'\t' && ch <= L'\n')
          return 2;
            else if (ch == L'\r')
                return 2;
            else if (ch == L' ')
                return 2;
        //TKBlanks
    break; // 
            case 3:
            if (ch == L'$')
                return 3;
        else if (ch >= L'0' && ch <= L'9')
          return 14;
        else if (ch >= L'A' && ch <= L'Z')
          return 3;
            else if (ch == L'_')
                return 3;
        else if (ch >= L'a' && ch <= L'z')
          return 3;
        //TKIdentifier
    break; // 
            case 4:
        //TKOpen
   
}}}



===Tokenizer (do not depend on grammar)===

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - VersionMar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////


#pragma once

template < class TDFA,
         class TInputStream >
struct Tokenizer
{
public:
    typedef TInputStream             InputStream;
    typedef typename TDFA::TokenType TokenType;

private:

  
    Tokenizer& operator=(const Tokenizer&); //= deleted

    template<class T>
    bool NextTokenNoInterleave(T& lexeme, TokenType& tk)
    {
        lexeme.clear();
        int lastGoodState = -1;
        int currentState = 0;
        wchar_t ch;

        while (m_InputStream.NextChar(ch))
        {
            currentState = TDFA::GetNext(currentState, ch);

            if (currentState == -1)
            {
                m_InputStream.PutBack(ch);
                break;
            }

            TokenType tk2;

            if (TDFA::GetTokenFromState(currentState, tk2))
            {
                tk = tk2;
                lastGoodState = currentState;
            }

            lexeme.append(1, ch);
        }

        return (lastGoodState != -1);
    }


public:

    InputStream& m_InputStream;

    Tokenizer(InputStream& stream)
        : m_InputStream(stream)
    {
    }

    template<class T>
    bool NextToken(T& lexeme, TokenType& tk)
    {
        for (;;)
        {
            if (!NextTokenNoInterleave(lexeme, tk))
            {
                return false;
            }

            if (!TDFA::IsInterleave(tk))
            {
                return true;
            }
        }
    }
};


}}}

===FileStream (do not depend on grammar)==

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - VersionMar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////


#pragma once

#include <cstdio>
#include <cassert>

struct FileStream
{
  typedef const wchar_t* BufferIterator;

  wchar_t*     m_pCharacteres;
  const size_t m_MaxBufferSize;
  wchar_t*     m_pCurrentChar;
  FILE*        m_hFile;
  size_t       m_CurrentLine;
  size_t       m_CurrentCol;

  bool         m_HasPutBack;
  wchar_t      m_PutBackCharacter;

  bool         m_EofSent;

  BufferIterator FirstBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize - 1;
  }

  BufferIterator SecondBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize * 2 - 1;
  }

  bool NextCharCore(wchar_t& ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L'\0')
    {
      ch = '\0';
      m_EofSent = true;
    }
    else
    {
      if (*m_pCurrentChar == L'\0')
      {
        if (m_pCurrentChar == FirstBufferEnd())
        {
          wchar_t* pSecondBuffer =
            m_pCharacteres + m_MaxBufferSize;

          size_t r = fread(pSecondBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);
          pSecondBuffer[r] = 0;
          m_pCurrentChar = pSecondBuffer;
        }
        else if (m_pCurrentChar == SecondBufferEnd())
        {
          wchar_t* pFirstBuffer = m_pCharacteres;

          size_t r = fread(pFirstBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);

          pFirstBuffer[r] = 0;
          m_pCurrentChar = pFirstBuffer;
        }
      }
    }

    assert(m_pCharacteres[m_MaxBufferSize - 1] == 0);
    assert(m_pCharacteres[m_MaxBufferSize * 2 - 1] == 0);
    return true;
  }

public:

  FileStream(const wchar_t* fileName, size_t bufferSize = 4096)
    : m_MaxBufferSize(bufferSize)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L'\0')
    , m_EofSent(false)
  {
    assert(bufferSize >= 2);

    //allocate 2 buffers
    m_pCharacteres = new wchar_t[m_MaxBufferSize * 2];
    m_pCharacteres[m_MaxBufferSize * 2 - 1] = 0;
    m_pCharacteres[m_MaxBufferSize - 1] = 0;
    m_pCurrentChar = m_pCharacteres;

    errno_t err = _wfopen_s(&m_hFile, fileName, L"r,ccs=UTF-8");

    if (err == 0)
    {
      size_t r = fread(m_pCharacteres,
                       sizeof(wchar_t),
                       m_MaxBufferSize - 1,
                       m_hFile);

      m_pCharacteres[r] = L'\0';
    }
  }

  ~FileStream()
  {
    fclose(m_hFile);
    delete [] m_pCharacteres;
  }

  void PutBack(wchar_t ch)
  {
    assert(m_HasPutBack == false);

    if (ch == L'\n')
    {
      if (m_CurrentLine > 1)
      {
        m_CurrentLine--;
      }
    }
    else
    {
      if (m_CurrentCol > 1)
      {
        m_CurrentCol--;
      }
    }

    m_PutBackCharacter = ch;
    m_HasPutBack = true;
  }

  bool NextChar(wchar_t& ch)
  {
    bool b = NextCharCore(ch);

    if (b && ch == L'\n')
    {
      m_CurrentLine++;
      m_CurrentCol = 1;
    }
    else
    {
      m_CurrentCol++;
    }

    return b;
  }

  size_t GetLine() const
  {
    return m_CurrentLine;
  }

  size_t GetCol() const
  {
    return m_CurrentCol;
  }
};

}}}

===StringStream (do not depend on grammar) ===

{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

struct StringStream
{
  const wchar_t* m_pCharacteres;
  const wchar_t* m_pCurrentChar;
  size_t         m_CurrentLine;
  size_t         m_CurrentCol;
  bool           m_HasPutBack;
  wchar_t        m_PutBackCharacter;
  bool           m_EofSent;

  bool NextCharCore(wchar_t& ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L'\0')
    {
      ch = '\0';
      m_EofSent = true;
    }

    return true;
  }

public:

  StringStream(const wchar_t* psz)
    : m_pCharacteres(psz)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L'\0')
    , m_EofSent(false)
  {
    m_pCurrentChar = m_pCharacteres;
  }

  void PutBack(wchar_t ch)
  {
    assert(m_HasPutBack == false);

    if (ch == L'\n')
    {
      if (m_CurrentLine > 1)
      {
        m_CurrentLine--;
      }
    }
    else
    {
      if (m_CurrentCol > 1)
      {
        m_CurrentCol--;
      }
    }

    m_PutBackCharacter = ch;
    m_HasPutBack = true;
  }

  bool NextChar(wchar_t& ch)
  {
    bool b = NextCharCore(ch);

    if (b && ch == L'\n')
    {
      m_CurrentLine++;
      m_CurrentCol = 1;
    }
    else
    {
      m_CurrentCol++;
    }

    return b;
  }

  size_t GetLine() const
  {
    return m_CurrentLine;
  }

  size_t GetCol() const
  {
    return m_CurrentCol;
  }
};
}}}


===SampleProgram.txt (just a sample)===


{{{cpp

#include "stdafx.h"
#include "GrammarFileParser.h"
#include <iostream>

int _tmain(int argc, _TCHAR* argv[])
{
  if (argc == 1)
  {
    std::cout << "missing input file ";
    return 1;
  }

  try
  {
    Grammar::Context::InputStream ss(argv[1]);
    Grammar::Context::Scanner scanner(ss);
    Grammar::Context ctx(scanner);
    Grammar::Parse_Main(ctx);
  }
  catch (const Grammar::ParserException& e)
  {
    std::cout << "Error : line, col = " << e.m_Line << ", " << e.m_Col << std::endl;
  }
  catch (const std::exception& e)
  {
    std::cout << e.what() << std::endl;
  }

  return 0;
}

}}}


===Modifed SampleParser.h===


{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "Sample2DFA.h"

//Select the input stream type
#include "FileStream.h"
//#include "StringStream.h"
//#include "YourStream.h"


namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    
    };


    class ParserException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ErrorCode m_Error;
        ParserException(int line,
                        int col,
                        ErrorCode error)
            : m_Line(line)
            , m_Col(col)
            , m_Error(error)
    {
    }
    };


    class Context
    {
        public:
        //Select
        typedef FileStream   InputStream;
        //typedef StringStream InputStream;
        //typedef YourStream   InputStream;
        
        typedef Tokenizer<Sample2::DFA, InputStream> Scanner;
        
        private:
        Scanner& m_scanner;
        
        Sample2::Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
    public:
        Context(Scanner& s) : m_scanner(s)
        {
            if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
            {
                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);
            }
        }

        //returns the current token
        Sample2::Tokens Token() const
        {
             return m_CurrentToken;
        }
        
        //checks if Token() == tk and then move the current token
        void Match(Sample2::Tokens tk)
        {
             if (tk != m_CurrentToken)
             {
                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);
             }
             if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
             {
             }
        }
        
        int GetLine() const
        {
            return m_scanner.m_InputStream.GetLine();
        }
        
        int GetCol() const
        {
            return m_scanner.m_InputStream.GetCol();
        }

    void Action_PrintPlus()
    {
      wcout << L" +";
    }
    void Action_PrintMinus()
    {
      wcout << L" -";
    }
    void Action_PrintMulti()
    {
      wcout << L" *";
    }
    void Action_PrintDiv()
    {
      wcout << L" /";
    }
    void Action_PrintPower()
    {
      wcout << L" ^";
    }
    void Action_PrintLexeme()
    {
      wcout << L" " << m_lexeme;
    }
    void Action_PrintNeg()
    {
      wcout << L" NEG";
    }
    void Action_PrintNewLine()
    {
        wcout << std::endl;
    }
    };
    


    void Parse_Main(Context&);
} //namespace


}}}

