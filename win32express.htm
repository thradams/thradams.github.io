
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<p>Micro framework to generate win32 applications.</p>



<p>Sample:</p>

<pre>

<span class="comment">// Windows Header Files:
</span><span class="keyword">#include</span> &lt;windows.h&gt;

<span class="comment">// C RunTime Header Files
</span><span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> &lt;malloc.h&gt;
<span class="keyword">#include</span> &lt;memory.h&gt;
<span class="keyword">#include</span> &lt;tchar.h&gt;

<span class="keyword">#include</span> <span class="string">&quot;win32express.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;resource.h&quot;</span>


<span class="keyword">class</span> AboutDlg : <span class="keyword">public</span> Dialog&lt;AboutDlg, IDD_ABOUT&gt;
{
  <span class="keyword">void</span> About()
  {  
  }

  <span class="keyword">void</span> OnClose()
  {
    EndDialog(IDCANCEL);
  }

  <span class="keyword">void</span> OnOk()
  {
    EndDialog(IDCANCEL);
    PostQuitMessage(<span class="number">1</span>);
  }  

<span class="keyword">public</span>:

  BEGIN_MSG_MAP(AboutDlg)
  S_COMMAND_ID_HANDLER(IDCANCEL, OnClose)  
  S_COMMAND_ID_HANDLER(IDOK, OnOk)  
  S_COMMAND_ID_HANDLER(IDM_ABOUT1, About)
  END_MSG_MAP()

  AboutDlg(HWND hParent = NULL) : Dialog&lt;AboutDlg, IDD_ABOUT&gt;(hParent) 
  {
  }
  
    <span class="keyword">void</span> OnPaint(HDC hdc)
    {
        ::TextOut(hdc, <span class="number">10</span>,<span class="number">10</span>,L<span class="string">&quot;hello&quot;</span>, <span class="number">6</span>);
    }
};


<span class="keyword">class</span> Doc : <span class="keyword">public</span> Window&lt;Doc, IDI_ICON1, IDR_MENU1&gt;
{
  <span class="keyword">void</span> Exit()
  {
    DestroyWindow(m_hWnd);
    PostQuitMessage(<span class="number">0</span>);
  }

  <span class="keyword">void</span> About()
  {
    AboutDlg dlg(m_hWnd);
    dlg.ShowDialog();
  }

<span class="keyword">public</span>:

  BEGIN_MSG_MAP(AboutDlg)
  S_COMMAND_ID_HANDLER(IDM_ABOUT1, About)
  S_COMMAND_ID_HANDLER(IDM_EXIT1, Exit)
  END_MSG_MAP()

  <span class="keyword">void</span> OnPaint(HDC hdc)
    {
        ::TextOut(hdc, <span class="number">10</span>,<span class="number">10</span>,L<span class="string">&quot;hello&quot;</span>, <span class="number">6</span>);
    }
};

<span class="keyword">int</span> APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR    lpCmdLine,
                     <span class="keyword">int</span>       nCmdShow)
 {

   Doc doc;
   doc.Create();
   
    <span class="keyword">return</span> RunMessageLoop();
 }

Header file


<span class="comment">// Copyright (C) 2010, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span>
<span class="comment">//This is a experimental code.
</span>

<span class="keyword">#pragma</span> once

<span class="keyword">#include</span> &lt;windows.h&gt;
<span class="keyword">#include</span> &lt;commctrl.h&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;
<span class="keyword">#ifndef</span> ASSERT
<span class="keyword">#include</span> &lt;cassert&gt;
<span class="keyword">#define</span> ASSERT assert
<span class="keyword">#endif</span>
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>.h&gt;

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
T* GetWindowDocument(HWND hWnd)
{
  T *pDoc = <span class="keyword">reinterpret_cast</span>&lt;T *&gt;(<span class="keyword">static_cast</span>&lt;LONG_PTR&gt;(
    ::GetWindowLongPtrW(hWnd, GWLP_USERDATA)));
  <span class="keyword">return</span> pDoc;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
T* SetWindowDocument(HWND hWnd, T* pReceiver)
{
  LONG_PTR lptr = ::SetWindowLongPtrW(
    hWnd,
    GWLP_USERDATA,
    PtrToUlong(pReceiver));
  T *pOldDoc = (T*)(LONG_PTR)(lptr);
  <span class="keyword">return</span> pOldDoc;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
LRESULT CALLBACK WindowsProcEx(HWND hWnd,
  UINT message,
  WPARAM wParam,
  LPARAM lParam)
{
  T* pDoc = GetWindowDocument&lt;T&gt;(hWnd);
  BOOL bHandled = <span class="keyword">false</span>;
  LRESULT r = Details::SendMessageTo(pDoc, hWnd , message, wParam, lParam, bHandled);
  <span class="keyword">if</span> (bHandled)
  {
    <span class="keyword">return</span> r;
  }
  <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);  
}


<span class="keyword">inline</span> <span class="keyword">bool</span> IsControlKeyPressed()
{
  <span class="keyword">return</span> (GetKeyState(VK_CONTROL) &amp; <span class="number">0</span>xf000) == <span class="number">0</span>xf000;
}

<span class="keyword">inline</span> <span class="keyword">bool</span> IsShiftKeyPressed()
{
  <span class="keyword">return</span> (GetKeyState(VK_SHIFT) &amp; <span class="number">0</span>xf000) == <span class="number">0</span>xf000;
}

<span class="keyword">#ifndef</span> GET_X_LPARAM
<span class="keyword">#define</span> GET_X_LPARAM(lParam)    ((<span class="keyword">int</span>)(<span class="keyword">short</span>)LOWORD(lParam))
<span class="keyword">#endif</span>
<span class="keyword">#ifndef</span> GET_Y_LPARAM
<span class="keyword">#define</span> GET_Y_LPARAM(lParam)    ((<span class="keyword">int</span>)(<span class="keyword">short</span>)HIWORD(lParam))
<span class="keyword">#endif</span>

<span class="keyword">namespace</span> Details
{
  <span class="keyword">class</span> MemoryDC
  {
  <span class="keyword">public</span>:
    HDC m_hDC;
    HDC m_hDCOriginal;
    RECT m_rcPaint;
    HBITMAP m_hBitmap;
    HBITMAP m_hBmpOld;

    MemoryDC(HDC hDC, RECT&amp; rcPaint) : m_hDCOriginal(hDC), m_hBmpOld(NULL)
    {
      m_rcPaint = rcPaint;
      m_hDC = ::CreateCompatibleDC(m_hDCOriginal);
      ASSERT(m_hDC != NULL);
      m_hBitmap = ::CreateCompatibleBitmap(m_hDCOriginal,
        m_rcPaint.right - m_rcPaint.left, m_rcPaint.bottom - m_rcPaint.top);
      ASSERT(m_hBitmap != NULL);
      m_hBmpOld = (HBITMAP)::SelectObject(m_hDC, m_hBitmap);
      ::SetViewportOrgEx(m_hDC, -m_rcPaint.left, -m_rcPaint.top, <span class="number">0</span>);
    }

    ~MemoryDC()
    {
      ::BitBlt(m_hDCOriginal, m_rcPaint.left, m_rcPaint.top,
        m_rcPaint.right - m_rcPaint.left, m_rcPaint.bottom - m_rcPaint.top,
        m_hDC, m_rcPaint.left, m_rcPaint.top, SRCCOPY);
      (HBITMAP)::SelectObject(m_hDC, m_hBmpOld);
      ::DeleteObject(m_hBitmap);
      ::DeleteObject(m_hDC);
    }
  };


  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TEventReceiver&gt;
  LRESULT SendMessageTo(TEventReceiver* pEventReceiver,
    HWND hWnd,
    UINT uMsg,
    WPARAM wparam,
    LPARAM lparam,
    BOOL&amp; bHandled)
  {
    bHandled = FALSE;
    <span class="keyword">if</span> (pEventReceiver == NULL)
    {
      <span class="keyword">return</span> FALSE;
    }
    bHandled = TRUE;
    <span class="keyword">switch</span> (uMsg)
    {

      <span class="comment">//notifications
</span>    <span class="keyword">case</span> WM_COMMAND:
    <span class="keyword">case</span> WM_NOTIFY:
      {
        LRESULT lresult;
        pEventReceiver-&gt;ProcessWindowMessage(hWnd, uMsg, wparam, lparam, lresult);
      }
      <span class="keyword">break</span>;

      __if_exists(TEventReceiver::OnDeactivate)
      {
    <span class="keyword">case</span> WM_ACTIVATE:
      {
        <span class="keyword">if</span> (LOWORD(wparam) == WA_INACTIVE)
        {
          pEventReceiver-&gt;OnDeactivate();
        }
        <span class="keyword">break</span>;
      }
      } <span class="comment">//OnDeactivate
</span>
<span class="keyword">#ifndef</span> _WIN32_WCE
      __if_exists(TEventReceiver::OnMouseWheel)
      {
    <span class="keyword">case</span> WM_MOUSEWHEEL:
      {
        <span class="keyword">int</span> fwKeys = GET_KEYSTATE_WPARAM(wparam );
        <span class="keyword">short</span> zDelta = GET_WHEEL_DELTA_WPARAM(wparam );                
        pEventReceiver-&gt;OnMouseWheel(fwKeys, zDelta);
      }
      <span class="keyword">break</span>;
      }<span class="comment">//OnMouseWheel
</span><span class="keyword">#endif</span>
      __if_exists(TEventReceiver::OnSetFocus)
      {
    <span class="keyword">case</span> WM_SETFOCUS:
      {
        pEventReceiver-&gt;OnSetFocus();
      }            
      <span class="keyword">break</span>;
      }

      __if_exists(TEventReceiver::OnSetCursor)
      {
    <span class="keyword">case</span> WM_SETCURSOR:
      {
        <span class="keyword">if</span> (!pEventReceiver-&gt;OnSetCursor())
        {
          bHandled = FALSE;
        }
      }            
      <span class="keyword">break</span>;
      }

      __if_exists (TEventReceiver::OnKillFocus)
      {
    <span class="keyword">case</span> WM_KILLFOCUS:
      {
        pEventReceiver-&gt;OnKillFocus();
      }            
      <span class="keyword">break</span>;
      }<span class="comment">//OnKillFocus
</span>
      __if_exists (TEventReceiver::OnPaint)
      {
    <span class="keyword">case</span> WM_PAINT:
      {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint(hWnd, &amp;ps);
        pEventReceiver-&gt;OnPaint(hDC);
        EndPaint(hWnd, &amp;ps);
      }
      <span class="keyword">break</span>;
      }

    <span class="keyword">default</span>:
      bHandled = FALSE;
      <span class="keyword">return</span> FALSE;
    }
    <span class="keyword">return</span> TRUE;
  }
} <span class="comment">//namespace details
</span>
<span class="keyword">int</span> RunMessageLoop()
{
  MSG msg;
  <span class="keyword">while</span> (GetMessage(&amp;msg, NULL, <span class="number">0</span>, <span class="number">0</span>))
  {
    DispatchMessage(&amp;msg);
  }
  <span class="keyword">return</span> (<span class="keyword">int</span>) msg.wParam;
}

DWORD GetStyle(HWND m_hWnd)
{
  ASSERT(::IsWindow(m_hWnd));
  <span class="keyword">return</span> (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
}

BOOL CenterWindow(HWND m_hWnd, HWND hWndCenter = NULL)
{
  ASSERT(::IsWindow(m_hWnd));

  <span class="comment">// determine owner window to center against
</span>  DWORD dwStyle = GetStyle(m_hWnd);
  <span class="keyword">if</span>(hWndCenter == NULL)
  {
    <span class="keyword">if</span>(dwStyle &amp; WS_CHILD)
      hWndCenter = ::GetParent(m_hWnd);
    <span class="keyword">else</span>
      hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
  }

  <span class="comment">// get coordinates of the window relative to its parent
</span>  RECT rcDlg;
  ::GetWindowRect(m_hWnd, &amp;rcDlg);
  RECT rcArea;
  RECT rcCenter;
  HWND hWndParent;
  <span class="keyword">if</span>(!(dwStyle &amp; WS_CHILD))
  {
    <span class="comment">// don't center against invisible or minimized windows
</span>    <span class="keyword">if</span>(hWndCenter != NULL)
    {
      DWORD dwStyleCenter = ::GetWindowLong(hWndCenter, GWL_STYLE);
      <span class="keyword">if</span>(!(dwStyleCenter &amp; WS_VISIBLE) || (dwStyleCenter &amp; WS_MINIMIZE))
        hWndCenter = NULL;
    }

    <span class="comment">// center within screen coordinates
</span><span class="keyword">#if</span> WINVER &lt; <span class="number">0</span>x0500
    ::SystemParametersInfo(SPI_GETWORKAREA, NULL, &amp;rcArea, NULL);
<span class="keyword">#else</span>
    HMONITOR hMonitor = NULL;
    <span class="keyword">if</span>(hWndCenter != NULL)
    {
      hMonitor = ::MonitorFromWindow(hWndCenter,
        MONITOR_DEFAULTTONEAREST);
    }
    <span class="keyword">else</span>
    {
      hMonitor = ::MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);
    }

    <span class="comment">//ATLENSURE_RETURN_VAL(hMonitor != NULL, FALSE);
</span>
    MONITORINFO minfo;
    minfo.cbSize = <span class="keyword">sizeof</span>(MONITORINFO);
    BOOL bResult = ::GetMonitorInfo(hMonitor, &amp;minfo);
    <span class="comment">//ATLENSURE_RETURN_VAL(bResult, FALSE);
</span>
    rcArea = minfo.rcWork;
<span class="keyword">#endif</span>
    <span class="keyword">if</span>(hWndCenter == NULL)
      rcCenter = rcArea;
    <span class="keyword">else</span>
      ::GetWindowRect(hWndCenter, &amp;rcCenter);
  }
  <span class="keyword">else</span>
  {
    <span class="comment">// center within parent client coordinates
</span>    hWndParent = ::GetParent(m_hWnd);
    ASSERT(::IsWindow(hWndParent));

    ::GetClientRect(hWndParent, &amp;rcArea);
    ASSERT(::IsWindow(hWndCenter));
    ::GetClientRect(hWndCenter, &amp;rcCenter);
    ::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&amp;rcCenter, <span class="number">2</span>);
  }

  <span class="keyword">int</span> DlgWidth = rcDlg.right - rcDlg.left;
  <span class="keyword">int</span> DlgHeight = rcDlg.bottom - rcDlg.top;

  <span class="comment">// find dialog's upper left based on rcCenter
</span>  <span class="keyword">int</span> xLeft = (rcCenter.left + rcCenter.right) / <span class="number">2</span> - DlgWidth / <span class="number">2</span>;
  <span class="keyword">int</span> yTop = (rcCenter.top + rcCenter.bottom) / <span class="number">2</span> - DlgHeight / <span class="number">2</span>;

  <span class="comment">// if the dialog is outside the screen, move it inside
</span>  <span class="keyword">if</span>(xLeft + DlgWidth &gt; rcArea.right)
    xLeft = rcArea.right - DlgWidth;
  <span class="keyword">if</span>(xLeft &lt; rcArea.left)
    xLeft = rcArea.left;

  <span class="keyword">if</span>(yTop + DlgHeight &gt; rcArea.bottom)
    yTop = rcArea.bottom - DlgHeight;
  <span class="keyword">if</span>(yTop &lt; rcArea.top)
    yTop = rcArea.top;

  <span class="comment">// map screen coordinates to child coordinates
</span>  <span class="keyword">return</span> ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, <span class="number">-1</span>, <span class="number">-1</span>,
    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}


<span class="comment">// Message handler for about box.
</span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
INT_PTR CALLBACK DlgProc(HWND hDlg,
  UINT message,
  WPARAM wParam,
  LPARAM lParam)
{
  BOOL bHandled = FALSE;
  UNREFERENCED_PARAMETER(lParam);

  <span class="keyword">switch</span> (message)
  {
  <span class="keyword">case</span> WM_INITDIALOG:
    {
      T * p = (T*)lParam;
      SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) p);
      p-&gt;InitEntry(hDlg);
      <span class="keyword">return</span> (INT_PTR)TRUE;
    }  
  }

  <span class="comment">//TODO : all messages?
</span>  T * p = (T*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
  LRESULT r = Details::SendMessageTo(p, hDlg, message, wParam, lParam, bHandled);

  <span class="keyword">return</span> bHandled;
}


<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
INT_PTR ShowDialog(LPCWSTR lpTemplateName, T * p, HWND hWndParent)
{
  HINSTANCE hInst = GetModuleHandle(NULL);
  INT_PTR r = DialogBoxParam(hInst, lpTemplateName, hWndParent, &amp;DlgProc&lt;T&gt;,(LPARAM) p);

  ASSERT(r != <span class="number">0</span>); //resource exists?	(<span class="number">1813</span>)
  <span class="keyword">return</span> r;
}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
HWND ShowModeless(UINT IDD, T* p, HWND hParent)
{
  HWND hWnd = NULL;

  HINSTANCE hInstance = GetModuleHandle(NULL);   

  HRSRC hDlg = FindResource(hInstance, MAKEINTRESOURCE(IDD), RT_DIALOG);
  <span class="keyword">if</span> (hDlg != NULL)
  {
    DWORD dwLastError = <span class="number">0</span>;
    HGLOBAL hResource = LoadResource(hInstance, hDlg);
    <span class="keyword">if</span> (hResource != NULL)
    {
      DLGTEMPLATE* pDlg = (DLGTEMPLATE*) LockResource(hResource);
      <span class="keyword">if</span> (pDlg != NULL)
      {
        hWnd = CreateDialogIndirectParam(
          hInstance,
          pDlg,
          hParent,
          &amp;DlgProc&lt;T&gt;, 
          (LPARAM)p);

        UnlockResource(hResource);
      }
      <span class="keyword">else</span>
        dwLastError = ::GetLastError();
    }
    <span class="keyword">else</span>
      dwLastError = ::GetLastError();

    <span class="keyword">if</span> (dwLastError != <span class="number">0</span>)
      SetLastError(dwLastError);
  }
  <span class="keyword">return</span> hWnd;
}


<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, UINT IDD&gt;
<span class="keyword">class</span> Dialog
{
<span class="keyword">protected</span>:
  HWND m_hDlg;
  HWND m_hParent;

<span class="keyword">public</span>:

  <span class="keyword">int</span> EndDialog(<span class="keyword">int</span> r)
  {
    <span class="keyword">return</span> ::EndDialog(m_hDlg, r);
  }

  UINT GetDlgItemText(<span class="keyword">int</span> nID, std::<span class="keyword2">wstring</span>&amp; s) <span class="keyword">const</span>
  {
    ASSERT(::IsWindow(m_hDlg));
    HWND hItem = GetDlgItem(nID);
    <span class="keyword">if</span> (hItem != NULL)
    {
      <span class="keyword">int</span> nLength = ::GetWindowTextLength(hItem);
      std::<span class="keyword2">vector</span>&lt;<span class="keyword">wchar_t</span>&gt; buffer(nLength<span class="number">+1</span>);
      <span class="keyword">wchar_t</span>* pszText = &amp;buffer[<span class="number">0</span>];
      nLength = ::GetWindowText(hItem, pszText, nLength<span class="number">+1</span>);
      s = pszText;
      <span class="keyword">return</span> nLength;
    }
    <span class="keyword">else</span>
    {
      s.clear();
      <span class="keyword">return</span> <span class="number">0</span>;
    }
  }

  HWND GetDlgItem(UINT id) <span class="keyword">const</span>
  {
    <span class="keyword">return</span> ::GetDlgItem(m_hDlg, id);
  }

  Dialog(HWND hParent = NULL) : m_hParent(hParent)
  {
  }

  <span class="comment">//WM_INITDIALOG
</span>  <span class="keyword">void</span> InitEntry(HWND hDlg)
  {     
    m_hDlg = hDlg;
    CenterWindow(m_hDlg, m_hParent);

    __if_exists (T::InitDialog)
    {
      <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;InitDialog();
    }
  }

  <span class="comment">//show modeless
</span>  <span class="keyword">void</span> Show()
  {
    m_hDlg = ShowModeless(IDD, <span class="keyword">this</span>, m_hParent);                        
  }

  <span class="comment">//show modal
</span>  <span class="keyword">int</span> ShowDialog()
  {
    <span class="keyword">return</span> ::ShowDialog(MAKEINTRESOURCE(IDD), <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>), m_hParent);
  }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, 
  UINT IconId =<span class="number">0</span>,
  UINT MENUIDD = <span class="number">0</span>,
  UINT wStyle =  WS_OVERLAPPEDWINDOW | CS_DBLCLKS 
&gt;
<span class="keyword">class</span> Window
{
<span class="keyword">protected</span>:
  HWND m_hWnd;

<span class="keyword">public</span>:

  <span class="keyword">static</span> <span class="keyword">const</span> WNDCLASSEX * GetClass()
  {
    HINSTANCE hInstance = GetModuleHandle(NULL);
    <span class="keyword">static</span> WNDCLASSEX wcex;
    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);
    wcex.style          = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wcex.lpfnWndProc    = &amp;WindowsProcEx&lt;T&gt;;
    wcex.cbClsExtra     = <span class="number">0</span>;
    wcex.cbWndExtra     = <span class="number">0</span>;
    wcex.hInstance      = hInstance;

    wcex.hIcon            = LoadIcon(hInstance, MAKEINTRESOURCE(IconId));

    wcex.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);

    <span class="keyword">if</span> (MENUIDD != NULL)
      wcex.lpszMenuName   = MAKEINTRESOURCE(MENUIDD);
    <span class="keyword">else</span>
      wcex.lpszMenuName   = NULL;

    wcex.lpszClassName  = L<span class="string">&quot;class&quot;</span>;
    wcex.hIconSm        = <span class="number">0</span>;<span class="comment">//LoadIcon(wcex.hInstance,MAKEINTRESOURCE(IDI_SMALL));
</span>    <span class="keyword">return</span> &amp;wcex;
  }

  Window() : m_hWnd(NULL)
  {
  }

  <span class="keyword">void</span> Create(HWND hWndParent = <span class="number">0</span>)
  {
    HINSTANCE hInstance = GetModuleHandle(NULL);
    RegisterClassEx(GetClass());

    m_hWnd = CreateWindow(GetClass()-&gt;lpszClassName, L<span class="string">&quot;&quot;</span>, wStyle,
      <span class="number">0</span>, <span class="number">0</span>, CW_USEDEFAULT, CW_USEDEFAULT, hWndParent, NULL, hInstance, NULL);

    SetWindowDocument(m_hWnd, <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>));
    ShowWindow(m_hWnd, TRUE);
    UpdateWindow(m_hWnd);
  }
};


<span class="keyword">#if</span> defined _M_IX86
<span class="keyword">#pragma</span> comment(linker, <span class="string">&quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;</span>)
#elif defined _M_IA64
<span class="keyword">#pragma</span> comment(linker, <span class="string">&quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='ia64' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;</span>)
#elif defined _M_X64
<span class="keyword">#pragma</span> comment(linker, <span class="string">&quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;</span>)
<span class="keyword">#else</span>
<span class="keyword">#pragma</span> comment(linker, <span class="string">&quot;/manifestdependency:\&quot;type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\&quot;&quot;</span>)
<span class="keyword">#endif</span>


<span class="keyword">#define</span> COMMAND_ID_HANDLER(id, func) \
  <span class="keyword">if</span>(uMsg == WM_COMMAND &amp;&amp; id == LOWORD(wParam)) \
{ \
  bHandled = TRUE; \
  lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
  <span class="keyword">if</span>(bHandled) \
  <span class="keyword">return</span> TRUE; \
}

<span class="keyword">#define</span> S_COMMAND_ID_HANDLER(id, func) \
  <span class="keyword">if</span>(uMsg == WM_COMMAND &amp;&amp; id == LOWORD(wParam)) \
{ \
  bHandled = TRUE; \
  lResult = <span class="number">1</span>;\
  bHandled = TRUE;\
  func(); \
  <span class="keyword">if</span>(bHandled) \
  <span class="keyword">return</span> TRUE; \
}


<span class="keyword">#define</span> COMMAND_HANDLER(id, code, func) \
  <span class="keyword">if</span>(uMsg == WM_COMMAND &amp;&amp; id == LOWORD(wParam) &amp;&amp; code == HIWORD(wParam)) \
{ \
  bHandled = TRUE; \
  lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
  <span class="keyword">if</span>(bHandled) \
  <span class="keyword">return</span> TRUE; \
}


<span class="keyword">#define</span> BEGIN_MSG_MAP(theClass) \
<span class="keyword">public</span>: \
  BOOL ProcessWindowMessage(_In_ HWND hWnd, _In_ UINT uMsg, _In_ WPARAM wParam,\
  _In_ LPARAM lParam, _Inout_ LRESULT&amp; lResult, _In_ DWORD dwMsgMapID = <span class="number">0</span>) \
{ \
  BOOL bHandled = TRUE; \
  (hWnd); \
  (uMsg); \
  (wParam); \
  (lParam); \
  (lResult); \
  (bHandled); \
  <span class="keyword">switch</span>(dwMsgMapID) \
{ \
  <span class="keyword">case</span> <span class="number">0</span>:


<span class="keyword">#define</span> END_MSG_MAP() \
  <span class="keyword">break</span>; \
  <span class="keyword">default</span>: \
  <span class="keyword">break</span>; \
} \
  <span class="keyword">return</span> FALSE; \
}

</pre>



<p><a href="Download sample">win32express1.zip</a>
<!-- Page content end --> 
</article> 
 
</body> 
</html>  