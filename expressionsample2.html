<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<a class = "linkbox" href = "codeblog.html">CODE-BLOG</a>
<a class = "linkbox" href = "about.html">ABOUT </a>
<p><a href="tklgen2.md">TKLGEN HOME</a></p>

<h2 id="toc_0">Tutorial and sample</h2>

<p>This sample parse expressions.</p>

<p>This <strong>is not the tklgen grammar</strong> but it helps to think how to build LL1 grammars.</p>

<p>The brackets [ and ] enclose an optional part of the production. 
The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. 
The unquoted parentheses ( and ) serve only to group elements in a production.)</p>

<pre><code>  E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
  T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
  F --&gt; P [&quot;^&quot; F]
  P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
</code></pre>

<p>Now lets see how to build a tklgen LL1 grammar:</p>

<h3>grammar.txt</h3>

<pre><code class="language-tklgen">
module Sample2
{
  language Sample2
   {
    token Plus = &#39;+&#39;;
    token Minus = &#39;-&#39;;
    token Multi = &#39;*&#39;;
    token Div = &#39;/&#39;;
    token Power = &#39;^&#39;;
    token Open = &#39;(&#39;;
    token Close = &#39;)&#39;;
    token End = &#39;;&#39;;
    token EndMark = &#39;\0&#39;;
    token Integer   = (&#39;0&#39;..&#39;9&#39;)+;
    token Identifier   = (&#39;a&#39;..&#39;z&#39; | &#39;A&#39;..&#39;Z&#39; | &#39;_&#39; | &#39;$&#39;) +
                       (&#39;0&#39;..&#39;9&#39; + (&#39;a&#39;..&#39;z&#39; | &#39;A&#39;..&#39;Z&#39; | &#39;_&#39; | &#39;$&#39;) +) ?;
    
    interleave Blanks  = (&quot; &quot; | &quot;\n&quot; | &quot;\t&quot; | &quot;\r&quot;) +;

    
    syntax Main = Expressions;
    syntax Expression = E &#39;;&#39; {PrintNewLine};
    syntax Expressions = Expression Expressions | empty;

    // E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
    syntax E = T E2;
    syntax E2 = &#39;+&#39; T {PrintPlus} E2 |
                &#39;-&#39; T {PrintMinus} E2 |
                empty;

    // T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
    syntax T = F T2;
    syntax T2 = &#39;*&#39; F {PrintMulti} T2|
                &#39;/&#39; F {PrintDiv}T2|
                empty;

    // F --&gt; P [&quot;^&quot; F]
    syntax F = P FOpt;
    syntax FOpt = &#39;^&#39; F {PrintPower} | empty;

    // P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
    syntax P = {PrintLexeme} Integer |
               {PrintLexeme} Identifier | 
               &#39;(&#39; E &#39;)&#39; | 
               &#39;-&#39; T {PrintNeg};
      }
}

</code></pre>

<p>Use this command line:</p>

<pre><code> tklgen grammar.txt
</code></pre>

<p>The files below will be generated:</p>

<pre><code> Sample2Parser.h
 Sample2Parser.cpp
 Sample2DFA.h
</code></pre>

<p>The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.</p>

<pre><code>Tokenizer.h
FileStream.h
StringStream.h
SampleProgram.txt
</code></pre>

<h3>Sample2Parser.h</h3>

<pre><code class="language-cpp">//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include &lt;cassert&gt;
#include &lt;string&gt;
#include &quot;tokenizer.h&quot;
#include &quot;Sample2DFA.h&quot;


#include &quot;FileStream.h&quot;

namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    };

    class Context;
    void OnError(Context&amp;, ErrorCode);

    class ParserException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ErrorCode m_Error;
        ParserException(int line, int col, ErrorCode error)
            : m_Line(line), m_Col(col), m_Error(error)
        {
        }
    };


    class Context
    {
    public:
        FileStream&amp; m_Stream;

        Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
        Context(FileStream&amp; stream) : m_Stream(stream)
        {
            if (!NextToken&lt;DFA&gt;(
                        stream,
                        m_lexeme,
                        m_CurrentToken))
            {
              assert(false);
            }
        }
    };

    inline void OnError(Context&amp; context, ErrorCode er)
    {
        throw ParserException(GetLine(context.m_Stream),
                              GetCol(context.m_Stream),
                              er);
    }

    inline Tokens GetToken(Context&amp; context)
    {
        return context.m_CurrentToken;
    }

    inline bool Match(Context&amp; context, Tokens tk)
    {
        if (tk != context.m_CurrentToken)
        {
            OnError(context, ErrorCodeUnexpectedToken);
            return false;
        }

        if (!NextToken&lt;DFA&gt;(
                    context.m_Stream,
                    context.m_lexeme,
                    context.m_CurrentToken))
        {
        }
        return true;
    }


    inline void Action_PrintNewLine(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintPlus(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintMinus(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintMulti(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintDiv(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintPower(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintLexeme(Context&amp; /*ctx*/)
    {
    }

    inline void Action_PrintNeg(Context&amp; /*ctx*/)
    {
    }

    void Parse_Main(Context&amp;);
} // namespace

</code></pre>

<h3>Sample2Parser.cpp</h3>

<pre><code class="language-cpp">//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#include &quot;stdafx.h&quot;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &quot;tokenizer.h&quot;
#include &quot;Sample2DFA.h&quot;
#include &quot;Sample2Parser.h&quot;


namespace Sample2
{
    //forward declarations 
    void Parse_Main(Context&amp;);
    void Parse_Expressions(Context&amp;);
    void Parse_E(Context&amp;);
    void Parse_T(Context&amp;);
    void Parse_E2(Context&amp;);
    void Parse_Expression(Context&amp;);
    void Parse_T2(Context&amp;);
    void Parse_F(Context&amp;);
    void Parse_P(Context&amp;);
    void Parse_FOpt(Context&amp;);


    void Parse_Main(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKEndMark ||
            token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Main =&gt; Expressions 
            Parse_Expressions(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expressions(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Expressions =&gt; Expression Expressions 
            Parse_Expression(ctx);
            Parse_Expressions(ctx);
        }
        else if (token == TKEndMark)
        {
            //Expressions =&gt; Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //E =&gt; T E2 
            Parse_T(ctx);
            Parse_E2(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //T =&gt; F T2 
            Parse_F(ctx);
            Parse_T2(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E2(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKPlus)
        {
            //E2 =&gt; Plus T E2 
            Match(ctx, TKPlus);
            Parse_T(ctx);
            Action_PrintPlus(ctx);
            Parse_E2(ctx);
        }
        else if (token == TKMinus)
        {
            //E2 =&gt; Minus T E2 
            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintMinus(ctx);
            Parse_E2(ctx);
        }
        else if (token == TKClose ||
            token == TKEnd)
        {
            //E2 =&gt; Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expression(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Expression =&gt; E End 
            Parse_E(ctx);
            Match(ctx, TKEnd);
            Action_PrintNewLine(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T2(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMulti)
        {
            //T2 =&gt; Multi F T2 
            Match(ctx, TKMulti);
            Parse_F(ctx);
            Action_PrintMulti(ctx);
            Parse_T2(ctx);
        }
        else if (token == TKDiv)
        {
            //T2 =&gt; Div F T2 
            Match(ctx, TKDiv);
            Parse_F(ctx);
            Action_PrintDiv(ctx);
            Parse_T2(ctx);
        }
        else if (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            //T2 =&gt; Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_F(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //F =&gt; P FOpt 
            Parse_P(ctx);
            Parse_FOpt(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_P(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKInteger)
        {
            //P =&gt; Integer 
            Action_PrintLexeme(ctx);
            Match(ctx, TKInteger);
        }
        else if (token == TKIdentifier)
        {
            //P =&gt; Identifier 
            Action_PrintLexeme(ctx);
            Match(ctx, TKIdentifier);
        }
        else if (token == TKOpen)
        {
            //P =&gt; Open E Close 
            Match(ctx, TKOpen);
            Parse_E(ctx);
            Match(ctx, TKClose);
        }
        else if (token == TKMinus)
        {
            //P =&gt; Minus T 
            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintNeg(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_FOpt(Context&amp; ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKPower)
        {
            //FOpt =&gt; Power F 
            Match(ctx, TKPower);
            Parse_F(ctx);
            Action_PrintPower(ctx);
        }
        else if (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            //FOpt =&gt; Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

} //namespace Sample2

</code></pre>

<h3>Sample2DFA.h</h3>

<pre><code class="language-cpp">//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef __SAMPLE2DFA_H__
#define __SAMPLE2DFA_H__

namespace Sample2
{

enum Tokens
{
    TKPlus,
    TKMinus,
    TKMulti,
    TKDiv,
    TKPower,
    TKOpen,
    TKClose,
    TKEnd,
    TKEndMark,
    TKInteger,
    TKIdentifier,
    TKBlanks,
};

inline const wchar_t* TokensToString(Tokens e)
{
    switch(e)
    {
    case TKPlus: return L&quot;Plus&quot;;
    case TKMinus: return L&quot;Minus&quot;;
    case TKMulti: return L&quot;Multi&quot;;
    case TKDiv: return L&quot;Div&quot;;
    case TKPower: return L&quot;Power&quot;;
    case TKOpen: return L&quot;Open&quot;;
    case TKClose: return L&quot;Close&quot;;
    case TKEnd: return L&quot;End&quot;;
    case TKEndMark: return L&quot;EndMark&quot;;
    case TKInteger: return L&quot;Integer&quot;;
    case TKIdentifier: return L&quot;Identifier&quot;;
    case TKBlanks: return L&quot;Blanks&quot;;
    default:break;
    }
    return L&quot;&quot;;
}

struct DFA
{
    typedef Tokens TokenType;

    static int GetNext(int state, wchar_t ch)
    {
        switch (state)
        {
            case 0:
            if (ch == L&#39;\0&#39;)
                return 1;
        else if (ch &gt;= L&#39;\t&#39; &amp;&amp; ch &lt;= L&#39;\n&#39;)
          return 2;
            else if (ch == L&#39;\r&#39;)
                return 2;
            else if (ch == L&#39; &#39;)
                return 2;
            else if (ch == L&#39;$&#39;)
                return 3;
            else if (ch == L&#39;(&#39;)
                return 4;
            else if (ch == L&#39;)&#39;)
                return 5;
            else if (ch == L&#39;*&#39;)
                return 6;
            else if (ch == L&#39;+&#39;)
                return 7;
            else if (ch == L&#39;-&#39;)
                return 8;
            else if (ch == L&#39;/&#39;)
                return 9;
        else if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
          return 10;
            else if (ch == L&#39;;&#39;)
                return 11;
        else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
          return 3;
            else if (ch == L&#39;^&#39;)
                return 12;
            else if (ch == L&#39;_&#39;)
                return 3;
        else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
           return 3;
    break; // 
            case 1:
        //TKEndMark
    break; // 
            case 2:
        if (ch &gt;= L&#39;\t&#39; &amp;&amp; ch &lt;= L&#39;\n&#39;)
          return 2;
            else if (ch == L&#39;\r&#39;)
                return 2;
            else if (ch == L&#39; &#39;)
                return 2;
        //TKBlanks
    break; // 
            case 3:
            if (ch == L&#39;$&#39;)
                return 3;
        else if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
          return 14;
        else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
          return 3;
            else if (ch == L&#39;_&#39;)
                return 3;
        else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
          return 3;
        //TKIdentifier
    break; // 
            case 4:
        //TKOpen
    break; // 
            case 5:
        //TKClose
    break; // 
            case 6:
        //TKMulti
    break; // 
            case 7:
        //TKPlus
    break; // 
            case 8:
        //TKMinus
    break; // 
            case 9:
        //TKDiv
    break; // 
            case 10:
        if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
          return 10;
        //TKInteger
    break; // 
            case 11:
        //TKEnd
    break; // 
            case 12:
        //TKPower
    break; // 
            case 13:
  return -1;
    break; // 
            case 14:
            if (ch == L&#39;$&#39;)
                return 15;
        else if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
          return 14;
        else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
          return 15;
            else if (ch == L&#39;_&#39;)
                return 15;
        else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
           return 15;
    break; // 
            case 15:
            if (ch == L&#39;$&#39;)
                return 15;
        else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
          return 15;
            else if (ch == L&#39;_&#39;)
                return 15;
        else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
          return 15;
        //TKIdentifier
    break; // 
        } //switch
        return -1;
    }

    static bool IsInterleave(Tokens tk)
    {
        return tk == TKBlanks;
    }

    static bool GetTokenFromState(int state, Tokens&amp; tk)
    {
        switch(state)
        {
            case 1: tk = TKEndMark; break;
            case 2: tk = TKBlanks; break;
            case 3: tk = TKIdentifier; break;
            case 4: tk = TKOpen; break;
            case 5: tk = TKClose; break;
            case 6: tk = TKMulti; break;
            case 7: tk = TKPlus; break;
            case 8: tk = TKMinus; break;
            case 9: tk = TKDiv; break;
            case 10: tk = TKInteger; break;
            case 11: tk = TKEnd; break;
            case 12: tk = TKPower; break;
            case 15: tk = TKIdentifier; break;
            default:
                return false;
        }
        return true;
    }
};
} //namespace
#endif //header

</code></pre>

<h3>Tokenizer (do not depend on grammar)</h3>

<pre><code class="language-cpp">//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

inline void Clear(std::wstring&amp; ws)
{
    ws.clear();
}

inline void Append(std::wstring&amp; ws, wchar_t ch)
{
    ws.append(1, ch);
}


inline void Clear(std::string&amp; ws)
{
    ws.clear();
}

inline void Append(std::string&amp; ws, char ch)
{
    ws.append(1, ch);
}

template &lt; class TDFA,
         class T,
         class TInputStream &gt;
bool NextTokenNoInterleave(TInputStream&amp; stream,
                           T&amp; lexeme,
                           typename TDFA::TokenType&amp; tk)
{
    Clear(lexeme);
    int lastGoodState = -1;
    int currentState = 0;
    wchar_t ch;

    while (GetChar(stream, ch))
    {
        currentState = TDFA::GetNext(currentState, ch);

        if (currentState == -1)
        {
            PutBack(stream, ch);
            break;
        }

        typename TDFA::TokenType tk2;

        if (TDFA::GetTokenFromState(currentState, tk2))
        {
            tk = tk2;
            lastGoodState = currentState;
        }

        Append(lexeme, ch);
    }

    return (lastGoodState != -1);
}

template &lt; class TDFA,
         class T,
         class TInputStream &gt;
bool NextToken(TInputStream&amp; stream,
               T&amp; lexeme,
               typename TDFA::TokenType&amp; tk)
{
    for (;;)
    {
        if (!NextTokenNoInterleave&lt;TDFA&gt;(stream, lexeme, tk))
        {
            return false;
        }

        if (!TDFA::IsInterleave(tk))
        {
            return true;
        }
    }
}



</code></pre>

<h3>FileStream (do not depend on grammar)</h3>

<pre><code class="language-cpp">

#pragma once

#include &lt;cstdio&gt;
#include &lt;cassert&gt;

struct FileStream
{
  typedef const wchar_t* BufferIterator;

  wchar_t*     m_pCharacteres;
  const size_t m_MaxBufferSize;
  wchar_t*     m_pCurrentChar;
  FILE*        m_hFile;
  size_t       m_CurrentLine;
  size_t       m_CurrentCol;

  bool         m_HasPutBack;
  wchar_t      m_PutBackCharacter;

  bool         m_EofSent;

  BufferIterator FirstBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize - 1;
  }

  BufferIterator SecondBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize * 2 - 1;
  }

  bool GetCharCore(wchar_t&amp; ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L&#39;\0&#39;)
    {
      ch = &#39;\0&#39;;
      m_EofSent = true;
    }
    else
    {
      if (*m_pCurrentChar == L&#39;\0&#39;)
      {
        if (m_pCurrentChar == FirstBufferEnd())
        {
          wchar_t* pSecondBuffer =
            m_pCharacteres + m_MaxBufferSize;

          size_t r = fread(pSecondBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);
          pSecondBuffer[r] = 0;
          m_pCurrentChar = pSecondBuffer;
        }
        else if (m_pCurrentChar == SecondBufferEnd())
        {
          wchar_t* pFirstBuffer = m_pCharacteres;

          size_t r = fread(pFirstBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);

          pFirstBuffer[r] = 0;
          m_pCurrentChar = pFirstBuffer;
        }
      }
    }

    assert(m_pCharacteres[m_MaxBufferSize - 1] == 0);
    assert(m_pCharacteres[m_MaxBufferSize * 2 - 1] == 0);
    return true;
  }

public:

  FileStream(const wchar_t* fileName, size_t bufferSize = 4096)
    : m_MaxBufferSize(bufferSize)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L&#39;\0&#39;)
    , m_EofSent(false)
  {
    assert(bufferSize &gt;= 2);

    //allocate 2 buffers
    m_pCharacteres = new wchar_t[m_MaxBufferSize * 2];
    m_pCharacteres[m_MaxBufferSize * 2 - 1] = 0;
    m_pCharacteres[m_MaxBufferSize - 1] = 0;
    m_pCurrentChar = m_pCharacteres;

    errno_t err = _wfopen_s(&amp;m_hFile, fileName, L&quot;r,ccs=UTF-8&quot;);

    if (err == 0)
    {
      size_t r = fread(m_pCharacteres,
                       sizeof(wchar_t),
                       m_MaxBufferSize - 1,
                       m_hFile);

      m_pCharacteres[r] = L&#39;\0&#39;;
    }
  }

  ~FileStream()
  {
    fclose(m_hFile);
    delete [] m_pCharacteres;
  }

  friend void PutBack(FileStream&amp; fileStream, wchar_t ch)
  {
    assert(fileStream.m_HasPutBack == false);

    if (ch == L&#39;\n&#39;)
    {
      if (fileStream.m_CurrentLine &gt; 1)
      {
        fileStream.m_CurrentLine--;
      }
    }
    else
    {
      if (fileStream.m_CurrentCol &gt; 1)
      {
        fileStream.m_CurrentCol--;
      }
    }

    fileStream.m_PutBackCharacter = ch;
    fileStream.m_HasPutBack = true;
  }
  
  friend bool GetChar(FileStream&amp; fileStream, wchar_t&amp; ch)
  {
    bool b = fileStream.GetCharCore(ch);

    if (b &amp;&amp; ch == L&#39;\n&#39;)
    {
      fileStream.m_CurrentLine++;
      fileStream.m_CurrentCol = 1;
    }
    else
    {
      fileStream.m_CurrentCol++;
    }

    return b;
  }

  friend size_t GetLine(const FileStream&amp; fileStream)
  {
    return fileStream.m_CurrentLine;
  }

  friend size_t GetCol(const FileStream&amp; fileStream)
  {
    return fileStream.m_CurrentCol;
  }
};


</code></pre>

<h3>StringStream (do not depend on grammar) ===</h3>

<pre><code class="language-cpp">
#pragma once
#include &lt;cassert&gt;

struct StringStream
{
  const wchar_t* m_pCharacteres;
  const wchar_t* m_pCurrentChar;
  size_t         m_CurrentLine;
  size_t         m_CurrentCol;
  bool           m_HasPutBack;
  wchar_t        m_PutBackCharacter;
  bool           m_EofSent;

  bool GetCharCore(wchar_t&amp; ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L&#39;\0&#39;)
    {
      ch = &#39;\0&#39;;
      m_EofSent = true;
    }

    return true;
  }

public:

  StringStream(const wchar_t* psz)
    : m_pCharacteres(psz)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L&#39;\0&#39;)
    , m_EofSent(false)
  {
    m_pCurrentChar = m_pCharacteres;
  }

  friend void PutBack(StringStream&amp; stream,  wchar_t ch)
  {
    assert(stream.m_HasPutBack == false);

    if (ch == L&#39;\n&#39;)
    {
      if (stream.m_CurrentLine &gt; 1)
      {
        stream.m_CurrentLine--;
      }
    }
    else
    {
      if (stream.m_CurrentCol &gt; 1)
      {
        stream.m_CurrentCol--;
      }
    }

    stream.m_PutBackCharacter = ch;
    stream.m_HasPutBack = true;
  }

  friend bool GetChar(StringStream&amp; stream, wchar_t&amp; ch)
  {
    bool b = stream.GetCharCore(ch);

    if (b &amp;&amp; ch == L&#39;\n&#39;)
    {
      stream.m_CurrentLine++;
      stream.m_CurrentCol = 1;
    }
    else
    {
      stream.m_CurrentCol++;
    }

    return b;
  }

  size_t GetLine(const StringStream&amp; stream)
  {
    return stream.m_CurrentLine;
  }

  size_t GetCol(const StringStream&amp; stream) 
  {
    return stream.m_CurrentCol;
  }
};

</code></pre>

<h3>SampleProgram.txt (just a sample)===</h3>

<pre><code class="language-cpp">
#include &quot;stdafx.h&quot;
#include &quot;Sample2Parser.h&quot;
#include &lt;iostream&gt;

int _tmain(int argc, _TCHAR* argv[])
{
  if (argc == 1)
  {
    std::cout &lt;&lt; &quot;missing input file &quot;;
    return 1;
  }

  try
  {
    FileStream ss(argv[1]);
    Sample2::Context ctx(ss);
    Sample2::Parse_Main(ctx);
  }
  catch (const Sample2::ParserException&amp; e)
  {
    std::cout &lt;&lt; &quot;Error : line, col = &quot; &lt;&lt; e.m_Line &lt;&lt; &quot;, &quot; &lt;&lt; e.m_Col &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; e)
  {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  return 0;
}

</code></pre>

<h2 id="toc_1">Modifed SampleParser.h</h2>

<pre><code class="language-cpp">
//iostream included
#include &lt;iostream&gt;
using namespace std;

...

   //Actions added

    inline void Action_PrintNewLine(Context&amp; /*ctx*/)
    {
      wcout &lt;&lt; std::endl;
    }

    inline void Action_PrintPlus(Context&amp; /*ctx*/)
    {    
       wcout &lt;&lt; L&quot; +&quot;;
    }

    inline void Action_PrintMinus(Context&amp; /*ctx*/)
    {
        wcout &lt;&lt; L&quot; -&quot;;
    }

    inline void Action_PrintMulti(Context&amp; /*ctx*/)
    {
       wcout &lt;&lt; L&quot; *&quot;;
    }

    inline void Action_PrintDiv(Context&amp; /*ctx*/)
    {
       wcout &lt;&lt; L&quot; /&quot;;
    }

    inline void Action_PrintPower(Context&amp; /*ctx*/)
    {
       wcout &lt;&lt; L&quot; ^&quot;;
    }

    inline void Action_PrintLexeme(Context&amp; ctx)
    {
         wcout &lt;&lt; L&quot; &quot; &lt;&lt; ctx.m_lexeme;
    }

    inline void Action_PrintNeg(Context&amp; /*ctx*/)
    {
         wcout &lt;&lt; L&quot; NEG&quot;;
    }

...
} // namespace

</code></pre>
</body></html>