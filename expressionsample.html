<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<p>[[tklgen.htm|TKLGEN HOME]]</p>

<p>==Tutorial and sample==</p>

<p>This sample parse expressions.</p>

<p>This <strong>is not the tklgen grammar</strong> but it helps to think how to build LL1 grammars.</p>

<p>The brackets [ and ] enclose an optional part of the production. 
The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. 
The unquoted parentheses ( and ) serve only to group elements in a production.)</p>

<p>{{{
  E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
  T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
  F --&gt; P [&quot;^&quot; F]
  P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
}}}</p>

<p>Now lets see how to build a tklgen LL1 grammar:</p>

<p>===grammar.txt===</p>

<p>{{{cpp</p>

<p>module Sample2
{
  language Sample2
   {
    token Plus = &#39;+&#39;;
    token Minus = &#39;-&#39;;
    token Multi = &#39;*&#39;;
    token Div = &#39;/&#39;;
    token Power = &#39;^&#39;;
    token Open = &#39;(&#39;;
    token Close = &#39;)&#39;;
    token End = &#39;;&#39;;
    token EndMark = &#39;\0&#39;;
    token Integer   = (&#39;0&#39;..&#39;9&#39;)+;
    token Identifier   = (&#39;a&#39;..&#39;z&#39; | &#39;A&#39;..&#39;Z&#39; | &#39;<em>&#39; | &#39;$&#39;) +
                       (&#39;0&#39;..&#39;9&#39; + (&#39;a&#39;..&#39;z&#39; | &#39;A&#39;..&#39;Z&#39; | &#39;</em>&#39; | &#39;$&#39;) +) ?;</p>

<pre><code>interleave Blanks  = (&quot; &quot; | &quot;\n&quot; | &quot;\t&quot; | &quot;\r&quot;) +;


syntax Main = Expressions;
syntax Expression = E &#39;;&#39; {PrintNewLine};
syntax Expressions = Expression Expressions | empty;

// E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
syntax E = T E2;
syntax E2 = &#39;+&#39; T {PrintPlus} E2 |
            &#39;-&#39; T {PrintMinus} E2 |
            empty;

// T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
syntax T = F T2;
syntax T2 = &#39;*&#39; F {PrintMulti} T2|
            &#39;/&#39; F {PrintDiv}T2|
            empty;

// F --&gt; P [&quot;^&quot; F]
syntax F = P FOpt;
syntax FOpt = &#39;^&#39; F {PrintPower} | empty;

// P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
syntax P = {PrintLexeme} Integer |
           {PrintLexeme} Identifier | 
           &#39;(&#39; E &#39;)&#39; | 
           &#39;-&#39; T {PrintNeg};
  }
</code></pre>

<p>}</p>

<p>}}}</p>

<p>Use this command line:</p>

<p>{{{
 tklgen grammar.txt
}}}</p>

<p>The files below will be generated:</p>

<p>{{{
 Sample2Parser.h
 Sample2Parser.cpp
 Sample2DFA.h
}}}</p>

<p>The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.</p>

<p>{{{
Tokenizer.h
FileStream.h
StringStream.h
SampleProgram.txt
}}}</p>

<p>===Sample2Parser.h===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_0">pragma once</h1>

<h1 id="toc_1">include <cassert></h1>

<h1 id="toc_2">include <string></h1>

<h1 id="toc_3">include &quot;tokenizer.h&quot;</h1>

<h1 id="toc_4">include &quot;Sample2DFA.h&quot;</h1>

<p>//Select the input stream type</p>

<h1 id="toc_5">include &quot;FileStream.h&quot;</h1>

<p>//#include &quot;StringStream.h&quot;
//#include &quot;YourStream.h&quot;</p>

<p>namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken</p>

<pre><code>};


class ParserException : public std::exception
{
public:
    int m_Line;
    int m_Col;
    ErrorCode m_Error;
    ParserException(int line,
                    int col,
                    ErrorCode error)
        : m_Line(line)
        , m_Col(col)
        , m_Error(error)
{
}
};


class Context
{
    public:
    //Select
    typedef FileStream   InputStream;
    //typedef StringStream InputStream;
    //typedef YourStream   InputStream;

    typedef Tokenizer&lt;Sample2::DFA, InputStream&gt; Scanner;

    private:
    Scanner&amp; m_scanner;

    Sample2::Tokens m_CurrentToken;
    std::wstring m_lexeme;

public:
    Context(Scanner&amp; s) : m_scanner(s)
    {
        if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
        {
            throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);
        }
    }

    //returns the current token
    Sample2::Tokens Token() const
    {
         return m_CurrentToken;
    }

    //checks if Token() == tk and then move the current token
    void Match(Sample2::Tokens tk)
    {
         if (tk != m_CurrentToken)
         {
            throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);
         }
         if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
         {
         }
    }

    int GetLine() const
    {
        return m_scanner.m_InputStream.GetLine();
    }

    int GetCol() const
    {
        return m_scanner.m_InputStream.GetCol();
    }
    void Action_PrintNewLine() {}
    void Action_PrintPlus() {}
    void Action_PrintMinus() {}
    void Action_PrintMulti() {}
    void Action_PrintDiv() {}
    void Action_PrintPower() {}
    void Action_PrintLexeme() {}
    void Action_PrintNeg() {}
};



void Parse_Main(Context&amp;);
</code></pre>

<p>} //namespace</p>

<p>}}}</p>

<p>===Sample2Parser.cpp===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_6">include <cassert></h1>

<h1 id="toc_7">include <string></h1>

<h1 id="toc_8">include &quot;tokenizer.h&quot;</h1>

<h1 id="toc_9">include &quot;Sample2DFA.h&quot;</h1>

<h1 id="toc_10">include &quot;Sample2Parser.h&quot;</h1>

<p>namespace Sample2
{
    //forward declarations 
    void Parse<em>Main(Context&amp;);
    void Parse</em>Expressions(Context&amp;);
    void Parse<em>Expression(Context&amp;);
    void Parse</em>E(Context&amp;);
    void Parse<em>T(Context&amp;);
    void Parse</em>E2(Context&amp;);
    void Parse<em>F(Context&amp;);
    void Parse</em>T2(Context&amp;);
    void Parse<em>P(Context&amp;);
    void Parse</em>FOpt(Context&amp;);</p>

<pre><code>void Parse_Main(Context&amp; ctx)
{
    if (ctx.Token() == TKEndMark ||
        ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //Main =&gt; Expressions 
        Parse_Expressions(ctx);
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_Expressions(Context&amp; ctx)
{
    if (ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //Expressions =&gt; Expression Expressions 
        Parse_Expression(ctx);
        Parse_Expressions(ctx);
    }
    else if (ctx.Token() == TKEndMark)
    {
        //Expressions =&gt; Epsilon 
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_Expression(Context&amp; ctx)
{
    if (ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //Expression =&gt; E End 
        Parse_E(ctx);
        ctx.Match(TKEnd);
        ctx.Action_PrintNewLine();
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_E(Context&amp; ctx)
{
    if (ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //E =&gt; T E2 
        Parse_T(ctx);
        Parse_E2(ctx);
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_T(Context&amp; ctx)
{
    if (ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //T =&gt; F T2 
        Parse_F(ctx);
        Parse_T2(ctx);
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_E2(Context&amp; ctx)
{
    if (ctx.Token() == TKPlus)
    {
        //E2 =&gt; Plus T E2 
        ctx.Match(TKPlus);
        Parse_T(ctx);
        ctx.Action_PrintPlus();
        Parse_E2(ctx);
    }
    else if (ctx.Token() == TKMinus)
    {
        //E2 =&gt; Minus T E2 
        ctx.Match(TKMinus);
        Parse_T(ctx);
        ctx.Action_PrintMinus();
        Parse_E2(ctx);
    }
    else if (ctx.Token() == TKClose ||
        ctx.Token() == TKEnd)
    {
        //E2 =&gt; Epsilon 
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_F(Context&amp; ctx)
{
    if (ctx.Token() == TKMinus ||
        ctx.Token() == TKOpen ||
        ctx.Token() == TKInteger ||
        ctx.Token() == TKIdentifier)
    {
        //F =&gt; P FOpt 
        Parse_P(ctx);
        Parse_FOpt(ctx);
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_T2(Context&amp; ctx)
{
    if (ctx.Token() == TKMulti)
    {
        //T2 =&gt; Multi F T2 
        ctx.Match(TKMulti);
        Parse_F(ctx);
        ctx.Action_PrintMulti();
        Parse_T2(ctx);
    }
    else if (ctx.Token() == TKDiv)
    {
        //T2 =&gt; Div F T2 
        ctx.Match(TKDiv);
        Parse_F(ctx);
        ctx.Action_PrintDiv();
        Parse_T2(ctx);
    }
    else if (ctx.Token() == TKPlus ||
        ctx.Token() == TKMulti ||
        ctx.Token() == TKMinus ||
        ctx.Token() == TKDiv ||
        ctx.Token() == TKPower ||
        ctx.Token() == TKClose ||
        ctx.Token() == TKEnd)
    {
        //T2 =&gt; Epsilon 
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_P(Context&amp; ctx)
{
    if (ctx.Token() == TKInteger)
    {
        //P =&gt; Integer 
        ctx.Action_PrintLexeme();
        ctx.Match(TKInteger);
    }
    else if (ctx.Token() == TKIdentifier)
    {
        //P =&gt; Identifier 
        ctx.Action_PrintLexeme();
        ctx.Match(TKIdentifier);
    }
    else if (ctx.Token() == TKOpen)
    {
        //P =&gt; Open E Close 
        ctx.Match(TKOpen);
        Parse_E(ctx);
        ctx.Match(TKClose);
    }
    else if (ctx.Token() == TKMinus)
    {
        //P =&gt; Minus T 
        ctx.Match(TKMinus);
        Parse_T(ctx);
        ctx.Action_PrintNeg();
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}

void Parse_FOpt(Context&amp; ctx)
{
    if (ctx.Token() == TKPower)
    {
        //FOpt =&gt; Power F 
        ctx.Match(TKPower);
        Parse_F(ctx);
        ctx.Action_PrintPower();
    }
    else if (ctx.Token() == TKPlus ||
        ctx.Token() == TKMulti ||
        ctx.Token() == TKMinus ||
        ctx.Token() == TKDiv ||
        ctx.Token() == TKPower ||
        ctx.Token() == TKClose ||
        ctx.Token() == TKEnd)
    {
        //FOpt =&gt; Epsilon 
    }
    else
    {
        throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);
    }
}
</code></pre>

<p>} //namespace Sample2</p>

<p>}}}</p>

<p>===Sample2DFA.h===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_11">ifndef <strong>SAMPLE2DFA_H</strong></h1>

<h1 id="toc_12">define <strong>SAMPLE2DFA_H</strong></h1>

<p>namespace Sample2
{</p>

<p>enum Tokens
{
    TKPlus,
    TKMinus,
    TKMulti,
    TKDiv,
    TKPower,
    TKOpen,
    TKClose,
    TKEnd,
    TKEndMark,
    TKInteger,
    TKIdentifier,
    TKBlanks,
};</p>

<p>inline const wchar_t* TokensToString(Tokens e)
{
    switch(e)
    {
    case TKPlus: return L&quot;Plus&quot;;
    case TKMinus: return L&quot;Minus&quot;;
    case TKMulti: return L&quot;Multi&quot;;
    case TKDiv: return L&quot;Div&quot;;
    case TKPower: return L&quot;Power&quot;;
    case TKOpen: return L&quot;Open&quot;;
    case TKClose: return L&quot;Close&quot;;
    case TKEnd: return L&quot;End&quot;;
    case TKEndMark: return L&quot;EndMark&quot;;
    case TKInteger: return L&quot;Integer&quot;;
    case TKIdentifier: return L&quot;Identifier&quot;;
    case TKBlanks: return L&quot;Blanks&quot;;
    default:break;
    }
    return L&quot;&quot;;
}</p>

<p>struct DFA
{
    typedef Tokens TokenType;</p>

<pre><code>static int GetNext(int state, wchar_t ch)
{
    switch (state)
    {
        case 0:
        if (ch == L&#39;\0&#39;)
            return 1;
    else if (ch &gt;= L&#39;\t&#39; &amp;&amp; ch &lt;= L&#39;\n&#39;)
      return 2;
        else if (ch == L&#39;\r&#39;)
            return 2;
        else if (ch == L&#39; &#39;)
            return 2;
        else if (ch == L&#39;$&#39;)
            return 3;
        else if (ch == L&#39;(&#39;)
            return 4;
        else if (ch == L&#39;)&#39;)
            return 5;
        else if (ch == L&#39;*&#39;)
            return 6;
        else if (ch == L&#39;+&#39;)
            return 7;
        else if (ch == L&#39;-&#39;)
            return 8;
        else if (ch == L&#39;/&#39;)
            return 9;
    else if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
      return 10;
        else if (ch == L&#39;;&#39;)
            return 11;
    else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
      return 3;
        else if (ch == L&#39;^&#39;)
            return 12;
        else if (ch == L&#39;_&#39;)
            return 3;
    else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
       return 3;
break; // 
        case 1:
    //TKEndMark
break; // 
        case 2:
    if (ch &gt;= L&#39;\t&#39; &amp;&amp; ch &lt;= L&#39;\n&#39;)
      return 2;
        else if (ch == L&#39;\r&#39;)
            return 2;
        else if (ch == L&#39; &#39;)
            return 2;
    //TKBlanks
break; // 
        case 3:
        if (ch == L&#39;$&#39;)
            return 3;
    else if (ch &gt;= L&#39;0&#39; &amp;&amp; ch &lt;= L&#39;9&#39;)
      return 14;
    else if (ch &gt;= L&#39;A&#39; &amp;&amp; ch &lt;= L&#39;Z&#39;)
      return 3;
        else if (ch == L&#39;_&#39;)
            return 3;
    else if (ch &gt;= L&#39;a&#39; &amp;&amp; ch &lt;= L&#39;z&#39;)
      return 3;
    //TKIdentifier
break; // 
        case 4:
    //TKOpen
</code></pre>

<p>}}}</p>

<p>===Tokenizer (do not depend on grammar)===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - VersionMar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_13">pragma once</h1>

<p>template &lt; class TDFA,
         class TInputStream &gt;
struct Tokenizer
{
public:
    typedef TInputStream             InputStream;
    typedef typename TDFA::TokenType TokenType;</p>

<p>private:</p>

<pre><code>Tokenizer&amp; operator=(const Tokenizer&amp;); //= deleted

template&lt;class T&gt;
bool NextTokenNoInterleave(T&amp; lexeme, TokenType&amp; tk)
{
    lexeme.clear();
    int lastGoodState = -1;
    int currentState = 0;
    wchar_t ch;

    while (m_InputStream.NextChar(ch))
    {
        currentState = TDFA::GetNext(currentState, ch);

        if (currentState == -1)
        {
            m_InputStream.PutBack(ch);
            break;
        }

        TokenType tk2;

        if (TDFA::GetTokenFromState(currentState, tk2))
        {
            tk = tk2;
            lastGoodState = currentState;
        }

        lexeme.append(1, ch);
    }

    return (lastGoodState != -1);
}
</code></pre>

<p>public:</p>

<pre><code>InputStream&amp; m_InputStream;

Tokenizer(InputStream&amp; stream)
    : m_InputStream(stream)
{
}

template&lt;class T&gt;
bool NextToken(T&amp; lexeme, TokenType&amp; tk)
{
    for (;;)
    {
        if (!NextTokenNoInterleave(lexeme, tk))
        {
            return false;
        }

        if (!TDFA::IsInterleave(tk))
        {
            return true;
        }
    }
}
</code></pre>

<p>};</p>

<p>}}}</p>

<p>===FileStream (do not depend on grammar)==</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - VersionMar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_14">pragma once</h1>

<h1 id="toc_15">include <cstdio></h1>

<h1 id="toc_16">include <cassert></h1>

<p>struct FileStream
{
  typedef const wchar_t* BufferIterator;</p>

<p>wchar<em>t*     m</em>pCharacteres;
  const size<em>t m</em>MaxBufferSize;
  wchar<em>t*     m</em>pCurrentChar;
  FILE*        m<em>hFile;
  size</em>t       m<em>CurrentLine;
  size</em>t       m_CurrentCol;</p>

<p>bool         m<em>HasPutBack;
  wchar</em>t      m_PutBackCharacter;</p>

<p>bool         m_EofSent;</p>

<p>BufferIterator FirstBufferEnd() const
  {
    return m<em>pCharacteres + m</em>MaxBufferSize - 1;
  }</p>

<p>BufferIterator SecondBufferEnd() const
  {
    return m<em>pCharacteres + m</em>MaxBufferSize * 2 - 1;
  }</p>

<p>bool NextCharCore(wchar<em>t&amp; ch)
  {
    if (m</em>HasPutBack)
    {
      ch = m<em>PutBackCharacter;
      m</em>HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }</p>

<pre><code>if (m_EofSent)
  return false;

ch = *m_pCurrentChar++;

if (ch == L&#39;\0&#39;)
{
  ch = &#39;\0&#39;;
  m_EofSent = true;
}
else
{
  if (*m_pCurrentChar == L&#39;\0&#39;)
  {
    if (m_pCurrentChar == FirstBufferEnd())
    {
      wchar_t* pSecondBuffer =
        m_pCharacteres + m_MaxBufferSize;

      size_t r = fread(pSecondBuffer,
                       sizeof(wchar_t),
                       m_MaxBufferSize - 1,
                       m_hFile);
      pSecondBuffer[r] = 0;
      m_pCurrentChar = pSecondBuffer;
    }
    else if (m_pCurrentChar == SecondBufferEnd())
    {
      wchar_t* pFirstBuffer = m_pCharacteres;

      size_t r = fread(pFirstBuffer,
                       sizeof(wchar_t),
                       m_MaxBufferSize - 1,
                       m_hFile);

      pFirstBuffer[r] = 0;
      m_pCurrentChar = pFirstBuffer;
    }
  }
}

assert(m_pCharacteres[m_MaxBufferSize - 1] == 0);
assert(m_pCharacteres[m_MaxBufferSize * 2 - 1] == 0);
return true;
</code></pre>

<p>}</p>

<p>public:</p>

<p>FileStream(const wchar<em>t* fileName, size</em>t bufferSize = 4096)
    : m<em>MaxBufferSize(bufferSize)
    , m</em>CurrentLine(1)
    , m<em>CurrentCol(1)
    , m</em>HasPutBack(false)
    , m<em>PutBackCharacter(L&#39;\0&#39;)
    , m</em>EofSent(false)
  {
    assert(bufferSize &gt;= 2);</p>

<pre><code>//allocate 2 buffers
m_pCharacteres = new wchar_t[m_MaxBufferSize * 2];
m_pCharacteres[m_MaxBufferSize * 2 - 1] = 0;
m_pCharacteres[m_MaxBufferSize - 1] = 0;
m_pCurrentChar = m_pCharacteres;

errno_t err = _wfopen_s(&amp;m_hFile, fileName, L&quot;r,ccs=UTF-8&quot;);

if (err == 0)
{
  size_t r = fread(m_pCharacteres,
                   sizeof(wchar_t),
                   m_MaxBufferSize - 1,
                   m_hFile);

  m_pCharacteres[r] = L&#39;\0&#39;;
}
</code></pre>

<p>}</p>

<p>~FileStream()
  {
    fclose(m<em>hFile);
    delete [] m</em>pCharacteres;
  }</p>

<p>void PutBack(wchar<em>t ch)
  {
    assert(m</em>HasPutBack == false);</p>

<pre><code>if (ch == L&#39;\n&#39;)
{
  if (m_CurrentLine &gt; 1)
  {
    m_CurrentLine--;
  }
}
else
{
  if (m_CurrentCol &gt; 1)
  {
    m_CurrentCol--;
  }
}

m_PutBackCharacter = ch;
m_HasPutBack = true;
</code></pre>

<p>}</p>

<p>bool NextChar(wchar_t&amp; ch)
  {
    bool b = NextCharCore(ch);</p>

<pre><code>if (b &amp;&amp; ch == L&#39;\n&#39;)
{
  m_CurrentLine++;
  m_CurrentCol = 1;
}
else
{
  m_CurrentCol++;
}

return b;
</code></pre>

<p>}</p>

<p>size<em>t GetLine() const
  {
    return m</em>CurrentLine;
  }</p>

<p>size<em>t GetCol() const
  {
    return m</em>CurrentCol;
  }
};</p>

<p>}}}</p>

<p>===StringStream (do not depend on grammar) ===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_17">pragma once</h1>

<p>struct StringStream
{
  const wchar<em>t* m</em>pCharacteres;
  const wchar<em>t* m</em>pCurrentChar;
  size<em>t         m</em>CurrentLine;
  size<em>t         m</em>CurrentCol;
  bool           m<em>HasPutBack;
  wchar</em>t        m<em>PutBackCharacter;
  bool           m</em>EofSent;</p>

<p>bool NextCharCore(wchar<em>t&amp; ch)
  {
    if (m</em>HasPutBack)
    {
      ch = m<em>PutBackCharacter;
      m</em>HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }</p>

<pre><code>if (m_EofSent)
  return false;

ch = *m_pCurrentChar++;

if (ch == L&#39;\0&#39;)
{
  ch = &#39;\0&#39;;
  m_EofSent = true;
}

return true;
</code></pre>

<p>}</p>

<p>public:</p>

<p>StringStream(const wchar<em>t* psz)
    : m</em>pCharacteres(psz)
    , m<em>CurrentLine(1)
    , m</em>CurrentCol(1)
    , m<em>HasPutBack(false)
    , m</em>PutBackCharacter(L&#39;\0&#39;)
    , m<em>EofSent(false)
  {
    m</em>pCurrentChar = m_pCharacteres;
  }</p>

<p>void PutBack(wchar<em>t ch)
  {
    assert(m</em>HasPutBack == false);</p>

<pre><code>if (ch == L&#39;\n&#39;)
{
  if (m_CurrentLine &gt; 1)
  {
    m_CurrentLine--;
  }
}
else
{
  if (m_CurrentCol &gt; 1)
  {
    m_CurrentCol--;
  }
}

m_PutBackCharacter = ch;
m_HasPutBack = true;
</code></pre>

<p>}</p>

<p>bool NextChar(wchar_t&amp; ch)
  {
    bool b = NextCharCore(ch);</p>

<pre><code>if (b &amp;&amp; ch == L&#39;\n&#39;)
{
  m_CurrentLine++;
  m_CurrentCol = 1;
}
else
{
  m_CurrentCol++;
}

return b;
</code></pre>

<p>}</p>

<p>size<em>t GetLine() const
  {
    return m</em>CurrentLine;
  }</p>

<p>size<em>t GetCol() const
  {
    return m</em>CurrentCol;
  }
};
}}}</p>

<p>===SampleProgram.txt (just a sample)===</p>

<p>{{{cpp</p>

<h1 id="toc_18">include &quot;stdafx.h&quot;</h1>

<h1 id="toc_19">include &quot;GrammarFileParser.h&quot;</h1>

<h1 id="toc_20">include <iostream></h1>

<p>int _tmain(int argc, _TCHAR* argv[])
{
  if (argc == 1)
  {
    std::cout &lt;&lt; &quot;missing input file &quot;;
    return 1;
  }</p>

<p>try
  {
    Grammar::Context::InputStream ss(argv[1]);
    Grammar::Context::Scanner scanner(ss);
    Grammar::Context ctx(scanner);
    Grammar::Parse<em>Main(ctx);
  }
  catch (const Grammar::ParserException&amp; e)
  {
    std::cout &lt;&lt; &quot;Error : line, col = &quot; &lt;&lt; e.m</em>Line &lt;&lt; &quot;, &quot; &lt;&lt; e.m_Col &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; e)
  {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }</p>

<p>return 0;
}</p>

<p>}}}</p>

<p>===Modifed SampleParser.h===</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Mar  8 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_21">pragma once</h1>

<h1 id="toc_22">include <cassert></h1>

<h1 id="toc_23">include <string></h1>

<h1 id="toc_24">include &quot;tokenizer.h&quot;</h1>

<h1 id="toc_25">include &quot;Sample2DFA.h&quot;</h1>

<p>//Select the input stream type</p>

<h1 id="toc_26">include &quot;FileStream.h&quot;</h1>

<p>//#include &quot;StringStream.h&quot;
//#include &quot;YourStream.h&quot;</p>

<p>namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken</p>

<pre><code>};


class ParserException : public std::exception
{
public:
    int m_Line;
    int m_Col;
    ErrorCode m_Error;
    ParserException(int line,
                    int col,
                    ErrorCode error)
        : m_Line(line)
        , m_Col(col)
        , m_Error(error)
{
}
};


class Context
{
    public:
    //Select
    typedef FileStream   InputStream;
    //typedef StringStream InputStream;
    //typedef YourStream   InputStream;

    typedef Tokenizer&lt;Sample2::DFA, InputStream&gt; Scanner;

    private:
    Scanner&amp; m_scanner;

    Sample2::Tokens m_CurrentToken;
    std::wstring m_lexeme;

public:
    Context(Scanner&amp; s) : m_scanner(s)
    {
        if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
        {
            throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);
        }
    }

    //returns the current token
    Sample2::Tokens Token() const
    {
         return m_CurrentToken;
    }

    //checks if Token() == tk and then move the current token
    void Match(Sample2::Tokens tk)
    {
         if (tk != m_CurrentToken)
         {
            throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);
         }
         if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
         {
         }
    }

    int GetLine() const
    {
        return m_scanner.m_InputStream.GetLine();
    }

    int GetCol() const
    {
        return m_scanner.m_InputStream.GetCol();
    }

void Action_PrintPlus()
{
  wcout &lt;&lt; L&quot; +&quot;;
}
void Action_PrintMinus()
{
  wcout &lt;&lt; L&quot; -&quot;;
}
void Action_PrintMulti()
{
  wcout &lt;&lt; L&quot; *&quot;;
}
void Action_PrintDiv()
{
  wcout &lt;&lt; L&quot; /&quot;;
}
void Action_PrintPower()
{
  wcout &lt;&lt; L&quot; ^&quot;;
}
void Action_PrintLexeme()
{
  wcout &lt;&lt; L&quot; &quot; &lt;&lt; m_lexeme;
}
void Action_PrintNeg()
{
  wcout &lt;&lt; L&quot; NEG&quot;;
}
void Action_PrintNewLine()
{
    wcout &lt;&lt; std::endl;
}
};



void Parse_Main(Context&amp;);
</code></pre>

<p>} //namespace</p>

<p>}}}</p>
</body></html>