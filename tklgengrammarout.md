
{{{cpp
// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// www.thradams.com
//
// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)
// http://www.thradams.com/
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
#pragma once

#include <string>
#include "tokenizer.h"
#include "Sample1DFA.h"


namespace Sample1
{
    template <class TokenizerStreamT>
    class Context
    {
        typedef Tokenizer<Sample1::DFA, TokenizerStreamT> Scanner;
        Scanner m_scanner;
        
        Sample1::Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
    public:
        Context(TokenizerStreamT& s) : m_scanner(s)
        {
            if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
            {
            }
        }

        Sample1::Tokens Token() const
        {
             return m_CurrentToken;
        }
        
        void Match(Sample1::Tokens tk)
        {
             if (tk != m_CurrentToken)
             {
                 throw std::runtime_error("token not expected");
             }
             if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
             {
             }
        }
        
        void Action_ModuleName()
        {
        }

        void Action_LanguageName()
        {
        }

        void Action_teste()
        {
        }

        void Action_TokenName()
        {
        }

        void Action_TokenEnd()
        {
        }

        void Action_SyntaxName()
        {
        }

        void Action_PrintAnd()
        {
        }

        void Action_PrintOr()
        {
        }

        void Action_PrintOptional()
        {
        }

        void Action_PrintZeroOrMore()
        {
        }

        void Action_PrintOneOrMore()
        {
        }

        void Action_PrintChar()
        {
        }

        void Action_PrintName()
        {
        }

        void Action_PrintAny()
        {
        }

        void Action_PrintString()
        {
        }

        void Action_PrintRange()
        {
        }

        void Action_CloseProduction()
        {
        }

        void Action_PrintEmptyProduction()
        {
        }

        void Action_PrintAction()
        {
        }

    };
    
    
    

  void Parse_Main(Context&);

} //namespace 

}}}
{{{cpp
// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// www.thradams.com
//
// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)
// http://www.thradams.com/
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
#pragma once

#include <string>
#include "tokenizer.h"
#include "Sample1DFA.h"


namespace Sample1
{
    //forward declarations 
    void Parse_ZeroOrMoreOrF(Context&);
    void Parse_OrF(Context&);
    void Parse_ModuleBody(Context&);
    void Parse_LanguageBody(Context&);
    void Parse_Declaration(Context&);
    void Parse_Declarations(Context&);
    void Parse_InterleaveDeclaration(Context&);
    void Parse_TokenExpression(Context&);
    void Parse_TokenDeclaration(Context&);
    void Parse_T(Context&);
    void Parse_ZeroOrMoreT(Context&);
    void Parse_SyntaxExpression(Context&);
    void Parse_SyntaxDeclaration(Context&);
    void Parse_F(Context&);
    void Parse_Main(Context&);
    void Parse_P(Context&);
    void Parse_OptOperator(Context&);
    void Parse_V(Context&);
    void Parse_RangeOpt(Context&);
    void Parse_SyntaxExpressionSingle(Context&);
    void Parse_SyntaxExpressionMoreSingle(Context&);
    void Parse_SyntaxExpressionItem(Context&);
    void Parse_SyntaxExpressionSingleFollow(Context&);
    void Parse_SyntaxExpressionAction(Context&);


    void Parse_ZeroOrMoreOrF(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkSemicolonCharacter)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkVerticalLineCharacter)
        {
            //ZeroOrMoreOrF => OrF ZeroOrMoreOrF 
            Parse_OrF(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkRightParenthesisCharacter)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_OrF(Context& ctx)
    {
        if (ctx.Token() == tkVerticalLineCharacter)
        {
            //OrF => VerticalLineCharacter F 
            ctx.Match(tkVerticalLineCharacter);
            Parse_F(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_ModuleBody(Context& ctx)
    {
        if (ctx.Token() == tkKeywordModule)
        {
            //ModuleBody => KeywordModule Identifier LeftCurlyBracketCharacter LanguageBody RightCurlyBracketCharacter 
            ctx.Match(tkKeywordModule);
            ctx.Match(tkIdentifier);
            ctx.Match(tkLeftCurlyBracketCharacter);
            Parse_LanguageBody(ctx);
            ctx.Match(tkRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_LanguageBody(Context& ctx)
    {
        if (ctx.Token() == tkKeywordLanguage)
        {
            //LanguageBody => KeywordLanguage Identifier LeftCurlyBracketCharacter Declarations RightCurlyBracketCharacter 
            ctx.Match(tkKeywordLanguage);
            ctx.Match(tkIdentifier);
            ctx.Match(tkLeftCurlyBracketCharacter);
            Parse_Declarations(ctx);
            ctx.Match(tkRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_Declaration(Context& ctx)
    {
        if (ctx.Token() == tkKeywordInterleave)
        {
            //Declaration => InterleaveDeclaration 
            Parse_InterleaveDeclaration(ctx);
        }
        else if (ctx.Token() == tkKeywordToken)
        {
            //Declaration => TokenDeclaration 
            Parse_TokenDeclaration(ctx);
        }
        else if (ctx.Token() == tkKeywordSyntax)
        {
            //Declaration => SyntaxDeclaration 
            Parse_SyntaxDeclaration(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_Declarations(Context& ctx)
    {
        if (ctx.Token() == tkKeywordInterleave)
        {
            //Declarations => Declaration Declarations 
            Parse_Declaration(ctx);
            Parse_Declarations(ctx);
        }
        else if (ctx.Token() == tkKeywordToken)
        {
            //Declarations => Declaration Declarations 
            Parse_Declaration(ctx);
            Parse_Declarations(ctx);
        }
        else if (ctx.Token() == tkKeywordSyntax)
        {
            //Declarations => Declaration Declarations 
            Parse_Declaration(ctx);
            Parse_Declarations(ctx);
        }
        else if (ctx.Token() == tkRightCurlyBracketCharacter)
        {
            //Declarations => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_InterleaveDeclaration(Context& ctx)
    {
        if (ctx.Token() == tkKeywordInterleave)
        {
            //InterleaveDeclaration => KeywordInterleave Identifier EqualsCharacter TokenExpression SemicolonCharacter 
            ctx.Match(tkKeywordInterleave);
            ctx.Match(tkIdentifier);
            ctx.Match(tkEqualsCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tkSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_TokenExpression(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_TokenDeclaration(Context& ctx)
    {
        if (ctx.Token() == tkKeywordToken)
        {
            //TokenDeclaration => KeywordToken Identifier EqualsCharacter TokenExpression SemicolonCharacter 
            ctx.Match(tkKeywordToken);
            ctx.Match(tkIdentifier);
            ctx.Match(tkEqualsCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tkSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_T(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_ZeroOrMoreT(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkSemicolonCharacter)
        {
            //ZeroOrMoreT => Epsilon 
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tkRightParenthesisCharacter)
        {
            //ZeroOrMoreT => Epsilon 
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpression(Context& ctx)
    {
        if (ctx.Token() == tkKeywordEmpty)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else if (ctx.Token() == tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxDeclaration(Context& ctx)
    {
        if (ctx.Token() == tkKeywordSyntax)
        {
            //SyntaxDeclaration => KeywordSyntax Identifier EqualsCharacter SyntaxExpression SemicolonCharacter 
            ctx.Match(tkKeywordSyntax);
            ctx.Match(tkIdentifier);
            ctx.Match(tkEqualsCharacter);
            Parse_SyntaxExpression(ctx);
            ctx.Match(tkSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_F(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_Main(Context& ctx)
    {
        if (ctx.Token() == tkKeywordModule)
        {
            //Main => ModuleBody 
            Parse_ModuleBody(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_P(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //P => V 
            Parse_V(ctx);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //P => V 
            Parse_V(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //P => V 
            Parse_V(ctx);
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //P => LeftParenthesisCharacter TokenExpression RightParenthesisCharacter 
            ctx.Match(tkLeftParenthesisCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tkRightParenthesisCharacter);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //P => V 
            Parse_V(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_OptOperator(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkPlusCharacter)
        {
            //OptOperator => PlusCharacter 
            ctx.Match(tkPlusCharacter);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkSemicolonCharacter)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkQuestionMarkCharacter)
        {
            //OptOperator => QuestionMarkCharacter 
            ctx.Match(tkQuestionMarkCharacter);
        }
        else if (ctx.Token() == tkAsteriskCharacter)
        {
            //OptOperator => AsteriskCharacter 
            ctx.Match(tkAsteriskCharacter);
        }
        else if (ctx.Token() == tkVerticalLineCharacter)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkRightParenthesisCharacter)
        {
            //OptOperator => Epsilon 
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //OptOperator => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_V(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //V => KeywordAny 
            ctx.Match(tkKeywordAny);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //V => LiteralChar RangeOpt 
            ctx.Match(tkLiteralChar);
            Parse_RangeOpt(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //V => Identifier 
            ctx.Match(tkIdentifier);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //V => StringLiteral 
            ctx.Match(tkStringLiteral);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_RangeOpt(Context& ctx)
    {
        if (ctx.Token() == tkKeywordAny)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkRangeSeparator)
        {
            //RangeOpt => RangeSeparator LiteralChar 
            ctx.Match(tkRangeSeparator);
            ctx.Match(tkLiteralChar);
        }
        else if (ctx.Token() == tkPlusCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkSemicolonCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkQuestionMarkCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkAsteriskCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkVerticalLineCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkLeftParenthesisCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkRightParenthesisCharacter)
        {
            //RangeOpt => Epsilon 
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //RangeOpt => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionSingle(Context& ctx)
    {
        if (ctx.Token() == tkKeywordEmpty)
        {
            //SyntaxExpressionSingle => KeywordEmpty 
            ctx.Match(tkKeywordEmpty);
        }
        else if (ctx.Token() == tkLiteralChar)
        {
            //SyntaxExpressionSingle => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //SyntaxExpressionSingle => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionSingle => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //SyntaxExpressionSingle => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionMoreSingle(Context& ctx)
    {
        if (ctx.Token() == tkSemicolonCharacter)
        {
            //SyntaxExpressionMoreSingle => Epsilon 
        }
        else if (ctx.Token() == tkVerticalLineCharacter)
        {
            //SyntaxExpressionMoreSingle => VerticalLineCharacter SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            ctx.Match(tkVerticalLineCharacter);
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionItem(Context& ctx)
    {
        if (ctx.Token() == tkLiteralChar)
        {
            //SyntaxExpressionItem => LiteralChar 
            ctx.Match(tkLiteralChar);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //SyntaxExpressionItem => Identifier 
            ctx.Match(tkIdentifier);
        }
        else if (ctx.Token() == tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionItem => SyntaxExpressionAction 
            Parse_SyntaxExpressionAction(ctx);
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //SyntaxExpressionItem => StringLiteral 
            ctx.Match(tkStringLiteral);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionSingleFollow(Context& ctx)
    {
        if (ctx.Token() == tkLiteralChar)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkIdentifier)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tkSemicolonCharacter)
        {
            //SyntaxExpressionSingleFollow => Epsilon 
        }
        else if (ctx.Token() == tkVerticalLineCharacter)
        {
            //SyntaxExpressionSingleFollow => Epsilon 
        }
        else if (ctx.Token() == tkStringLiteral)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionAction(Context& ctx)
    {
        if (ctx.Token() == tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionAction => LeftCurlyBracketCharacter Identifier RightCurlyBracketCharacter 
            ctx.Match(tkLeftCurlyBracketCharacter);
            ctx.Match(tkIdentifier);
            ctx.Match(tkRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }
} //namespace Sample1

}}}