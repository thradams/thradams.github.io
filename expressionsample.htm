
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<p></p>

<p>==Tutorial and sample==</p>

<p>This sample parse expressions.</p>

<p>This <strong>is not the tklgen grammar</strong> but it helps to think how to build LL1 grammars.</p>


<p>The brackets The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. The unquoted parentheses ( and ) serve only to group elements in a production.)</p>

<p>{{{  E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}  T --&gt; F {( &quot;  F --&gt; P   P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T}}}</p>


<p>Now lets see how to build a tklgen LL1 grammar:</p>

<p>===grammar.txt===</p>

<p>{{{cpp</p>

<p>module Sample2{  language Sample2   {    token Plus = '+';    token Minus = '-';    token Multi = '    token Div = '/';    token Power = '^';    token Open = '(';    token Close = ')';    token End = ';';    token EndMark = '\0';    token Integer   = ('0'..'9')+;    token Identifier   = ('a'..'z' | 'A'..'Z' | '                       ('0'..'9' + ('a'..'z' | 'A'..'Z' | '</p>

<p>    interleave Blanks  = (&quot; &quot; | &quot;\n&quot; | &quot;\t&quot; | &quot;\r&quot;) +;</p>


<p>    syntax Main = Expressions;    syntax Expression = E ';' {PrintNewLine};    syntax Expressions = Expression Expressions | empty;</p>

<p>    // E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}    syntax E = T E2;    syntax E2 = '+' T {PrintPlus} E2 |                '-' T {PrintMinus} E2 |                empty;</p>

<p>    // T --&gt; F {( &quot;    syntax T = F T2;    syntax T2 = '                '/' F {PrintDiv}T2|                empty;</p>

<p>    // F --&gt; P     syntax F = P FOpt;    syntax FOpt = '^' F {PrintPower} | empty;</p>

<p>    // P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T    syntax P = {PrintLexeme} Integer |               {PrintLexeme} Identifier |                '(' E ')' |                '-' T {PrintNeg};      }}</p>

<p>}}}</p>

<p>Use this command line:</p>

<p>{{{ tklgen grammar.txt}}}</p>

<p>The files below will be generated:</p>

<p>{{{ Sample2Parser.h Sample2Parser.cpp Sample2DFA.h}}}</p>


<p>The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.</p>

<p>{{{Tokenizer.hFileStream.hStringStream.hSampleProgram.txt}}}</p>


<p>===Sample2Parser.h===</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// Generated by TKLGEN - Version Mar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>
<h1>pragma once</h1>

<h1>include <cassert></h1>
<h1>include <string></h1>
<h1>include "tokenizer.h"</h1>
<h1>include "Sample2DFA.h"</h1>

<p>//Select the input stream type</p>
<h1>include "FileStream.h"</h1>
<p>////</p>


<p>namespace Sample2{    enum ErrorCode    {        ErrorCodeUnexpectedEof,        ErrorCodeUnexpectedToken</p>

<p>    };</p>


<p>    class ParserException : public std::exception    {    public:        int m        int m        ErrorCode m        ParserException(int line,                        int col,                        ErrorCode error)            : m            , m            , m    {    }    };</p>


<p>    class Context    {        public:        //Select        typedef FileStream   InputStream;        //typedef StringStream InputStream;        //typedef YourStream   InputStream;</p>

<p>        typedef Tokenizer&lt;Sample2::DFA, InputStream&gt; Scanner;</p>

<p>        private:        Scanner&amp; m</p>

<p>        Sample2::Tokens m        std::wstring m</p>

<p>    public:        Context(Scanner&amp; s) : m        {            if (            {                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);            }        }</p>

<p>        //returns the current token        Sample2::Tokens Token() const        {             return m        }</p>

<p>        //checks if Token() == tk and then move the current token        void Match(Sample2::Tokens tk)        {             if (tk              {                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);             }             if (             {             }        }</p>

<p>        int GetLine() const        {            return m        }</p>

<p>        int GetCol() const        {            return m        }        void Action        void Action        void Action        void Action        void Action        void Action        void Action        void Action    };</p>



<p>    void Parse} //namespace</p>


<p>}}}</p>

<p>===Sample2Parser.cpp===</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// Generated by TKLGEN - Version Mar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>

<h1>include <cassert></h1>
<h1>include <string></h1>
<h1>include "tokenizer.h"</h1>
<h1>include "Sample2DFA.h"</h1>
<h1>include "Sample2Parser.h"</h1>


<p>namespace Sample2{    //forward declarations     void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse    void Parse</p>


<p>    void Parse    {        if (ctx.Token() == TKEndMark ||            ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //Main =&gt; Expressions             Parse        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //Expressions =&gt; Expression Expressions             Parse            Parse        }        else if (ctx.Token() == TKEndMark)        {            //Expressions =&gt; Epsilon         }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //Expression =&gt; E End             Parse            ctx.Match(TKEnd);            ctx.Action        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //E =&gt; T E2             Parse            Parse        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //T =&gt; F T2             Parse            Parse        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKPlus)        {            //E2 =&gt; Plus T E2             ctx.Match(TKPlus);            Parse            ctx.Action            Parse        }        else if (ctx.Token() == TKMinus)        {            //E2 =&gt; Minus T E2             ctx.Match(TKMinus);            Parse            ctx.Action            Parse        }        else if (ctx.Token() == TKClose ||            ctx.Token() == TKEnd)        {            //E2 =&gt; Epsilon         }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMinus ||            ctx.Token() == TKOpen ||            ctx.Token() == TKInteger ||            ctx.Token() == TKIdentifier)        {            //F =&gt; P FOpt             Parse            Parse        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKMulti)        {            //T2 =&gt; Multi F T2             ctx.Match(TKMulti);            Parse            ctx.Action            Parse        }        else if (ctx.Token() == TKDiv)        {            //T2 =&gt; Div F T2             ctx.Match(TKDiv);            Parse            ctx.Action            Parse        }        else if (ctx.Token() == TKPlus ||            ctx.Token() == TKMulti ||            ctx.Token() == TKMinus ||            ctx.Token() == TKDiv ||            ctx.Token() == TKPower ||            ctx.Token() == TKClose ||            ctx.Token() == TKEnd)        {            //T2 =&gt; Epsilon         }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKInteger)        {            //P =&gt; Integer             ctx.Action            ctx.Match(TKInteger);        }        else if (ctx.Token() == TKIdentifier)        {            //P =&gt; Identifier             ctx.Action            ctx.Match(TKIdentifier);        }        else if (ctx.Token() == TKOpen)        {            //P =&gt; Open E Close             ctx.Match(TKOpen);            Parse            ctx.Match(TKClose);        }        else if (ctx.Token() == TKMinus)        {            //P =&gt; Minus T             ctx.Match(TKMinus);            Parse            ctx.Action        }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>    void Parse    {        if (ctx.Token() == TKPower)        {            //FOpt =&gt; Power F             ctx.Match(TKPower);            Parse            ctx.Action        }        else if (ctx.Token() == TKPlus ||            ctx.Token() == TKMulti ||            ctx.Token() == TKMinus ||            ctx.Token() == TKDiv ||            ctx.Token() == TKPower ||            ctx.Token() == TKClose ||            ctx.Token() == TKEnd)        {            //FOpt =&gt; Epsilon         }        else        {            throw ParserException(ctx.GetLine(), ctx.GetCol(), ErrorCodeUnexpectedToken);        }    }</p>

<p>} //namespace Sample2</p>

<p>}}}</p>

<p>===Sample2DFA.h===</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// Generated by TKLGEN - Version Mar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>
<h1>ifndef __SAMPLE2DFA_H__</h1>
<h1>define __SAMPLE2DFA_H__</h1>

<p>namespace Sample2{</p>

<p>enum Tokens{    TKPlus,    TKMinus,    TKMulti,    TKDiv,    TKPower,    TKOpen,    TKClose,    TKEnd,    TKEndMark,    TKInteger,    TKIdentifier,    TKBlanks,};</p>

<p>inline const wchar{    switch(e)    {    case TKPlus: return L&quot;Plus&quot;;    case TKMinus: return L&quot;Minus&quot;;    case TKMulti: return L&quot;Multi&quot;;    case TKDiv: return L&quot;Div&quot;;    case TKPower: return L&quot;Power&quot;;    case TKOpen: return L&quot;Open&quot;;    case TKClose: return L&quot;Close&quot;;    case TKEnd: return L&quot;End&quot;;    case TKEndMark: return L&quot;EndMark&quot;;    case TKInteger: return L&quot;Integer&quot;;    case TKIdentifier: return L&quot;Identifier&quot;;    case TKBlanks: return L&quot;Blanks&quot;;    default:break;    }    return L&quot;&quot;;}</p>

<p>struct DFA{    typedef Tokens TokenType;</p>

<p>    static int GetNext(int state, wchar    {        switch (state)        {            case 0:            if (ch == L'\0')                return 1;        else if (ch &gt;= L'\t' &amp;&amp; ch &lt;= L'\n')          return 2;            else if (ch == L'\r')                return 2;            else if (ch == L' ')                return 2;            else if (ch == L'$')                return 3;            else if (ch == L'(')                return 4;            else if (ch == L')')                return 5;            else if (ch == L'                return 6;            else if (ch == L'+')                return 7;            else if (ch == L'-')                return 8;            else if (ch == L'/')                return 9;        else if (ch &gt;= L'0' &amp;&amp; ch &lt;= L'9')          return 10;            else if (ch == L';')                return 11;        else if (ch &gt;= L'A' &amp;&amp; ch &lt;= L'Z')          return 3;            else if (ch == L'^')                return 12;            else if (ch == L'                return 3;        else if (ch &gt;= L'a' &amp;&amp; ch &lt;= L'z')           return 3;    break; //             case 1:        //TKEndMark    break; //             case 2:        if (ch &gt;= L'\t' &amp;&amp; ch &lt;= L'\n')          return 2;            else if (ch == L'\r')                return 2;            else if (ch == L' ')                return 2;        //TKBlanks    break; //             case 3:            if (ch == L'$')                return 3;        else if (ch &gt;= L'0' &amp;&amp; ch &lt;= L'9')          return 14;        else if (ch &gt;= L'A' &amp;&amp; ch &lt;= L'Z')          return 3;            else if (ch == L'                return 3;        else if (ch &gt;= L'a' &amp;&amp; ch &lt;= L'z')          return 3;        //TKIdentifier    break; //             case 4:        //TKOpen</p>

<p>}}}</p>



<p>===Tokenizer (do not depend on grammar)===</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// TKLGEN - VersionMar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>


<h1>pragma once</h1>

<p>template &lt; class TDFA,         class TInputStream &gt;struct Tokenizer{public:    typedef TInputStream             InputStream;    typedef typename TDFA::TokenType TokenType;</p>

<p>private:</p>


<p>    Tokenizer&amp; operator=(const Tokenizer&amp;); //= deleted</p>

<p>    template&lt;class T&gt;    bool NextTokenNoInterleave(T&amp; lexeme, TokenType&amp; tk)    {        lexeme.clear();        int lastGoodState = -1;        int currentState = 0;        wchar</p>

<p>        while (m        {            currentState = TDFA::GetNext(currentState, ch);</p>

<p>            if (currentState == -1)            {                m                break;            }</p>

<p>            TokenType tk2;</p>

<p>            if (TDFA::GetTokenFromState(currentState, tk2))            {                tk = tk2;                lastGoodState = currentState;            }</p>

<p>            lexeme.append(1, ch);        }</p>

<p>        return (lastGoodState     }</p>


<p>public:</p>

<p>    InputStream&amp; m</p>

<p>    Tokenizer(InputStream&amp; stream)        : m    {    }</p>

<p>    template&lt;class T&gt;    bool NextToken(T&amp; lexeme, TokenType&amp; tk)    {        for (;;)        {            if (            {                return false;            }</p>

<p>            if (            {                return true;            }        }    }};</p>


<p>}}}</p>

<p>===FileStream (do not depend on grammar)==</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// TKLGEN - VersionMar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>


<h1>pragma once</h1>

<h1>include <cstdio></h1>
<h1>include <cassert></h1>

<p>struct FileStream{  typedef const wchar</p>

<p>  wchar  const size  wchar  FILE  size  size</p>

<p>  bool         m  wchar</p>

<p>  bool         m</p>

<p>  BufferIterator FirstBufferEnd() const  {    return m  }</p>

<p>  BufferIterator SecondBufferEnd() const  {    return m  }</p>

<p>  bool NextCharCore(wchar  {    if (m    {      ch = m      m      m      return true;    }</p>

<p>    if (m      return false;</p>

<p>    ch = </p>

<p>    if (ch == L'\0')    {      ch = '\0';      m    }    else    {      if (      {        if (m        {          wchar            m</p>

<p>          size                           sizeof(wchar                           m                           m          pSecondBuffer          m        }        else if (m        {          wchar</p>

<p>          size                           sizeof(wchar                           m                           m</p>

<p>          pFirstBuffer          m        }      }    }</p>

<p>    assert(m    assert(m    return true;  }</p>

<p>public:</p>

<p>  FileStream(const wchar    : m    , m    , m    , m    , m    , m  {    assert(bufferSize &gt;= 2);</p>

<p>    //allocate 2 buffers    m    m    m    m</p>

<p>    errno</p>

<p>    if (err == 0)    {      size                       sizeof(wchar                       m                       m</p>

<p>      m    }  }</p>

<p>  ~FileStream()  {    fclose(m    delete   }</p>

<p>  void PutBack(wchar  {    assert(m</p>

<p>    if (ch == L'\n')    {      if (m      {        m      }    }    else    {      if (m      {        m      }    }</p>

<p>    m    m  }</p>

<p>  bool NextChar(wchar  {    bool b = NextCharCore(ch);</p>

<p>    if (b &amp;&amp; ch == L'\n')    {      m      m    }    else    {      m    }</p>

<p>    return b;  }</p>

<p>  size  {    return m  }</p>

<p>  size  {    return m  }};</p>

<p>}}}</p>

<p>===StringStream (do not depend on grammar) ===</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// TKLGEN - Version Mar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>

<h1>pragma once</h1>

<p>struct StringStream{  const wchar  const wchar  size  size  bool           m  wchar  bool           m</p>

<p>  bool NextCharCore(wchar  {    if (m    {      ch = m      m      m      return true;    }</p>

<p>    if (m      return false;</p>

<p>    ch = </p>

<p>    if (ch == L'\0')    {      ch = '\0';      m    }</p>

<p>    return true;  }</p>

<p>public:</p>

<p>  StringStream(const wchar    : m    , m    , m    , m    , m    , m  {    m  }</p>

<p>  void PutBack(wchar  {    assert(m</p>

<p>    if (ch == L'\n')    {      if (m      {        m      }    }    else    {      if (m      {        m      }    }</p>

<p>    m    m  }</p>

<p>  bool NextChar(wchar  {    bool b = NextCharCore(ch);</p>

<p>    if (b &amp;&amp; ch == L'\n')    {      m      m    }    else    {      m    }</p>

<p>    return b;  }</p>

<p>  size  {    return m  }</p>

<p>  size  {    return m  }};}}}</p>


<p>===SampleProgram.txt (just a sample)===</p>


<p>{{{cpp</p>

<h1>include "stdafx.h"</h1>
<h1>include "GrammarFileParser.h"</h1>
<h1>include <iostream></h1>

<p>int {  if (argc == 1)  {    std::cout &lt;&lt; &quot;missing input file &quot;;    return 1;  }</p>

<p>  try  {    Grammar::Context::InputStream ss(argv    Grammar::Context::Scanner scanner(ss);    Grammar::Context ctx(scanner);    Grammar::Parse  }  catch (const Grammar::ParserException&amp; e)  {    std::cout &lt;&lt; &quot;Error : line, col = &quot; &lt;&lt; e.m  }  catch (const std::exception&amp; e)  {    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  }</p>

<p>  return 0;}</p>

<p>}}}</p>


<p>===Modifed SampleParser.h===</p>


<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// Generated by TKLGEN - Version Mar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>
<h1>pragma once</h1>

<h1>include <cassert></h1>
<h1>include <string></h1>
<h1>include "tokenizer.h"</h1>
<h1>include "Sample2DFA.h"</h1>

<p>//Select the input stream type</p>
<h1>include "FileStream.h"</h1>
<p>////</p>


<p>namespace Sample2{    enum ErrorCode    {        ErrorCodeUnexpectedEof,        ErrorCodeUnexpectedToken</p>

<p>    };</p>


<p>    class ParserException : public std::exception    {    public:        int m        int m        ErrorCode m        ParserException(int line,                        int col,                        ErrorCode error)            : m            , m            , m    {    }    };</p>


<p>    class Context    {        public:        //Select        typedef FileStream   InputStream;        //typedef StringStream InputStream;        //typedef YourStream   InputStream;</p>

<p>        typedef Tokenizer&lt;Sample2::DFA, InputStream&gt; Scanner;</p>

<p>        private:        Scanner&amp; m</p>

<p>        Sample2::Tokens m        std::wstring m</p>

<p>    public:        Context(Scanner&amp; s) : m        {            if (            {                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedEof);            }        }</p>

<p>        //returns the current token        Sample2::Tokens Token() const        {             return m        }</p>

<p>        //checks if Token() == tk and then move the current token        void Match(Sample2::Tokens tk)        {             if (tk              {                throw ParserException(GetLine(), GetCol(), ErrorCodeUnexpectedToken);             }             if (             {             }        }</p>

<p>        int GetLine() const        {            return m        }</p>

<p>        int GetCol() const        {            return m        }</p>

<p>    void Action    {      wcout &lt;&lt; L&quot; +&quot;;    }    void Action    {      wcout &lt;&lt; L&quot; -&quot;;    }    void Action    {      wcout &lt;&lt; L&quot;     }    void Action    {      wcout &lt;&lt; L&quot; /&quot;;    }    void Action    {      wcout &lt;&lt; L&quot; ^&quot;;    }    void Action    {      wcout &lt;&lt; L&quot; &quot; &lt;&lt; m    }    void Action    {      wcout &lt;&lt; L&quot; NEG&quot;;    }    void Action    {        wcout &lt;&lt; std::endl;    }    };</p>



<p>    void Parse} //namespace</p>


<p>}}}</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  