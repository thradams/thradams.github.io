<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<a class = "linkbox" href = "codeblog.html">CODE-BLOG</a>
<a class = "linkbox" href = "about.html">ABOUT </a>
<p>Tokenizer.h</p>

<p>{{{cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (<a href="mailto:thiago.adams@gmail.com">thiago.adams@gmail.com</a>)
// <a href="http://www.thradams.com">www.thradams.com</a>
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided &quot;as is&quot; without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////</p>

<h1 id="toc_0">pragma once</h1>

<p>inline void Clear(std::wstring&amp; ws)
{
    ws.clear();
}</p>

<p>inline void Append(std::wstring&amp; ws, wchar_t ch)
{
    ws.append(1, ch);
}</p>

<p>inline void Clear(std::string&amp; ws)
{
    ws.clear();
}</p>

<p>inline void Append(std::string&amp; ws, char ch)
{
    ws.append(1, ch);
}</p>

<p>template &lt; class TDFA,
         class T,
         class TInputStream &gt;
bool NextTokenNoInterleave(TInputStream&amp; stream,
                           T&amp; lexeme,
                           typename TDFA::TokenType&amp; tk)
{
    Clear(lexeme);
    int lastGoodState = -1;
    int currentState = 0;
    wchar_t ch;</p>

<pre><code>while (GetChar(stream, ch))
{
    currentState = TDFA::GetNext(currentState, ch);

    if (currentState == -1)
    {
        PutBack(stream, ch);
        break;
    }

    typename TDFA::TokenType tk2;

    if (TDFA::GetTokenFromState(currentState, tk2))
    {
        tk = tk2;
        lastGoodState = currentState;
    }

    Append(lexeme, ch);
}

return (lastGoodState != -1);
</code></pre>

<p>}</p>

<p>template &lt; class TDFA,
         class T,
         class TInputStream &gt;
bool NextToken(TInputStream&amp; stream,
               T&amp; lexeme,
               typename TDFA::TokenType&amp; tk)
{
    for (;;)
    {
        if (!NextTokenNoInterleave<TDFA>(stream, lexeme, tk))
        {
            return false;
        }</p>

<pre><code>    if (!TDFA::IsInterleave(tk))
    {
        return true;
    }
}
</code></pre>

<p>}</p>

<p>}}}</p>

<p>Sample</p>

<p>{{{cpp</p>

<h1 id="toc_1">include &quot;stdafx.h&quot;</h1>

<h1 id="toc_2">include &quot;ExpressionsParser.h&quot;</h1>

<h1 id="toc_3">include <iostream></h1>

<p>const wchar_t* IntToLiteral(int i)
{
  switch (i)
  {
    case &#39;\0&#39;: return L&quot;\0&quot;;
    case &#39;\r&#39;: return L&quot;\r&quot;;
    case &#39;\n&#39;:return L&quot;\n&quot;;
    case &#39;\t&#39;:return L&quot;\t&quot;;
    case &#39;\&#39;&#39;:return L&quot;\&#39;&quot;;
    case &#39;&quot;&#39;:return L&quot;\&quot;&quot;;
    case &#39;\?&#39;:return L&quot;\?&quot;;
    case &#39;\&#39;:return L&quot;\\&quot;;
    case &#39;\a&#39;:return L&quot;\a&quot;;
    case &#39;\b&#39;:return L&quot;\b&quot;;
    case &#39;\f&#39;:return L&quot;\f&quot;;
    case &#39;\v&#39;:return L&quot;\v&quot;;
  }</p>

<p>static wchar<em>t ch[2] = {0, 0};
  ch[0] = wchar</em>t(i);
  return ch;
}</p>

<p>void PrintLiteral(const std::wstring&amp; ws)
{
  if (ws.empty())
  {
    std::wcout &lt;&lt; &quot;&#39;\0&#39;&quot;;<br>
  }
  else
  {
    std::wcout &lt;&lt; &quot;&quot;&quot;;
    for (size_t i = 0 ; i &lt; ws.size() ; i++)
    {
      std::wcout &lt;&lt; IntToLiteral(ws[i]);
    }
    std::wcout  &lt;&lt; &quot;&quot;&quot;;
  }
}</p>

<p>template<class Language, class Stream>
void PrintTokens(Stream&amp; stream)
{<br>
    std::wstring lexeme;
    typename Language::TokenType token;</p>

<pre><code>while (NextToken&lt;Language&gt;(stream, lexeme, token))    
{ 
  std::wcout.width(15);
  std::wcout &lt;&lt;  TokensToString(token);
  std::wcout &lt;&lt; L&quot; : &quot;;
  PrintLiteral(lexeme.c_str());
  std::wcout &lt;&lt; std::endl;
}
</code></pre>

<p>}</p>

<p>int _tmain(int argc, _TCHAR* argv[])
{
  if (argc == 1)
  {
    std::cout &lt;&lt; &quot;missing input file &quot;;
    return 1;
  }</p>

<p>try
  {
    FileStream ss(argv[1]);
    PrintTokens<a href="Expressions::DFA">Expressions::DFA</a>(ss);<br>
  }
  catch (const Expressions::ParserException&amp; e)
  {
    std::cout &lt;&lt; &quot;Error : line, col = &quot; &lt;&lt; e.m<em>Line &lt;&lt; &quot;, &quot; &lt;&lt; e.m</em>Col &lt;&lt; std::endl;
  }
  catch (const std::exception&amp; e)
  {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }</p>

<p>return 0;
}</p>

<p>}}}</p>
</body></html>