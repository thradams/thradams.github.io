<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h2>Function wrapper testing the class invariant</h2>

<p>Using functions wrappers to test the class invariant Search for: Wrapping C++ Member Function Calls - Bjarne Stroustrup This code is an application for this function wrapper.</p>

<pre>

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pref, <span class="keyword">class</span> Suf&gt; <span class="keyword">class</span> Wrap;

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Suf&gt;
<span class="keyword">class</span> Call_proxy {
  T* p;
  <span class="keyword">mutable</span> <span class="keyword">bool</span> own;
  Suf suffix;
  Call_proxy(T* pp, Suf su) :p(pp) , own(<span class="keyword">true</span>) , suffix(su) { } <span class="comment">// restrict creation
</span>    Call_proxy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Call_proxy&amp;) ; <span class="comment">// prevent assignment
</span><span class="keyword">public</span>:
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> U, <span class="keyword">class</span> P, <span class="keyword">class</span> S&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Wrap;
  Call_proxy(<span class="keyword">const</span> Call_proxy&amp; a) : p(a.p) , own(<span class="keyword">true</span>) , suffix(a.suffix) { a.own=<span class="keyword">false</span>; }
  ~Call_proxy() { <span class="keyword">if</span> (own) suffix() ; }
  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> { <span class="keyword">return</span> p; }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pref, <span class="keyword">class</span> Suf&gt;
<span class="keyword">class</span> Wrap {
  T* p;
  <span class="keyword">int</span>* owned;
  <span class="keyword">void</span> incr_owned() <span class="keyword">const</span> { <span class="keyword">if</span> (owned) ++*owned; }
  <span class="keyword">void</span> decr_owned() <span class="keyword">const</span> { <span class="keyword">if</span> (owned &amp;&amp; --*owned == <span class="number">0</span>) { <span class="keyword">delete</span> p; <span class="keyword">delete</span> owned; } }
  Pref prefix;
  Suf suffix;
<span class="keyword">public</span>:
  Wrap(T&amp; x, Pref pr, Suf su) :p(&amp;x) , owned(<span class="number">0</span>) , prefix(pr) , suffix(su) { }
  Wrap(T* pp, Pref pr, Suf su) :p(pp) , owned(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) , prefix(pr) , suffix(su) { }
  Wrap(<span class="keyword">const</span> Wrap&amp; a)
    :p(a.p) , owned(a.owned) , prefix(a.prefix) , suffix(a.suffix) { incr_owned() ; }
  Wrap&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Wrap&amp; a)
  {
    a.incr_owned() ;
    decr_owned() ;
    p = a.p;
    owned = a.owned;
    prefix = a.prefix;
    suffix = a.suffix;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
  }
  ~Wrap() { decr_owned() ; }
  Call_proxy&lt;T,Suf&gt; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> { prefix() ; <span class="keyword">return</span> Call_proxy&lt;T,Suf&gt;(p,suffix) ; }
  T* direct() <span class="keyword">const</span> { <span class="keyword">return</span> p; } <span class="comment">// extract pointer to wrapped object
</span>};


<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">struct</span> Invariant
{
  T * m_p;
  Invariant(T * p) : m_p(p){}
  <span class="keyword">void</span> <span class="keyword">operator</span>()() <span class="keyword">const</span>
  {
    m_p-&gt;Invariant();
  }
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">struct</span> TestInvariant : <span class="keyword">public</span> Wrap&lt;T, Invariant&lt;T&gt;, Invariant&lt;T&gt;&gt;
{
  TestInvariant(T &amp;x) :  Wrap(x, Invariant&lt;T&gt;(&amp;x), Invariant&lt;T&gt;(&amp;x))
  {
  }

};

<span class="keyword">struct</span> X
{
  <span class="keyword">void</span> Invariant()
  {
    cout &lt;&lt; <span class="string">&quot;X::Invariant\n&quot;</span>;
  }
  <span class="keyword">void</span> F()
  {
    cout &lt;&lt; <span class="string">&quot;X::F\n&quot;</span>;
  }
};

<span class="keyword">int</span> main() <span class="comment">// test program
</span>{
  X x;
  TestInvariant&lt;X&gt; wx(x);
  wx-&gt;F();
  <span class="keyword">return</span> <span class="number">0</span>;
}

</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  