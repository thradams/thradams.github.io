
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<p>Tokenizer.h</p>

<p>{{{cpp//////////////////////////////////////////////////////////////////////////////// Generated by TKLGEN - Version Sep 27 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>

<h1>pragma once</h1>

<p>inline void Clear(std::wstring&amp; ws){    ws.clear();}</p>

<p>inline void Append(std::wstring&amp; ws, wchar{    ws.append(1, ch);}</p>


<p>inline void Clear(std::string&amp; ws){    ws.clear();}</p>

<p>inline void Append(std::string&amp; ws, char ch){    ws.append(1, ch);}</p>

<p>template &lt; class TDFA,         class T,         class TInputStream &gt;bool NextTokenNoInterleave(TInputStream&amp; stream,                           T&amp; lexeme,                           typename TDFA::TokenType&amp; tk){    Clear(lexeme);    int lastGoodState = -1;    int currentState = 0;    wchar</p>

<p>    while (GetChar(stream, ch))    {        currentState = TDFA::GetNext(currentState, ch);</p>

<p>        if (currentState == -1)        {            PutBack(stream, ch);            break;        }</p>

<p>        typename TDFA::TokenType tk2;</p>

<p>        if (TDFA::GetTokenFromState(currentState, tk2))        {            tk = tk2;            lastGoodState = currentState;        }</p>

<p>        Append(lexeme, ch);    }</p>

<p>    return (lastGoodState }</p>

<p>template &lt; class TDFA,         class T,         class TInputStream &gt;bool NextToken(TInputStream&amp; stream,               T&amp; lexeme,               typename TDFA::TokenType&amp; tk){    for (;;)    {        if (        {            return false;        }</p>

<p>        if (        {            return true;        }    }}</p>


<p>}}}</p>

<p>Sample</p>

<p>{{{cpp</p>

<h1>include "stdafx.h"</h1>
<h1>include "ExpressionsParser.h"</h1>
<h1>include <iostream></h1>

<p>const wchar{  switch (i)  {    case '\0': return L&quot;\\0&quot;;    case '\r': return L&quot;\\r&quot;;    case '\n':return L&quot;\\n&quot;;    case '\t':return L&quot;\\t&quot;;    case '\'':return L&quot;\\'&quot;;    case '\&quot;':return L&quot;\\\&quot;&quot;;    case '\?':return L&quot;\\?&quot;;    case '\\':return L&quot;\\\\&quot;;    case '\a':return L&quot;\\a&quot;;    case '\b':return L&quot;\\b&quot;;    case '\f':return L&quot;\\f&quot;;    case '\v':return L&quot;\\v&quot;;  }</p>

<p>  static wchar  ch  return ch;}</p>

<p>void PrintLiteral(const std::wstring&amp; ws){  if (ws.empty())  {    std::wcout &lt;&lt; &quot;'\\0'&quot;;      }  else  {    std::wcout &lt;&lt; &quot;\&quot;&quot;;    for (size    {      std::wcout &lt;&lt; IntToLiteral(ws    }    std::wcout  &lt;&lt; &quot;\&quot;&quot;;  }}</p>

<p>template&lt;class Language, class Stream&gt;void PrintTokens(Stream&amp; stream){      std::wstring lexeme;    typename Language::TokenType token;</p>

<p>    while (NextToken&lt;Language&gt;(stream, lexeme, token))        {       std::wcout.width(15);      std::wcout &lt;&lt;  TokensToString(token);      std::wcout &lt;&lt; L&quot; : &quot;;      PrintLiteral(lexeme.c      std::wcout &lt;&lt; std::endl;    }}</p>


<p>int {  if (argc == 1)  {    std::cout &lt;&lt; &quot;missing input file &quot;;    return 1;  }</p>

<p>  try  {    FileStream ss(argv    PrintTokens&lt;Expressions::DFA&gt;(ss);      }  catch (const Expressions::ParserException&amp; e)  {    std::cout &lt;&lt; &quot;Error : line, col = &quot; &lt;&lt; e.m  }  catch (const std::exception&amp; e)  {    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  }</p>

<p>  return 0;}</p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  