<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h2>shared_ptr</h2>

<p>This is my implementation of the TR1::shared</p>

<p>See more details in:</p>

<p><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1745.pdf">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1745.pdf</a></p>

<p><a href="http://www.boost.org">http://www.boost.org</a><a href="http://www.boost.org/libs/smart_ptr/smart_ptr.htm">http://www.boost.org/libs/smart_ptr/smart_ptr.htm</a></p>


<pre>

<span class="comment">/*-
 * Thiago Rosso Adams &lt;thiago.adams@gmail.com&gt;
 * This is the implementation of shared_ptr and weak_ptr proposed in tr1.
 * See details in: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1745.pdf

 Permission to copy, use, modify, sell and distribute this software
 is granted provided this copyright notice appears in all copies.
 This software is provided &quot;as is&quot; without express or implied
 warranty, and with no claim as to its suitability for any purpose.
*/</span>
<span class="keyword">#pragma</span> once
<span class="keyword">#ifndef</span> _MEMORYTR1_
<span class="keyword">#define</span> _MEMORYTR1_

<span class="keyword">#include</span> &lt;memory&gt;
<span class="keyword">#include</span> &lt;cassert&gt;

<span class="keyword">namespace</span> std {
    <span class="keyword">namespace</span> tr1 {

        <span class="keyword">namespace</span> detail
        {
            <span class="keyword">struct</span> shared_count
            {
                <span class="keyword">long</span> use_count;
                <span class="keyword">long</span> weak_count;
                shared_count(<span class="keyword">long</span> use, <span class="keyword">long</span> weak) : use_count(use), weak_count(weak)
                {
                }
                <span class="keyword">virtual</span> <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *) = <span class="number">0</span>;
                <span class="keyword">virtual</span> <span class="keyword">void</span> * get_deleter(<span class="keyword">const</span> type_info &amp;) {  <span class="keyword">return</span> <span class="number">0</span>; }
            };

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
            <span class="keyword">struct</span> shared_count_imp : <span class="keyword">public</span> shared_count
            {
                D deleter;
                shared_count_imp(<span class="keyword">long</span> use, <span class="keyword">long</span> weak, <span class="keyword">const</span> D &amp; d) :  shared_count(use, weak), deleter(d)
                {
                }

                <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *pv)
                {
                    T * p = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(pv);
                    deleter(p);
                }

                <span class="keyword">void</span> * get_deleter(<span class="keyword">const</span> type_info &amp;inf)
                {
                    <span class="keyword">return</span> inf == <span class="keyword">typeid</span>(D) ? &amp;deleter : <span class="number">0</span>;
                };

            };

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
            <span class="keyword">struct</span> shared_count_imp_default : <span class="keyword">public</span> shared_count
            {
                shared_count_imp_default(<span class="keyword">long</span> use, <span class="keyword">long</span> weak) :  shared_count(use, weak)
                {
                }

                <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *pv)
                {
                    T * p = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(pv);
                    <span class="keyword">delete</span> p;
                }
            };

        };

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> <span class="keyword2">shared_ptr</span>;

        <span class="keyword">class</span> bad_weak_ptr: <span class="keyword">public</span> std::exception
        {
        <span class="keyword">public</span>:
            bad_weak_ptr() : std::exception(<span class="string">&quot;&quot;</span>){}
            <span class="keyword">const</span> <span class="keyword">char</span> * what()
            {
                <span class="keyword">return</span> <span class="string">&quot;tr1::bad_weak_ptr&quot;</span>;
            }
        };

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> weak_ptr
        {
            T *m_p;
            detail::shared_count* m_pCount;

        <span class="keyword">public</span>:
            <span class="keyword">typedef</span> T element_type;

            <span class="comment">// constructors
</span>            weak_ptr() : m_p(<span class="number">0</span>) , m_pCount(<span class="number">0</span>)
            {
                assert(use_count() == <span class="number">0</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r) : m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }

                assert(use_count() == r.use_count());
            }

            weak_ptr(weak_ptr <span class="keyword">const</span>&amp; r): m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }
                assert(use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r) : m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }
                assert(use_count() == r.use_count());
            }

            <span class="comment">// destructor
</span>            ~weak_ptr()
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count--;
                    <span class="keyword">if</span> (m_pCount-&gt;weak_count == <span class="number">0</span> &amp;&amp; m_pCount-&gt;use_count == <span class="number">0</span>)
                        <span class="keyword">delete</span> m_pCount;
                }
            }

            <span class="comment">// assignment
</span>            weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="comment">// modifiers
</span>            <span class="keyword">void</span> swap(weak_ptr&amp; r)
            {
                std::swap(m_p, r.m_p);
                std::swap(m_pCount, r.m_pCount);
            }

            <span class="keyword">void</span> reset()
            {
                weak_ptr().swap(*<span class="keyword">this</span>);
            }

            <span class="comment">// observers
</span>            <span class="keyword">long</span> use_count() <span class="keyword">const</span>
            {
                <span class="keyword">if</span> (m_pCount)
                    <span class="keyword">return</span> m_pCount-&gt;use_count;
                <span class="keyword">return</span> <span class="number">0</span>;
            }

            <span class="keyword">bool</span> expired() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> use_count() == <span class="number">0</span>;
            }

            <span class="keyword2">shared_ptr</span>&lt;T&gt; lock() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> expired() ? <span class="keyword2">shared_ptr</span>&lt;T&gt;() : <span class="keyword2">shared_ptr</span>&lt;T&gt;(*<span class="keyword">this</span>);
            }
        };

        <span class="comment">// comparison
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(weak_ptr&lt;T&gt; <span class="keyword">const</span>&amp; a, weak_ptr&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() &lt; b.get();
        }

        <span class="comment">// specialized algorithms
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b)
        {
            a.swap(b);
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> <span class="keyword2">shared_ptr</span> {

            <span class="keyword">friend</span> <span class="keyword">class</span> weak_ptr&lt;T&gt;;

            T *m_p;
            detail::shared_count* m_pCount;

        <span class="keyword">public</span>:
            <span class="keyword">typedef</span> T element_type;

            <span class="comment">// [2.2.3.1] constructors
</span>            <span class="keyword2">shared_ptr</span>() : m_p(<span class="number">0</span>), m_pCount(<span class="number">0</span>)
            {
                assert(use_count() == <span class="number">0</span> &amp;&amp; get() == <span class="number">0</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(Y * p)
            {
                <span class="keyword">try</span>
                {
                    <span class="comment">//Throws: bad_alloc, or an implementation-defined exception when a resource other
</span>                    <span class="comment">// than memory could not be obtained.
</span>                    m_pCount = <span class="keyword">new</span> detail::shared_count_imp_default&lt;Y&gt;(<span class="number">1</span>, <span class="number">0</span>);
                    m_p = p;
                }
                <span class="keyword">catch</span>(...)
                {
                    <span class="keyword">delete</span> p; <span class="comment">//Exception safety: If an exception is thrown, delete p is called.
</span>                    <span class="keyword">throw</span>;
                }
                assert(use_count() == <span class="number">1</span> &amp;&amp; get() == p);
            }

            <span class="comment">//The copy constructor and destructor of D shall
</span>            <span class="comment">// not throw exceptions. The expression d(p) shall be well-formed,
</span>            <span class="comment">// shall have well defined behavior, and shall not throw exceptions.
</span>            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="keyword2">shared_ptr</span>(Y * p, D d)
            {
                <span class="keyword">try</span>
                {
                    m_pCount = <span class="keyword">new</span> detail::shared_count_imp&lt;T,D&gt;(<span class="number">1</span>,<span class="number">0</span>, d);
                    m_p = p;
                }
                <span class="keyword">catch</span>(...)
                {
                    d(p); <span class="comment">//If an exception is thrown, d(p) is called.
</span>                    <span class="keyword">throw</span>;
                }
                assert(use_count() == <span class="number">1</span> &amp;&amp; get() == p);
            }

            <span class="keyword2">shared_ptr</span>(<span class="keyword2">shared_ptr</span> <span class="keyword">const</span>&amp; r)
            {
                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                    m_pCount-&gt;use_count++;
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                    (*m_pCount)++;
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword">if</span> (r.expired())
                    <span class="keyword">throw</span> bad_weak_ptr();

                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                    (*m_pCount)++;
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(auto_ptr&lt;Y&gt;&amp; r)
            {
                m_pCount = <span class="keyword">new</span> detail::shared_count_imp_default(<span class="number">1</span>, <span class="number">0</span>);
                m_p = r.release();
                assert(use_count() == <span class="number">1</span> &amp;&amp; r.get() == <span class="number">0</span>);
            }

            <span class="comment">// [2.2.3.2] destructor
</span>            ~<span class="keyword2">shared_ptr</span>()
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;use_count--;
                    <span class="keyword">if</span> (m_pCount-&gt;use_count == <span class="number">0</span>)
                    {
                        m_pCount-&gt;call_deleter(m_p);

                        <span class="comment">// has m_pCount being used by weak_ptrs?
</span>                        <span class="keyword">if</span> (m_pCount-&gt;weak_count == <span class="number">0</span>)
                          <span class="keyword">delete</span> m_pCount; <span class="comment">//delete if not
</span>                    }

                }
            }

            <span class="comment">// [2.2.3.3] assignment
</span>            <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span> <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }


            <span class="comment">// [2.2.3.4] modifiers
</span>            <span class="keyword">void</span> swap(<span class="keyword2">shared_ptr</span>&amp; r)
            {
                std::swap(m_p, r.m_p);
                std::swap(m_pCount, r.m_pCount);
            }

            <span class="keyword">void</span> reset()
            {
                <span class="keyword2">shared_ptr</span>().swap(<span class="keyword">this</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">void</span> reset(Y * p)
            {
                <span class="keyword2">shared_ptr</span>(p).swap(<span class="keyword">this</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="keyword">void</span> reset(Y * p, D d)
            {
                <span class="keyword2">shared_ptr</span>(p, d).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }


            <span class="comment">// [2.2.3.5] observers
</span>            T* get() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> m_p;
            }

            T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> *m_p;
            }

            T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> m_p;
            }

            <span class="keyword">long</span> use_count() <span class="keyword">const</span>
            {
                <span class="keyword">if</span> (m_pCount)
                    <span class="keyword">return</span> m_pCount-&gt;use_count;
                <span class="keyword">return</span> <span class="number">0</span>;
            }

            <span class="keyword">bool</span> unique() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> use_count() == <span class="number">0</span>;
            }

            <span class="keyword">operator</span> <span class="keyword">bool</span>() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> get() != <span class="number">0</span>;
            }

            <span class="comment">// [2.2.3.10] shared_ptr get_deleter
</span>            <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> T2&gt; <span class="keyword">friend</span> D * get_deleter(<span class="keyword2">shared_ptr</span>&lt;T2&gt; <span class="keyword">const</span>&amp; p)
            {
                <span class="keyword">if</span> (!p.m_pCount)
                    <span class="keyword">return</span> <span class="number">0</span>;

                <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;D*&gt;(p.m_pCount-&gt;get_deleter(<span class="keyword">typeid</span>(D)));
            }
        };

        <span class="comment">// [2.2.3.6] shared_ptr comparisons
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() == b.get();
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() != b.get();
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() &lt; b.get();
        }

        <span class="comment">// [2.2.3.7] shared_ptr I/O
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> T, <span class="keyword">class</span> Y&gt;
        basic_ostream&lt;E, T&gt;&amp; <span class="keyword">operator</span>&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, <span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; p)
        {
            <span class="keyword">return</span> os &lt;&lt; p.get();
        }

        <span class="comment">// [2.2.3.8] shared_ptr specialized algorithms
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> swap(<span class="keyword2">shared_ptr</span>&lt;T&gt;&amp; a, <span class="keyword2">shared_ptr</span>&lt;T&gt;&amp; b)
        {
            a.swap(b);
        }

        <span class="comment">// [2.2.3.9] shared_ptr casts
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; static_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">static_cast</span>&lt;T*&gt;(r.get()) );
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; dynamic_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">dynamic_cast</span>&lt;T*&gt;(r.get()) );
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; const_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">const_cast</span>&lt;T*&gt;(r.get()) );
        }


        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> enable_shared_from_this
        {
        <span class="keyword">protected</span>:

            enable_shared_from_this()
            {
            }

            enable_shared_from_this(enable_shared_from_this <span class="keyword">const</span> &amp;)
            {
            }

            enable_shared_from_this &amp; <span class="keyword">operator</span>=(enable_shared_from_this <span class="keyword">const</span> &amp;)
            {
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            ~enable_shared_from_this()
            {
            }

        <span class="keyword">public</span>:

            <span class="keyword2">shared_ptr</span>&lt;T&gt; shared_from_this()
            {
                <span class="keyword2">shared_ptr</span>&lt;T&gt; p(_internal_weak_this);
                assert(p.get() == <span class="keyword">this</span>);
                <span class="keyword">return</span> p;
            }

            <span class="keyword2">shared_ptr</span>&lt;T <span class="keyword">const</span>&gt; shared_from_this() <span class="keyword">const</span>
            {
                <span class="keyword2">shared_ptr</span>&lt;T <span class="keyword">const</span>&gt; p(_internal_weak_this);
                assert(p.get() == <span class="keyword">this</span>);
                <span class="keyword">return</span> p;
            }

            <span class="keyword">mutable</span> weak_ptr&lt; T &gt; _internal_weak_this;
        };

    } <span class="comment">// namespace tr1
</span>} <span class="comment">// namespace std
</span>

<span class="keyword">#endif</span>
</pre>



<hr>

<p>Updated : 29/9/2011</p>


<pre>

<span class="comment">/*-

 * Thiago Rosso Adams &lt;thiago.adams@gmail.com&gt;

 * This is the implementation of shared_ptr and weak_ptr proposed in tra.

 * See details in: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1745.pdf



 Permission to copy, use, modify, sell and distribute this software

 is granted provided this copyright notice appears in all copies.

 This software is provided &quot;as is&quot; without express or implied

 warranty, and with no claim as to its suitability for any purpose.

*/</span>
<span class="keyword">#pragma</span> once
<span class="keyword">#ifndef</span> _MEMORYTR1_
<span class="keyword">#define</span> _MEMORYTR1_

<span class="keyword">#include</span> &lt;memory&gt;
<span class="keyword">#include</span> &lt;cassert&gt;

<span class="keyword">namespace</span> std {
    <span class="keyword">namespace</span> tra {

        <span class="keyword">namespace</span> detail
        {
            <span class="keyword">struct</span> shared_count
            {
                <span class="keyword">long</span> use_count;
                <span class="keyword">long</span> weak_count;
                shared_count(<span class="keyword">long</span> use, <span class="keyword">long</span> weak) : use_count(use), weak_count(weak)
                {
                }
                <span class="keyword">virtual</span> <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *) = <span class="number">0</span>;
                <span class="keyword">virtual</span> <span class="keyword">void</span> * get_deleter(<span class="keyword">const</span> type_info &amp;) {  <span class="keyword">return</span> <span class="number">0</span>; }
            };

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> D&gt;
            <span class="keyword">struct</span> shared_count_imp : <span class="keyword">public</span> shared_count
            {
                D deleter;
                shared_count_imp(<span class="keyword">long</span> use, <span class="keyword">long</span> weak, <span class="keyword">const</span> D &amp; d) :  shared_count(use, weak), deleter(d)
                {
                }

                <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *pv)
                {
                    T * p = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(pv);
                    deleter(p);
                }

                <span class="keyword">void</span> * get_deleter(<span class="keyword">const</span> type_info &amp;inf)
                {
                    <span class="keyword">return</span> inf == <span class="keyword">typeid</span>(D) ? &amp;deleter : <span class="number">0</span>;
                };

            };

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
            <span class="keyword">struct</span> shared_count_imp_default : <span class="keyword">public</span> shared_count
            {
                shared_count_imp_default(<span class="keyword">long</span> use, <span class="keyword">long</span> weak) :  shared_count(use, weak)
                {
                }

                <span class="keyword">void</span> call_deleter(<span class="keyword">void</span> *pv)
                {
                    T * p = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(pv);
                    <span class="keyword">delete</span> p;
                }
            };

        };

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> <span class="keyword2">shared_ptr</span>;

        <span class="keyword">class</span> bad_weak_ptr: <span class="keyword">public</span> std::exception
        {
        <span class="keyword">public</span>:
            bad_weak_ptr() : std::exception(<span class="string">&quot;&quot;</span>){}
            <span class="keyword">const</span> <span class="keyword">char</span> * what()
            {
                <span class="keyword">return</span> <span class="string">&quot;tra::bad_weak_ptr&quot;</span>;
            }
        };

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> weak_ptr
        {
            T *m_p;
            detail::shared_count* m_pCount;

        <span class="keyword">public</span>:
            <span class="keyword">typedef</span> T element_type;

            <span class="comment">// constructors
</span>            weak_ptr() : m_p(<span class="number">0</span>) , m_pCount(<span class="number">0</span>)
            {
                assert(use_count() == <span class="number">0</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r) : m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }

                assert(use_count() == r.use_count());
            }

            weak_ptr(weak_ptr <span class="keyword">const</span>&amp; r): m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }
                assert(use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r) : m_pCount(r.m_pCount), m_p(r.m_p)
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count++;
                }
                assert(use_count() == r.use_count());
            }

            <span class="comment">// destructor
</span>            ~weak_ptr()
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;weak_count--;
                    <span class="keyword">if</span> (m_pCount-&gt;weak_count == <span class="number">0</span> &amp;&amp; m_pCount-&gt;use_count == <span class="number">0</span>)
                        <span class="keyword">delete</span> m_pCount;
                }
            }

            <span class="comment">// assignment
</span>            weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr&amp; <span class="keyword">operator</span>=(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; weak_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                weak_ptr(r).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="comment">// modifiers
</span>            <span class="keyword">void</span> swap(weak_ptr&amp; r)
            {
                std::swap(m_p, r.m_p);
                std::swap(m_pCount, r.m_pCount);
            }

            <span class="keyword">void</span> reset()
            {
                weak_ptr().swap(*<span class="keyword">this</span>);
            }

            <span class="comment">// observers
</span>            <span class="keyword">long</span> use_count() <span class="keyword">const</span>
            {
                <span class="keyword">if</span> (m_pCount)
                    <span class="keyword">return</span> m_pCount-&gt;use_count;
                <span class="keyword">return</span> <span class="number">0</span>;
            }

            <span class="keyword">bool</span> expired() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> use_count() == <span class="number">0</span>;
            }

            <span class="keyword2">shared_ptr</span>&lt;T&gt; lock() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> expired() ? <span class="keyword2">shared_ptr</span>&lt;T&gt;() : <span class="keyword2">shared_ptr</span>&lt;T&gt;(*<span class="keyword">this</span>);
            }
        };

        <span class="comment">// comparison
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(weak_ptr&lt;T&gt; <span class="keyword">const</span>&amp; a, weak_ptr&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() &lt; b.get();
        }

        <span class="comment">// specialized algorithms
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> swap(weak_ptr&lt;T&gt;&amp; a, weak_ptr&lt;T&gt;&amp; b)
        {
            a.swap(b);
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> <span class="keyword2">shared_ptr</span> {

            <span class="keyword">friend</span> <span class="keyword">class</span> weak_ptr&lt;T&gt;;

          
         

        <span class="keyword">public</span>:  
          T *m_p;
           detail::shared_count* m_pCount;

            <span class="keyword">typedef</span> T element_type;

            <span class="comment">// [2.2.3.1] constructors
</span>            <span class="keyword2">shared_ptr</span>() : m_p(<span class="number">0</span>), m_pCount(<span class="number">0</span>)
            {
                assert(use_count() == <span class="number">0</span> &amp;&amp; get() == <span class="number">0</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(Y * p)
            {
                <span class="keyword">try</span>
                {
                    <span class="comment">//Throws: bad_alloc, or an implementation-defined exception when a resource other
</span>                    <span class="comment">// than memory could not be obtained.
</span>                    m_pCount = <span class="keyword">new</span> detail::shared_count_imp_default&lt;Y&gt;(<span class="number">1</span>, <span class="number">0</span>);
                    m_p = p;
                }
                <span class="keyword">catch</span>(...)
                {
                    <span class="keyword">delete</span> p; <span class="comment">//Exception safety: If an exception is thrown, delete p is called.
</span>                    <span class="keyword">throw</span>;
                }
                assert(use_count() == <span class="number">1</span> &amp;&amp; get() == p);
            }

            <span class="comment">//The copy constructor and destructor of D shall
</span>            <span class="comment">// not throw exceptions. The expression d(p) shall be well-formed,
</span>            <span class="comment">// shall have well defined behavior, and shall not throw exceptions.
</span>            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="keyword2">shared_ptr</span>(Y * p, D d)
            {
                <span class="keyword">try</span>
                {
                    m_pCount = <span class="keyword">new</span> detail::shared_count_imp&lt;T,D&gt;(<span class="number">1</span>,<span class="number">0</span>, d);
                    m_p = p;
                }
                <span class="keyword">catch</span>(...)
                {
                    d(p); <span class="comment">//If an exception is thrown, d(p) is called.
</span>                    <span class="keyword">throw</span>;
                }
                assert(use_count() == <span class="number">1</span> &amp;&amp; get() == p);
            }

            <span class="keyword2">shared_ptr</span>(<span class="keyword2">shared_ptr</span> <span class="keyword">const</span>&amp; r)
            {
                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                    m_pCount-&gt;use_count++;
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                {
                  m_pCount-&gt;use_count++;
                }
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(weak_ptr&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword">if</span> (r.expired())
                    <span class="keyword">throw</span> bad_weak_ptr();

                m_pCount = r.m_pCount;
                m_p = r.m_p;
                <span class="keyword">if</span> (m_pCount)
                    (*m_pCount)++;
                assert(get() == r.get() &amp;&amp; use_count() == r.use_count());
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="keyword2">shared_ptr</span>(auto_ptr&lt;Y&gt;&amp; r)

            {
                m_pCount = <span class="keyword">new</span> detail::shared_count_imp_default(<span class="number">1</span>, <span class="number">0</span>);
                m_p = r.release();
                assert(use_count() == <span class="number">1</span> &amp;&amp; r.get() == <span class="number">0</span>);
            }

            <span class="comment">// [2.2.3.2] destructor
</span>            ~<span class="keyword2">shared_ptr</span>()
            {
                <span class="keyword">if</span> (m_pCount)
                {
                    m_pCount-&gt;use_count--;
                    <span class="keyword">if</span> (m_pCount-&gt;use_count == <span class="number">0</span>)
                    {
                        m_pCount-&gt;call_deleter((<span class="keyword">void</span>*)m_p);

                        <span class="comment">// has m_pCount being used by weak_ptrs?
</span>                        <span class="keyword">if</span> (m_pCount-&gt;weak_count == <span class="number">0</span>)
                          <span class="keyword">delete</span> m_pCount; <span class="comment">//delete if not
</span>                    }

                }
            }

            <span class="comment">// [2.2.3.3] assignment
</span>            <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span> <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword2">shared_ptr</span>&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r)
            {
                <span class="keyword2">shared_ptr</span>(r).swap(<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }


            <span class="comment">// [2.2.3.4] modifiers
</span>            <span class="keyword">void</span> swap(<span class="keyword2">shared_ptr</span>&amp; r)
            {
                std::swap(m_p, r.m_p);
                std::swap(m_pCount, r.m_pCount);
            }

            <span class="keyword">void</span> reset()
            {
                <span class="keyword2">shared_ptr</span>().swap(<span class="keyword">this</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">void</span> reset(Y * p)
            {
                <span class="keyword2">shared_ptr</span>(p).swap(<span class="keyword">this</span>);
            }

            <span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="keyword">void</span> reset(Y * p, D d)
            {
                <span class="keyword2">shared_ptr</span>(p, d).swap(*<span class="keyword">this</span>);
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }


            <span class="comment">// [2.2.3.5] observers
</span>            T* get() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> m_p;
            }

            T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> *m_p;
            }

            T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> m_p;
            }

            <span class="keyword">long</span> use_count() <span class="keyword">const</span>
            {
                <span class="keyword">if</span> (m_pCount)
                    <span class="keyword">return</span> m_pCount-&gt;use_count;
                <span class="keyword">return</span> <span class="number">0</span>;
            }

            <span class="keyword">bool</span> unique() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> use_count() == <span class="number">0</span>;
            }

            <span class="keyword">operator</span> <span class="keyword">bool</span>() <span class="keyword">const</span>
            {
                <span class="keyword">return</span> get() != <span class="number">0</span>;
            }

           <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> T2&gt; <span class="keyword">friend</span> D * get_deleter(<span class="keyword2">shared_ptr</span>&lt;T2&gt; <span class="keyword">const</span>&amp; p);
        };

         <span class="comment">// [2.2.3.10] shared_ptr get_deleter
</span>            <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> T2&gt;  D * get_deleter(<span class="keyword2">shared_ptr</span>&lt;T2&gt; <span class="keyword">const</span>&amp; p)
            {
                <span class="keyword">if</span> (!p.m_pCount)
                    <span class="keyword">return</span> <span class="number">0</span>;

                <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;D*&gt;(p.m_pCount-&gt;get_deleter(<span class="keyword">typeid</span>(D)));
            }

        <span class="comment">// [2.2.3.6] shared_ptr comparisons
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() == b.get();
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() != b.get();
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword2">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span>&amp; a, <span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; b)
        {
            <span class="keyword">return</span> a.get() &lt; b.get();
        }

        <span class="comment">// [2.2.3.7] shared_ptr I/O
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> E, <span class="keyword">class</span> T, <span class="keyword">class</span> Y&gt;
        basic_ostream&lt;E, T&gt;&amp; <span class="keyword">operator</span>&lt;&lt; (basic_ostream&lt;E, T&gt;&amp; os, <span class="keyword2">shared_ptr</span>&lt;Y&gt; <span class="keyword">const</span>&amp; p)
        {
            <span class="keyword">return</span> os &lt;&lt; p.get();
        }

        <span class="comment">// [2.2.3.8] shared_ptr specialized algorithms
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">void</span> swap(<span class="keyword2">shared_ptr</span>&lt;T&gt;&amp; a, <span class="keyword2">shared_ptr</span>&lt;T&gt;&amp; b)
        {
            a.swap(b);
        }

        <span class="comment">// [2.2.3.9] shared_ptr casts
</span>        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; static_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">static_cast</span>&lt;T*&gt;(r.get()) );
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; dynamic_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">dynamic_cast</span>&lt;T*&gt;(r.get()) );
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword2">shared_ptr</span>&lt;T&gt; const_pointer_cast(<span class="keyword2">shared_ptr</span>&lt;U&gt; <span class="keyword">const</span>&amp; r)
        {
            <span class="keyword">return</span> <span class="keyword2">shared_ptr</span>&lt;T&gt;( <span class="keyword">const_cast</span>&lt;T*&gt;(r.get()) );
        }


        <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> enable_shared_from_this
        {
        <span class="keyword">protected</span>:

            enable_shared_from_this()
            {
            }

            enable_shared_from_this(enable_shared_from_this <span class="keyword">const</span> &amp;)
            {
            }

            enable_shared_from_this &amp; <span class="keyword">operator</span>=(enable_shared_from_this <span class="keyword">const</span> &amp;)
            {
                <span class="keyword">return</span> *<span class="keyword">this</span>;
            }

            ~enable_shared_from_this()
            {
            }

        <span class="keyword">public</span>:

            <span class="keyword2">shared_ptr</span>&lt;T&gt; shared_from_this()
            {
                <span class="keyword2">shared_ptr</span>&lt;T&gt; p(_internal_weak_this);
                assert(p.get() == <span class="keyword">this</span>);
                <span class="keyword">return</span> p;
            }

            <span class="keyword2">shared_ptr</span>&lt;T <span class="keyword">const</span>&gt; shared_from_this() <span class="keyword">const</span>
            {
                <span class="keyword2">shared_ptr</span>&lt;T <span class="keyword">const</span>&gt; p(_internal_weak_this);
                assert(p.get() == <span class="keyword">this</span>);
                <span class="keyword">return</span> p;
            }

            <span class="keyword">mutable</span> weak_ptr&lt; T &gt; _internal_weak_this;
        };

    } <span class="comment">// namespace tra
</span>} <span class="comment">// namespace std
</span>

<span class="keyword">#endif</span>

</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  