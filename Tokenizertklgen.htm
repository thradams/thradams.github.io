<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->


<p>Header:</p>

<p><strong>Tokenizer.h</strong></p>

<p>{{{cpp</p>

<p>//////////////////////////////////////////////////////////////////////////////// TKLGEN - VersionMar  8 2013// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)// www.thradams.com//// Permission to copy, use, modify, sell and distribute this software// is granted provided this copyright notice appears in all copies.// This software is provided &quot;as is&quot; without express or implied// warranty, and with no claim as to its suitability for any purpose.////////////////////////////////////////////////////////////////////////////////</p>


<h1>pragma once</h1>

<p>template &lt; class TDFA,         class TInputStream &gt;struct Tokenizer{public:    typedef TInputStream             InputStream;    typedef typename TDFA::TokenType TokenType;</p>

<p>private:</p>


<p>    Tokenizer&amp; operator=(const Tokenizer&amp;); //= deleted</p>

<p>    template&lt;class T&gt;    bool NextTokenNoInterleave(T&amp; lexeme, TokenType&amp; tk)    {        lexeme.clear();        int lastGoodState = -1;        int currentState = 0;        wchar</p>

<p>        while (m        {            currentState = TDFA::GetNext(currentState, ch);</p>

<p>            if (currentState == -1)            {                m                break;            }</p>

<p>            TokenType tk2;</p>

<p>            if (TDFA::GetTokenFromState(currentState, tk2))            {                tk = tk2;                lastGoodState = currentState;            }</p>

<p>            lexeme.append(1, ch);        }</p>

<p>        return (lastGoodState     }</p>


<p>public:</p>

<p>    InputStream&amp; m</p>

<p>    Tokenizer(InputStream&amp; stream)        : m    {    }</p>

<p>    template&lt;class T&gt;    bool NextToken(T&amp; lexeme, TokenType&amp; tk)    {        for (;;)        {            if (            {                return false;            }</p>

<p>            if (            {                return true;            }        }    }};</p>


<p>}}}</p>


<p>Testing the tokenizer:</p>

<p>The generated DFA is necessary:</p>

<p>{{{cppconst wchar{  switch (i)  {    case '\0': return L&quot;\\0&quot;;    case '\r': return L&quot;\\r&quot;;    case '\n':return L&quot;\\n&quot;;    case '\t':return L&quot;\\t&quot;;    case '\'':return L&quot;\\'&quot;;    case '\&quot;':return L&quot;\\\&quot;&quot;;    case '\?':return L&quot;\\?&quot;;    case '\\':return L&quot;\\\\&quot;;    case '\a':return L&quot;\\a&quot;;    case '\b':return L&quot;\\b&quot;;    case '\f':return L&quot;\\f&quot;;    case '\v':return L&quot;\\v&quot;;  }</p>

<p>  static wchar  ch  return ch;}</p>

<p>void PrintLiteral(const std::wstring&amp; ws){  if (ws.empty())  {    std::wcout &lt;&lt; &quot;'\\0'&quot;;      }  else  {    std::wcout &lt;&lt; &quot;\&quot;&quot;;    for (size    {      std::wcout &lt;&lt; IntToLiteral(ws    }    std::wcout  &lt;&lt; &quot;\&quot;&quot;;  }}</p>

<p>template&lt;class Scanner&gt;void PrintTokens(Scanner&amp; scanner){</p>

<p>    std::wstring lexeme;    Scanner::TokenType token;</p>

<p>    while (scanner.NextToken(lexeme, token))        {       std::wcout.width(15);      std::wcout &lt;&lt;  TokensToString(token);      std::wcout &lt;&lt; L&quot; : &quot;;      PrintLiteral(lexeme.c      std::wcout &lt;&lt; std::endl;    }}</p>

<p>int main(){    StringStream ss(L&quot;blabla&quot;);</p>

<p>    typedef Tokenizer&lt;Sample2::DFA, StringStream&gt; StringStreamScanner;   </p>

<p>    StringStreamScanner scanner(ss);</p>

<p>    PrintTokens(scanner);}</p>

<p>}}}</p>


<p>{{{cpp</p>


<p>template &lt;class TDFA,          class T,          class TInputStream&gt;bool NextTokenNoInterleave(TInputStream&amp; stream,                           T&amp; lexeme,                           typename TDFA::TokenType&amp; tk){  lexeme.clear();  int lastGoodState = -1;  int currentState = 0;  wchar</p>

<p>  while (stream.NextChar(ch))  {    currentState = TDFA::GetNext(currentState, ch);</p>

<p>    if (currentState == -1)    {      stream.PutBack(ch);      break;    }</p>

<p>    typename TDFA::TokenType tk2;</p>

<p>    if (TDFA::GetTokenFromState(currentState, tk2))    {      tk = tk2;      lastGoodState = currentState;    }</p>

<p>    lexeme.append(1, ch);  }</p>

<p>  return (lastGoodState }</p>

<p>}}}
<!-- Page content end --> 
</article> 
 
</body> 
</html>  