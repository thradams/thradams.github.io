
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<p>I was wondering why I have to express the interface \\relationships on the object definition.</p>

<p>I don't have to express in the object type, \\for instance, if it is allocated on the stack or on \\the heap then it can be used in both.</p>

<p>The same idea could be applied in polymorphism.\\I could have the class definition and choose if I\\want it polymorphic or not. Even more, I want to choose how I will see the object,\\and it doesn't need to know about that. </p>

<p>One reason to do that is because the inheritance \\just complicated design and makes changes hard. </p>

<p>Static polymorphism and generic algorithms solve \\this problem in some cases, but they don't solve the problem\\when dynamic polymorphism is required.</p>

<p>Let's say I have a list with Cars and Dogs.\\Both have the Color property. To apply an algorithm in this list,\\which uses the Color property, I need to implement a common Interface\\in Dogs and Cars. I have to artificially create this common interface\\just to access the Color. If the base class of Dog is Animal and it\\already has the Color property, this will not help, because Car is not derived\\from Animal. The same if the Car is derived from Vehicle and Vehicle\\has the Color property.</p>

<p>Now let's say I have this Common interface but in another program\\I will reuse only the Car class. For this software, the Vehicle interface \\is enough, because I have a polymorphic list of Vehicles. I don't need Animals.</p>

<p>This sample shows that the same object Car can be &quot;viewed&quot; differently\\in two places. The Car object is exactly the same, it has the Color property.\\&quot;Beauty is in the eye of the beholder&quot;</p>

<p>Trying to address this question I did some experiment with an &quot;interface</p>

<p>Sample:</p>

<p>{{{cppstruct Car {  int Color() {return 1;}};</p>

<p>struct Dog {  int Color() {return 2;}};}}}</p>

<p>I need in some software / algorithm see the Color in a polymorphic way.For this, I will use this &quot;view&quot; or interface.{{{cppstruct IColor { virtual int Color() = 0; };}}}The use of &quot;interface{{{cppCar car;Dog dog;</p>

<p>IColor&amp; rCar = interfacecout  &lt;&lt; rCar.Color();IColor&amp; rDog = interfacecout  &lt;&lt; rDog.Color();}}}</p>

<p>The interface{{{cpp</p>

<p>template&lt;class TObject, class TInterface&gt; struct InterfaceAdapter; // Not Implemented</p>

<p>template&lt;class TInterface, class TObject&gt;InterfaceAdapter&lt;TObject, TInterface&gt; interface{    return InterfaceAdapter&lt;TObject, TInterface&gt;(r);}}}}</p>

<p>The returned &quot;InterfaceAdapter&quot; object must be created manually.In this case:{{{cpptemplate&lt;class T&gt;struct InterfaceAdapter&lt;T, IColor&gt; : public IColor{    T&amp; m    InterfaceAdapter(T&amp; r) : m</p>

<p>    virtual int Color()    {        return m    }};}}}</p>

<p>The color property could have a different syntax, for instance MyColor. In this case, a more specialized version of InterfaceAdapter must be created.{{{cpptemplate&lt;&gt;struct InterfaceAdapter&lt;Car, IColor&gt; : public IColor{    Car&amp; m    InterfaceAdapter(Car&amp; r) : m</p>

<p>    virtual int Color()    {        return m    }};}}}To keep the object in a polymorphic way we could do something like:{{{cpptemplate&lt;class TObject, class TInterface&gt; struct InterfaceAdapterInstance : public InterfaceAdapter&lt;TObject, TInterface&gt;{  TObject m  InterfaceAdapterInstance() : InterfaceAdapter&lt;TObject, TInterface&gt;(m};</p>

<p>template&lt;class TObject, class TInterface&gt;InterfaceAdapterInstance&lt;TObject, TInterface&gt;{    return new InterfaceAdapterInstance&lt;TObject, TInterface&gt;;   }</p>

<p>std::vector&lt;IColorv.pushv.push}}}</p>

<p>I think that there is some relationship with the idea of concepts, but in this case with polymorphic and dynamic behavior.I would appreciate your comments about this. </p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  