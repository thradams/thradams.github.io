<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h1> opendir windows</h1>

<p>This code is a port of opendir. readdir and closedir for windows. (include dirent.h on linux)</p>



<pre>

<span class="keyword">#include</span> &lt;Windows.h&gt;

<span class="keyword">#include</span> &lt;sys/types.h&gt;
<span class="keyword">#include</span> &lt;stdio.h&gt;
<span class="keyword">#include</span> &lt;sys/stat.h&gt;
<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>.h&gt;

<span class="keyword">#ifdef</span> _WINDOWS_


<span class="comment">/*
 opendir,  readdir closedir for windows.
 include dirent.h on linux
*/</span>

<span class="keyword">enum</span>
{
  DT_UNKNOWN = <span class="number">0</span>,
  DT_FIFO = <span class="number">1</span>,
  DT_CHR = <span class="number">2</span>,
  DT_DIR = <span class="number">4</span>,
  DT_BLK = <span class="number">6</span>,
  DT_REG = <span class="number">8</span>,
  DT_LNK = <span class="number">10</span>,
  DT_SOCK = <span class="number">12</span>,
  DT_WHT = <span class="number">14</span>
};

<span class="keyword">struct</span> dirent
{
  ino_t d_ino;             <span class="comment">/* Inode number */</span>
  off_t d_off;             <span class="comment">/* Not an offset; see below */</span>
  <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen; <span class="comment">/* Length of this record */</span>
  <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;    <span class="comment">/* Type of file; not supported
                                   by all filesystem types*/</span>
  <span class="keyword">char</span> d_name[<span class="number">256</span>];        <span class="comment">/* Null-terminated filename */</span>
};

<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
  <span class="keyword">void</span> *handle;
  <span class="keyword">struct</span> dirent dirent;
} DIR;

DIR *opendir(<span class="keyword">const</span> <span class="keyword">char</span> *name);
<span class="keyword">int</span> closedir(DIR *dirp);
<span class="keyword">struct</span> dirent *readdir(DIR *dirp);

<span class="keyword">static</span> <span class="keyword">int</span> convert_windows_getlasterror_to_posix(<span class="keyword">int</span> i)
{
  <span class="keyword">switch</span> (i)
  {
  <span class="keyword">case</span> ERROR_ACCESS_DENIED:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_ALREADY_EXISTS:
    <span class="keyword">return</span> EEXIST;
  <span class="keyword">case</span> ERROR_BAD_UNIT:
    <span class="keyword">return</span> ENODEV;
  <span class="keyword">case</span> ERROR_BUFFER_OVERFLOW:
    <span class="keyword">return</span> ENAMETOOLONG;
  <span class="keyword">case</span> ERROR_BUSY:
    <span class="keyword">return</span> EBUSY;
  <span class="keyword">case</span> ERROR_BUSY_DRIVE:
    <span class="keyword">return</span> EBUSY;
  <span class="keyword">case</span> ERROR_CANNOT_MAKE:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_CANTOPEN:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_CANTREAD:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_CANTWRITE:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_CURRENT_DIRECTORY:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_DEV_NOT_EXIST:
    <span class="keyword">return</span> ENODEV;
  <span class="keyword">case</span> ERROR_DEVICE_IN_USE:
    <span class="keyword">return</span> EBUSY;
  <span class="keyword">case</span> ERROR_DIR_NOT_EMPTY:
    <span class="keyword">return</span> ENOTEMPTY;
  <span class="keyword">case</span> ERROR_DIRECTORY:
    <span class="keyword">return</span> EINVAL;
  <span class="keyword">case</span> ERROR_DISK_FULL:
    <span class="keyword">return</span> ENOSPC;
  <span class="keyword">case</span> ERROR_FILE_EXISTS:
    <span class="keyword">return</span> EEXIST;
  <span class="keyword">case</span> ERROR_FILE_NOT_FOUND:
    <span class="keyword">return</span> ENOENT;
  <span class="keyword">case</span> ERROR_HANDLE_DISK_FULL:
    <span class="keyword">return</span> ENOSPC;
  <span class="keyword">case</span> ERROR_INVALID_ACCESS:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_INVALID_DRIVE:
    <span class="keyword">return</span> ENODEV;
  <span class="keyword">case</span> ERROR_INVALID_FUNCTION:
    <span class="keyword">return</span> ENOSYS;
  <span class="keyword">case</span> ERROR_INVALID_HANDLE:
    <span class="keyword">return</span> EINVAL;
  <span class="keyword">case</span> ERROR_INVALID_NAME:
    <span class="keyword">return</span> EINVAL;
  <span class="keyword">case</span> ERROR_LOCK_VIOLATION:
    <span class="keyword">return</span> ENOLCK;
  <span class="keyword">case</span> ERROR_LOCKED:
    <span class="keyword">return</span> ENOLCK;
  <span class="keyword">case</span> ERROR_NEGATIVE_SEEK:
    <span class="keyword">return</span> EINVAL;
  <span class="keyword">case</span> ERROR_NOACCESS:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_NOT_ENOUGH_MEMORY:
    <span class="keyword">return</span> ENOMEM;
  <span class="keyword">case</span> ERROR_NOT_READY:
    <span class="keyword">return</span> EAGAIN;
  <span class="keyword">case</span> ERROR_NOT_SAME_DEVICE:
    <span class="keyword">return</span> EXDEV;
  <span class="keyword">case</span> ERROR_OPEN_FAILED:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_OPEN_FILES:
    <span class="keyword">return</span> EBUSY;
  <span class="keyword">case</span> ERROR_OPERATION_ABORTED:
    <span class="keyword">return</span> ECANCELED;
  <span class="keyword">case</span> ERROR_OUTOFMEMORY:
    <span class="keyword">return</span> ENOMEM;
  <span class="keyword">case</span> ERROR_PATH_NOT_FOUND:
    <span class="keyword">return</span> ENOENT;
  <span class="keyword">case</span> ERROR_READ_FAULT:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_RETRY:
    <span class="keyword">return</span> EAGAIN;
  <span class="keyword">case</span> ERROR_SEEK:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_SHARING_VIOLATION:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> ERROR_TOO_MANY_OPEN_FILES:
    <span class="keyword">return</span> EMFILE;
  <span class="keyword">case</span> ERROR_WRITE_FAULT:
    <span class="keyword">return</span> EIO;
  <span class="keyword">case</span> ERROR_WRITE_PROTECT:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> WSAEACCES:
    <span class="keyword">return</span> EACCES;
  <span class="keyword">case</span> WSAEADDRINUSE:
    <span class="keyword">return</span> EADDRINUSE;
  <span class="keyword">case</span> WSAEADDRNOTAVAIL:
    <span class="keyword">return</span> EADDRNOTAVAIL;
  <span class="keyword">case</span> WSAEAFNOSUPPORT:
    <span class="keyword">return</span> EAFNOSUPPORT;
  <span class="keyword">case</span> WSAEALREADY:
    <span class="keyword">return</span> EALREADY;
  <span class="keyword">case</span> WSAEBADF:
    <span class="keyword">return</span> EBADF;
  <span class="keyword">case</span> WSAECONNABORTED:
    <span class="keyword">return</span> ECONNABORTED;
  <span class="keyword">case</span> WSAECONNREFUSED:
    <span class="keyword">return</span> ECONNREFUSED;
  <span class="keyword">case</span> WSAECONNRESET:
    <span class="keyword">return</span> ECONNRESET;
  <span class="keyword">case</span> WSAEDESTADDRREQ:
    <span class="keyword">return</span> EDESTADDRREQ;
  <span class="keyword">case</span> WSAEFAULT:
    <span class="keyword">return</span> EFAULT;
  <span class="keyword">case</span> WSAEHOSTUNREACH:
    <span class="keyword">return</span> EHOSTUNREACH;
  <span class="keyword">case</span> WSAEINPROGRESS:
    <span class="keyword">return</span> EINPROGRESS;
  <span class="keyword">case</span> WSAEINTR:
    <span class="keyword">return</span> EINTR;
  <span class="keyword">case</span> WSAEINVAL:
    <span class="keyword">return</span> EINVAL;
  <span class="keyword">case</span> WSAEISCONN:
    <span class="keyword">return</span> EISCONN;
  <span class="keyword">case</span> WSAEMFILE:
    <span class="keyword">return</span> EMFILE;
  <span class="keyword">case</span> WSAEMSGSIZE:
    <span class="keyword">return</span> EMSGSIZE;
  <span class="keyword">case</span> WSAENETDOWN:
    <span class="keyword">return</span> ENETDOWN;
  <span class="keyword">case</span> WSAENETRESET:
    <span class="keyword">return</span> ENETRESET;
  <span class="keyword">case</span> WSAENETUNREACH:
    <span class="keyword">return</span> ENETUNREACH;
  <span class="keyword">case</span> WSAENOBUFS:
    <span class="keyword">return</span> ENOBUFS;
  <span class="keyword">case</span> WSAENOPROTOOPT:
    <span class="keyword">return</span> ENOPROTOOPT;
  <span class="keyword">case</span> WSAENOTCONN:
    <span class="keyword">return</span> ENOTCONN;
  <span class="keyword">case</span> WSAENOTSOCK:
    <span class="keyword">return</span> ENOTSOCK;
  <span class="keyword">case</span> WSAEOPNOTSUPP:
    <span class="keyword">return</span> EOPNOTSUPP;
  <span class="keyword">case</span> WSAEPROTONOSUPPORT:
    <span class="keyword">return</span> EPROTONOSUPPORT;
  <span class="keyword">case</span> WSAEPROTOTYPE:
    <span class="keyword">return</span> EPROTOTYPE;
  <span class="keyword">case</span> WSAETIMEDOUT:
    <span class="keyword">return</span> ETIMEDOUT;
  <span class="keyword">case</span> WSAEWOULDBLOCK:
    <span class="keyword">return</span> EWOULDBLOCK;
  }
  <span class="keyword">return</span> EPERM;
}

DIR *opendir(<span class="keyword">const</span> <span class="keyword">char</span> *name)
{
  WIN32_FIND_DATAA fdFile;

  <span class="keyword">char</span> sPath[MAX_PATH] = {<span class="number">0</span>};
  strcat(sPath, name);
  strcat(sPath, <span class="string">&quot;\\*.*&quot;</span>);

  HANDLE handle = FindFirstFileA(sPath, &amp;fdFile);

  <span class="keyword">if</span> (handle != INVALID_HANDLE_VALUE)
  {
    DIR *p = calloc(<span class="number">1</span>, <span class="keyword">sizeof</span> *p);
    <span class="keyword">if</span> (p)
    {
      p-&gt;handle = handle;
      <span class="keyword">return</span> p;
    }
    <span class="keyword">else</span>
    {
      <span class="comment">/*calloc sets errno to ENOMEM if a memory allocation fails */</span>
      FindClose(handle);      
    }
  }
  <span class="keyword">else</span>
  {
    errno = convert_windows_getlasterror_to_posix(GetLastError());
  }

  <span class="keyword">return</span> NULL;
}

<span class="keyword">int</span> closedir(DIR *dirp)
{
  FindClose(dirp-&gt;handle);
  free(dirp);
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="keyword">struct</span> dirent *readdir(DIR *dirp)
{
  WIN32_FIND_DATAA fdFile;
  BOOL b = FindNextFileA(dirp-&gt;handle, &amp;fdFile);
  <span class="keyword">if</span> (b)
  {
    <span class="comment">/*clear*/</span>
    memset(&amp;dirp-&gt;dirent, <span class="number">0</span>, <span class="keyword">sizeof</span>(dirp-&gt;dirent));

    <span class="keyword">if</span> (fdFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
    {
      dirp-&gt;dirent.d_type |= DT_DIR;
    }

    <span class="comment">/*worst case trunks the string*/</span>
    strncpy(dirp-&gt;dirent.d_name,
            fdFile.cFileName,
            <span class="keyword">sizeof</span>(dirp-&gt;dirent.d_name) - <span class="number">1</span>);

    <span class="keyword">return</span> &amp;dirp-&gt;dirent;
  }
  <span class="keyword">else</span>
  {
    errno = convert_windows_getlasterror_to_posix(GetLastError());
  }
  <span class="keyword">return</span> NULL;
}

<span class="keyword">#endif</span> <span class="comment">//_WINDOWS_
</span>
<span class="keyword">int</span> copy_file(<span class="keyword">const</span> <span class="keyword">char</span> *pathfrom,
              <span class="keyword">const</span> <span class="keyword">char</span> *pathto)
{
  <span class="keyword">char</span> buf[<span class="number">4096</span>];
  size_t nread;
  <span class="keyword">int</span> saved_errno;

  FILE *fd_from = fopen(pathfrom, <span class="string">&quot;rb&quot;</span>);
  <span class="keyword">if</span> (fd_from &lt; <span class="number">0</span>)
    <span class="keyword">return</span> <span class="number">-1</span>;

  FILE *fd_to = fopen(pathto, <span class="string">&quot;wb&quot;</span>);
  <span class="keyword">if</span> (fd_to &lt; <span class="number">0</span>)
    <span class="keyword">goto</span> out_error;

  <span class="keyword">while</span> (nread = fread(buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="keyword">sizeof</span> buf, fd_from), nread &gt; <span class="number">0</span>)
  {
    <span class="keyword">char</span> *out_ptr = buf;
    size_t nwritten;

    <span class="keyword">do</span>
    {
      nwritten = fwrite(out_ptr, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), nread, fd_to);

      <span class="keyword">if</span> (nwritten &gt;= <span class="number">0</span>)
      {
        nread -= nwritten;
        out_ptr += nwritten;
      }
      <span class="keyword">else</span>
      {
        <span class="keyword">goto</span> out_error;
      }
    } <span class="keyword">while</span> (nread &gt; <span class="number">0</span>);
  }

  <span class="keyword">if</span> (nread == <span class="number">0</span>)
  {
    <span class="keyword">if</span> (fclose(fd_to) &lt; <span class="number">0</span>)
    {
      fd_to = NULL;
      <span class="keyword">goto</span> out_error;
    }
    fclose(fd_from);

    <span class="comment">/* Success! */</span>
    <span class="keyword">return</span> <span class="number">0</span>;
  }

out_error:
  saved_errno = errno;

  fclose(fd_from);

  <span class="keyword">if</span> (fd_to != NULL)
    fclose(fd_to);

  <span class="keyword">return</span> saved_errno;
}

<span class="keyword">int</span> copy_folder(<span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to)
{
  <span class="keyword">int</span> errcode = _mkdir(to);
  <span class="keyword">if</span> (errcode != <span class="number">0</span>)
  {
    <span class="keyword">return</span> errcode;
  }
  
  DIR *dir = opendir(from);

  <span class="keyword">if</span> (dir == NULL)
  {
    <span class="keyword">return</span> errno;
  }

  <span class="keyword">struct</span> dirent *dp;
  <span class="keyword">while</span> ((dp = readdir(dir)) != NULL)
  {
    <span class="keyword">if</span> (strcmp(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || strcmp(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)
    {
      <span class="comment">/* skip self and parent */</span>
      <span class="keyword">continue</span>; 
    }

    <span class="keyword">char</span> fromlocal[MAX_PATH];
    snprintf(fromlocal, MAX_PATH, <span class="string">&quot;%s/%s&quot;</span>, from, dp-&gt;d_name);

    <span class="keyword">char</span> tolocal[MAX_PATH];
    snprintf(tolocal, MAX_PATH, <span class="string">&quot;%s/%s&quot;</span>, to, dp-&gt;d_name);

    <span class="keyword">if</span> (dp-&gt;d_type &amp; DT_DIR)
    {
        errcode = copy_folder(fromlocal, tolocal);
    }
    <span class="keyword">else</span>
    {
      errcode = copy_file(fromlocal, tolocal);
    }

    <span class="keyword">if</span> (errcode != <span class="number">0</span>)
      <span class="keyword">break</span>;
  }

  closedir(dir);
  <span class="keyword">return</span> errcode;
}

<span class="keyword">int</span> main(<span class="keyword">void</span>)
{
  <span class="keyword">char</span> buffer[<span class="number">200</span>];
  _getcwd(buffer, <span class="number">200</span>);
  printf(<span class="string">&quot;%s\n&quot;</span>, buffer);

  <span class="keyword">int</span> errcode = copy_folder(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;to&quot;</span>);

  <span class="keyword">return</span> EXIT_SUCCESS;
}

</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  