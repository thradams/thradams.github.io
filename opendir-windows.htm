<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h1> opendir windows</h1>

<p>This is a port of opendir for windows.</p>

<p>This code only works for the cases you test.</p>

<p>dirent.h</p>

<pre>
<span class="keyword">#pragma</span> once

<span class="keyword">#include</span> &lt;sys/types.h&gt;

<span class="comment">/* File types for `d_type'.  */</span>
<span class="keyword">enum</span>
{
    DT_UNKNOWN = <span class="number">0</span>,
    DT_FIFO = <span class="number">1</span>,
    DT_CHR = <span class="number">2</span>,
    DT_DIR = <span class="number">4</span>,
    DT_BLK = <span class="number">6</span>,
    DT_REG = <span class="number">8</span>,
    DT_LNK = <span class="number">10</span>,
    DT_SOCK = <span class="number">12</span>,
    DT_WHT = <span class="number">14</span>
};


<span class="keyword">struct</span> dirent {
    ino_t          d_ino;       <span class="comment">/* Inode number */</span>
    off_t          d_off;       <span class="comment">/* Not an offset; see below */</span>
    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported
                                   by all filesystem types*/</span>
    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span>
};

<span class="keyword">typedef</span> <span class="keyword">struct</span> {
    <span class="keyword">void</span>* handle;
    <span class="keyword">struct</span> dirent dirent;
} DIR;


<span class="comment">//https://www.man7.org/linux/man-pages/man3/fdopendir.3.html
</span>DIR* opendir(<span class="keyword">const</span> <span class="keyword">char</span>* name);

<span class="keyword">int</span> closedir(DIR* dirp);
<span class="keyword">struct</span> dirent* readdir(DIR* dirp);

</pre>


<p>dirent.c</p>

<pre>


<span class="keyword">#include</span> <span class="string">&quot;dirent.h&quot;</span>
<span class="keyword">#include</span> &lt;Windows.h&gt;


<span class="keyword">static</span> <span class="keyword">int</span> convert_windows_getlasterror_to_posix(<span class="keyword">int</span> i)
{
    <span class="keyword">switch</span> (i)
    {
        <span class="keyword">case</span> ERROR_ACCESS_DENIED: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_ALREADY_EXISTS: <span class="keyword">return</span> EEXIST;
        <span class="keyword">case</span> ERROR_BAD_UNIT: <span class="keyword">return</span> ENODEV;
        <span class="keyword">case</span> ERROR_BUFFER_OVERFLOW: <span class="keyword">return</span> ENAMETOOLONG;
        <span class="keyword">case</span> ERROR_BUSY: <span class="keyword">return</span> EBUSY;
        <span class="keyword">case</span> ERROR_BUSY_DRIVE: <span class="keyword">return</span> EBUSY;
        <span class="keyword">case</span> ERROR_CANNOT_MAKE: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_CANTOPEN: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_CANTREAD: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_CANTWRITE: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_CURRENT_DIRECTORY: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_DEV_NOT_EXIST: <span class="keyword">return</span> ENODEV;
        <span class="keyword">case</span> ERROR_DEVICE_IN_USE: <span class="keyword">return</span> EBUSY;
        <span class="keyword">case</span> ERROR_DIR_NOT_EMPTY: <span class="keyword">return</span> ENOTEMPTY;
        <span class="keyword">case</span> ERROR_DIRECTORY: <span class="keyword">return</span> EINVAL;
        <span class="keyword">case</span> ERROR_DISK_FULL: <span class="keyword">return</span> ENOSPC;
        <span class="keyword">case</span> ERROR_FILE_EXISTS: <span class="keyword">return</span> EEXIST;
        <span class="keyword">case</span> ERROR_FILE_NOT_FOUND: <span class="keyword">return</span> ENOENT;
        <span class="keyword">case</span> ERROR_HANDLE_DISK_FULL: <span class="keyword">return</span> ENOSPC;
        <span class="keyword">case</span> ERROR_INVALID_ACCESS: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_INVALID_DRIVE: <span class="keyword">return</span> ENODEV;
        <span class="keyword">case</span> ERROR_INVALID_FUNCTION: <span class="keyword">return</span> ENOSYS;
        <span class="keyword">case</span> ERROR_INVALID_HANDLE: <span class="keyword">return</span> EINVAL;
        <span class="keyword">case</span> ERROR_INVALID_NAME: <span class="keyword">return</span> EINVAL;
        <span class="keyword">case</span> ERROR_LOCK_VIOLATION: <span class="keyword">return</span> ENOLCK;
        <span class="keyword">case</span> ERROR_LOCKED: <span class="keyword">return</span> ENOLCK;
        <span class="keyword">case</span> ERROR_NEGATIVE_SEEK: <span class="keyword">return</span> EINVAL;
        <span class="keyword">case</span> ERROR_NOACCESS: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_NOT_ENOUGH_MEMORY: <span class="keyword">return</span> ENOMEM;
        <span class="keyword">case</span> ERROR_NOT_READY: <span class="keyword">return</span> EAGAIN;
        <span class="keyword">case</span> ERROR_NOT_SAME_DEVICE: <span class="keyword">return</span> EXDEV;
        <span class="keyword">case</span> ERROR_OPEN_FAILED: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_OPEN_FILES: <span class="keyword">return</span> EBUSY;
        <span class="keyword">case</span> ERROR_OPERATION_ABORTED: <span class="keyword">return</span> ECANCELED;
        <span class="keyword">case</span> ERROR_OUTOFMEMORY: <span class="keyword">return</span> ENOMEM;
        <span class="keyword">case</span> ERROR_PATH_NOT_FOUND: <span class="keyword">return</span> ENOENT;
        <span class="keyword">case</span> ERROR_READ_FAULT: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_RETRY: <span class="keyword">return</span> EAGAIN;
        <span class="keyword">case</span> ERROR_SEEK: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_SHARING_VIOLATION: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> ERROR_TOO_MANY_OPEN_FILES: <span class="keyword">return</span> EMFILE;
        <span class="keyword">case</span> ERROR_WRITE_FAULT: <span class="keyword">return</span> EIO;
        <span class="keyword">case</span> ERROR_WRITE_PROTECT: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> WSAEACCES: <span class="keyword">return</span> EACCES;
        <span class="keyword">case</span> WSAEADDRINUSE: <span class="keyword">return</span> EADDRINUSE;
        <span class="keyword">case</span> WSAEADDRNOTAVAIL: <span class="keyword">return</span> EADDRNOTAVAIL;
        <span class="keyword">case</span> WSAEAFNOSUPPORT: <span class="keyword">return</span> EAFNOSUPPORT;
        <span class="keyword">case</span> WSAEALREADY: <span class="keyword">return</span> EALREADY;
        <span class="keyword">case</span> WSAEBADF: <span class="keyword">return</span> EBADF;
        <span class="keyword">case</span> WSAECONNABORTED: <span class="keyword">return</span> ECONNABORTED;
        <span class="keyword">case</span> WSAECONNREFUSED: <span class="keyword">return</span> ECONNREFUSED;
        <span class="keyword">case</span> WSAECONNRESET: <span class="keyword">return</span> ECONNRESET;
        <span class="keyword">case</span> WSAEDESTADDRREQ: <span class="keyword">return</span> EDESTADDRREQ;
        <span class="keyword">case</span> WSAEFAULT: <span class="keyword">return</span> EFAULT;
        <span class="keyword">case</span> WSAEHOSTUNREACH: <span class="keyword">return</span> EHOSTUNREACH;
        <span class="keyword">case</span> WSAEINPROGRESS: <span class="keyword">return</span> EINPROGRESS;
        <span class="keyword">case</span> WSAEINTR: <span class="keyword">return</span> EINTR;
        <span class="keyword">case</span> WSAEINVAL: <span class="keyword">return</span> EINVAL;
        <span class="keyword">case</span> WSAEISCONN: <span class="keyword">return</span> EISCONN;
        <span class="keyword">case</span> WSAEMFILE: <span class="keyword">return</span> EMFILE;
        <span class="keyword">case</span> WSAEMSGSIZE: <span class="keyword">return</span> EMSGSIZE;
        <span class="keyword">case</span> WSAENETDOWN: <span class="keyword">return</span> ENETDOWN;
        <span class="keyword">case</span> WSAENETRESET: <span class="keyword">return</span> ENETRESET;
        <span class="keyword">case</span> WSAENETUNREACH: <span class="keyword">return</span> ENETUNREACH;
        <span class="keyword">case</span> WSAENOBUFS: <span class="keyword">return</span> ENOBUFS;
        <span class="keyword">case</span> WSAENOPROTOOPT: <span class="keyword">return</span> ENOPROTOOPT;
        <span class="keyword">case</span> WSAENOTCONN: <span class="keyword">return</span> ENOTCONN;
        <span class="keyword">case</span> WSAENOTSOCK: <span class="keyword">return</span> ENOTSOCK;
        <span class="keyword">case</span> WSAEOPNOTSUPP: <span class="keyword">return</span> EOPNOTSUPP;
        <span class="keyword">case</span> WSAEPROTONOSUPPORT: <span class="keyword">return</span> EPROTONOSUPPORT;
        <span class="keyword">case</span> WSAEPROTOTYPE: <span class="keyword">return</span> EPROTOTYPE;
        <span class="keyword">case</span> WSAETIMEDOUT: <span class="keyword">return</span> ETIMEDOUT;
        <span class="keyword">case</span> WSAEWOULDBLOCK: <span class="keyword">return</span> EWOULDBLOCK;
    }
    <span class="keyword">return</span> EPERM;
}

DIR* opendir(<span class="keyword">const</span> <span class="keyword">char</span>* name)
{
    WIN32_FIND_DATAA fdFile;

    <span class="keyword">char</span> sPath[MAX_PATH] = { <span class="number">0</span> };
    strcat(sPath, name);
    strcat(sPath, <span class="string">&quot;\\*.*&quot;</span>);

    HANDLE handle = FindFirstFileA(sPath, &amp;fdFile);

    <span class="keyword">if</span> (handle != INVALID_HANDLE_VALUE)
    {
        DIR* p = calloc(<span class="number">1</span>, <span class="keyword">sizeof</span> * p);
        <span class="keyword">if</span> (p)
        {
            p-&gt;handle = handle;
            <span class="keyword">return</span> p;
        }
        <span class="keyword">else</span>
        {
            FindClose(handle);
        }
    }
    <span class="keyword">else</span>
    {
        errno = convert_windows_getlasterror_to_posix(GetLastError());
    }

    <span class="keyword">return</span> NULL;
}

<span class="keyword">int</span> closedir(DIR* dirp)
{
    FindClose(dirp-&gt;handle);
    free(dirp);
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="keyword">struct</span> dirent* readdir(DIR* dirp)
{
    WIN32_FIND_DATAA fdFile;
    BOOL b = FindNextFileA(dirp-&gt;handle, &amp;fdFile);
    <span class="keyword">if</span> (b)
    {
        <span class="comment">/*clear*/</span>
        memset(&amp;dirp-&gt;dirent, <span class="number">0</span>, <span class="keyword">sizeof</span>(dirp-&gt;dirent));


        <span class="keyword">if</span> (fdFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
        {
            dirp-&gt;dirent.d_type |= DT_DIR;
        }

        <span class="comment">/*worst case trunks the string*/</span>
        strncpy(dirp-&gt;dirent.d_name,
                fdFile.cFileName,
                <span class="keyword">sizeof</span>(dirp-&gt;dirent.d_name) - <span class="number">1</span>);

        <span class="keyword">return</span> &amp;dirp-&gt;dirent;
    }
    <span class="keyword">else</span>
    {
        errno = convert_windows_getlasterror_to_posix(GetLastError());
    }
    <span class="keyword">return</span> NULL;
}

</pre>


<p>sample</p>

<pre>
<span class="keyword">#include</span> &lt;stdio.h&gt;
<span class="keyword">#include</span> &lt;sys/types.h&gt;
<span class="keyword">#include</span> &lt;sys/stat.h&gt;
<span class="keyword">#include</span> <span class="string">&quot;dirent.h&quot;</span>
<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>.h&gt;

<span class="keyword">#define</span> MAX_PATH <span class="number">1024</span>

<span class="comment">//int stat(char*, struct stat*);
</span><span class="keyword">void</span> dirwalk(<span class="keyword">char</span>*, <span class="keyword">void</span> (*fcn)(<span class="keyword">char</span>*));

<span class="comment">/* fsize:  print size of file &quot;name&quot; */</span>
<span class="keyword">void</span> fsize(<span class="keyword">char</span>* name)
{
    <span class="keyword">struct</span> stat stbuf;

    <span class="keyword">if</span> (stat(name, &amp;stbuf) == <span class="number">-1</span>) {
        fprintf(stderr, <span class="string">&quot;fsize: can't access %s\n&quot;</span>, name);
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)
        dirwalk(name, fsize);
    printf(<span class="string">&quot;%8ld %s\n&quot;</span>, stbuf.st_size, name);
}


<span class="comment">/* dirwalk:  apply fcn to all files in dir */</span>
<span class="keyword">void</span> dirwalk(<span class="keyword">char</span>* dir, <span class="keyword">void</span> (*fcn)(<span class="keyword">char</span>*))
{
	<span class="keyword">char</span> name[MAX_PATH];
	<span class="keyword">struct</span> dirent* dp;
	DIR* dfd;

	<span class="keyword">if</span> ((dfd = opendir(dir)) == NULL) {
		fprintf(stderr, <span class="string">&quot;dirwalk: can't open %s\n&quot;</span>, dir);
		<span class="keyword">return</span>;
	}
	<span class="keyword">while</span> ((dp = readdir(dfd)) != NULL) {
		<span class="keyword">if</span> (strcmp(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>
			|| strcmp(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)
			<span class="keyword">continue</span>;	<span class="comment">/* skip self and parent */</span>
		<span class="keyword">if</span> (strlen(dir) + strlen(dp-&gt;d_name) + <span class="number">2</span> &gt; <span class="keyword">sizeof</span>(name))
			fprintf(stderr, <span class="string">&quot;dirwalk: name %s/%s too long\n&quot;</span>,
					dir, dp-&gt;d_name);
		<span class="keyword">else</span> {
			sprintf(name, <span class="string">&quot;%s%s&quot;</span>, dir, dp-&gt;d_name);
			(*fcn)(name);
		}
	}
	closedir(dfd);
}

<span class="keyword">void</span> callback(<span class="keyword">const</span> <span class="keyword">char</span>* name)
{
	printf(<span class="string">&quot;%s\n&quot;</span>, name);
}

<span class="keyword">int</span> main(<span class="keyword">void</span>)
{

	fsize(<span class="string">&quot;C:/Users/thiago/source/repos/iteratedir/&quot;</span>);
    
    <span class="keyword">return</span> EXIT_SUCCESS;
}

</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  