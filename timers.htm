
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 



<h2> Timer events</h2>

<p>Caracteristics:</p>

<ul>
<li> Timer is running and called from a &quot;Timer Thread&quot;</li>
<li> Insertion uses std::sort</li>
<li> Uses only C++ 11 libraries</li>
</ul>

<pre>


<span class="comment">//header
</span><span class="keyword">#include</span> &lt;thread&gt;
<span class="keyword">#include</span> &lt;mutex&gt;
<span class="keyword">#include</span> &lt;condition_variable&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> &lt;chrono&gt;
<span class="keyword">#include</span> &lt;memory&gt;
<span class="keyword">#include</span> &lt;algorithm&gt;

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">class</span> TimerThread
{

<span class="keyword">public</span>:
  <span class="keyword">typedef</span> std::chrono::high_resolution_clock clock_t;
  <span class="keyword">struct</span> TimerInfo
  {
    size_t m_id;
    clock_t::time_point m_TimePoint;
    T m_User;

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> TArg1&gt;
    TimerInfo(clock_t::time_point tp,
              size_t id,
              TArg1 &amp;&amp; arg1)
      : m_TimePoint(tp)
      , m_id(id)
      , m_User(std::forward&lt;TArg1&gt;(arg1))
    {
    }

    TimerInfo(TimerInfo &amp;&amp; other)
      : m_TimePoint(other.m_TimePoint)
      , m_id(other.m_id)
      , m_User(std::move(other.m_User))
    {
    }
  };
<span class="keyword">private</span>:
  std::<span class="keyword2">unique_ptr</span>&lt;std::thread&gt; m_Thread;
  std::<span class="keyword2">vector</span>&lt;TimerInfo&gt;       m_Timers;
  std::mutex                   m_Mutex;
  std::condition_variable      m_Condition;
  <span class="keyword">bool</span>                         m_Sort;
  <span class="keyword">bool</span>                         m_Stop;

  <span class="keyword">void</span> TimerLoop()
  {
    <span class="keyword">for</span> (;;)
    {
      std::unique_lock&lt;std::mutex&gt;  lock(m_Mutex);

      <span class="keyword">while</span> (!m_Stop &amp;&amp; m_Timers.empty())
      {
        m_Condition.wait(lock);
      }

      <span class="keyword">if</span> (m_Stop)
      {
        <span class="keyword">return</span>;
      }

      <span class="keyword">if</span> (m_Sort)
      {
        <span class="comment">//Sort could be done at insert
</span>        <span class="comment">//but probabily this thread has time to do
</span>        std::sort(m_Timers.begin(),
                  m_Timers.end(),
                  [](<span class="keyword">const</span> TimerInfo &amp; ti1, <span class="keyword">const</span> TimerInfo &amp; ti2)
        {
          <span class="keyword">return</span> ti1.m_TimePoint &gt; ti2.m_TimePoint;
        });
        m_Sort = <span class="keyword">false</span>;
      }

      <span class="keyword">auto</span> now = clock_t::now();
      <span class="keyword">auto</span> expire = m_Timers.back().m_TimePoint;
      <span class="keyword">bool</span> callTimer = expire &lt; now;

      <span class="keyword">if</span> (!callTimer) <span class="comment">//can I take a nap?
</span>      {
        <span class="keyword">auto</span> napTime = expire - now;
        m_Condition.wait_for(lock, napTime);

        <span class="keyword">if</span> (!m_Timers.empty())
        {
          <span class="comment">//check again
</span>          <span class="keyword">auto</span> expire = m_Timers.back().m_TimePoint;
          <span class="keyword">auto</span> now = clock_t::now();
          callTimer = expire &lt; now;
        }
      }

      <span class="keyword">if</span> (callTimer)
      {
        TimerInfo timeInfo(std::move(m_Timers.back()));
        m_Timers.pop_back();
        lock.unlock();
        TimerCall(timeInfo);
      }
    }
  }

<span class="keyword">public</span>:
  TimerThread()
    : m_Stop(<span class="keyword">false</span>)
    , m_Sort(<span class="keyword">false</span>)
  {
    m_Thread.reset(<span class="keyword">new</span> std::thread(std::bind(&amp;TimerThread::TimerLoop, <span class="keyword">this</span>)));
  }

  ~TimerThread()
  {
    m_Stop = <span class="keyword">true</span>;
    m_Condition.notify_all();
    m_Thread-&gt;join();
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TArg1&gt;
  <span class="keyword">void</span> CreateTimer(size_t id, <span class="keyword">int</span> ms, TArg1 &amp;&amp; arg1)
  {
    {
      std::unique_lock&lt;std::mutex&gt; lock(m_Mutex);
      m_Timers.push_back(TimerInfo(clock_t::now() + std::chrono::milliseconds(ms),
                                   id,
                                   std::forward&lt;TArg1&gt;(arg1)));
      m_Sort = <span class="keyword">true</span>;
    }
    <span class="comment">// wake up
</span>    m_Condition.notify_one();
  }

  <span class="keyword">void</span> CancelTimer(size_t id)
  {
    {
      std::unique_lock&lt;std::mutex&gt; lock(m_Mutex);

      <span class="keyword">for</span> (<span class="keyword">auto</span> it = m_Timers.begin(); it != m_Timers.end(); it++)
      {
        <span class="keyword">if</span> (it-&gt;m_id == id)
        {
          m_Timers.erase(it);
          <span class="keyword">break</span>;
        }
      }
    }
    <span class="comment">// wake up
</span>    m_Condition.notify_one();
  }
};


<span class="comment">//sample
</span><span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;

TimerThread&lt;std::<span class="keyword2">string</span>&gt; timers;

<span class="keyword">void</span> TimerCall(TimerThread&lt;std::<span class="keyword2">string</span>&gt;::TimerInfo&amp; info)
{
  std::cout &lt;&lt; info.m_User &lt;&lt; std::endl;
  timers.CancelTimer(<span class="number">2</span>);
}

<span class="keyword">int</span> main()
{
  std::cout &lt;&lt; <span class="string">&quot;start&quot;</span> &lt;&lt; std::endl;

  timers.CreateTimer(<span class="number">1</span>, <span class="number">2000</span>, <span class="string">&quot;first&quot;</span>);
  timers.CreateTimer(<span class="number">2</span>, <span class="number">3000</span>, <span class="string">&quot;second&quot;</span>);

  std::this_thread::sleep_for(std::chrono::seconds(<span class="number">5</span>));
  std::cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; std::endl;
}


</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  