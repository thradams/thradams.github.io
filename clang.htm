
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<h1> Additions into C language I would like to have</h1>

<p>September 2020</p>

<p>See the current implementation online : </p>

<p><a href="www.thradams.com/web2/cprime.html">cprime online</a></p>


<h2> Member initializer</h2>

<pre>

<span class="keyword">struct</span> X {
   <span class="keyword">int</span> i = <span class="number">1</span>;
   <span class="keyword">struct</span> Point pt = { .x = <span class="number">1</span>, .y = <span class="number">1</span> };
};

</pre>


<h2> Empty Initializer/Compound literal</h2>

<p>Static initialization using the values of member initializer</p>

<pre>
<span class="keyword">int</span> main() {
   
   <span class="comment">//new syntax
</span>   <span class="keyword">struct</span> X x = {};       
   <span class="keyword">struct</span> X x1[<span class="number">200</span>] = {};   
}

</pre>

<p>This initialization can be used for global scope variables.</p>


<h3> Overloaded functions</h3>

<p>Overload functions are functions with name mangling. </p>

<pre>
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* p) overload;
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* p) overload;
</pre>



<p>See reference:<a href="https://clang.llvm.org/docs/AttributeReference.html#overloadable">https://clang.llvm.org/docs/AttributeReference.html#overloadable</a></p>



<h3> New function</h3>

<p>New is an especial function that calls malloc and if malloc suceededit  initializes the object using the compound literal.</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name;
};

<span class="keyword">int</span> main() {

  <span class="keyword">struct</span> X* pX = <span class="keyword">new</span>((<span class="keyword">struct</span> X) {});
  <span class="keyword">if</span> (pX != NULL)
  {
    assert(pX-&gt;name == NULL);
    
    ...

    free(pX-&gt;name);
  }
}

</pre>


<h2> Destroy</h2>
<p>Destroy is a especial function that is generated but also calla user function to destroy the object.</p>

<p>See the sample:</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name = NULL;
};

<span class="keyword">void</span> destroy(<span class="keyword">struct</span> X* pX) overload {
   free(pX-&gt;name);
}

<span class="keyword">struct</span> Y {
    <span class="keyword">struct</span> X x;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> Y y = {};
  destroy(y);
}

</pre>



<h2> Auto pointers</h2>

<p>Pointers can be qualified with auto. This tells the type systemthat this pointer is the onwer of the pointed object.</p>


<pre>
<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * <span class="keyword">auto</span> name = NULL;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> X x = {};
  destroy(x);
}

</pre>


<p>When auto pointers are destroyed they check if the pointer is not nulland then destroy the content  of the pointer.</p>

<h2> if with initializer </h2>
<p>Same of C++.  Togueter with auto it creates an interting pattern.</p>

<pre>

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p)
  {
    <span class="comment">//pX in scope AND != NULL
</span>    ..
    destroy(pX);
  }
  <span class="comment">//pX not in scope
</span>
</pre>
<p>`</p>

<h2> if with initializer  and final expression</h2>


<pre>
  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p, destroy(pX))
  {
    ...
    <span class="comment">/* final expression goes here*/</span>
  }

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p, destroy(pX))
  {
      <span class="comment">/* final expression goes here*/</span>
      <span class="keyword">break</span>;
      <span class="keyword">return</span>;
      <span class="keyword">goto</span> label:
  }


</pre>
<p>`</p>

<h2> Lambdas </h2>
<p>Similar of C++.</p>

<h2> Polimorphism</h2>

<p>Pointers that can point to a especific set of types.</p>

<p>If you set of types have a common discriminant we also can select the appropriated operator in runtime according with the type.</p>

<p>Sample:</p>
<pre>
 
<span class="keyword">struct</span> Box {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">1</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* pBox) overload {
    printf(<span class="string">&quot;Box&quot;</span>);
}

<span class="keyword">struct</span> Circle {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">2</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* pCircle) overload {
    printf(<span class="string">&quot;Circle&quot;</span>);
}

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> &lt;Box | Circle&gt; * <span class="keyword">auto</span> shapes[<span class="number">2</span>] = {};
  
  shapes[<span class="number">0</span>] = <span class="keyword">new</span> ((<span class="keyword">struct</span> Box){});
  shapes[<span class="number">1</span>] = <span class="keyword">new</span> ((<span class="keyword">struct</span> Circle){});
  
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)
  {    
    <span class="comment">//runtime selecion according with the discriminant
</span>    <span class="comment">//auto generated  draw for shape
</span>    draw(shapes[i]); 
    
    <span class="comment">//when types have a common discriminant it is available
</span>    printf(<span class="string">&quot;%d&quot;</span>, shapes[i].id);
  }
  
  destroy(shapes);
}

</pre>


<h2> Resizable arrays [auto]</h2>


<pre>
<span class="keyword">int</span> a[<span class="keyword">auto</span>];
 
 capacity(a);
 size(a);
 push(a, <span class="number">1</span>);
 reserve(a, <span class="number">10</span>);
 
 a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//ok
</span> 
</pre>





<!-- Page content end --> 
</article> 
 
</body> 
</html>  