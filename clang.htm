
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<h1> Additions into C language I would like to have</h1>

<p>September 2020</p>

<p>See the current implementation online  </p>

<p><a href="/web2/cprime.html">cprime online</a></p>


<h2> Member initializer</h2>

<pre>

<span class="keyword">struct</span> X {
   <span class="keyword">int</span> i = <span class="number">1</span>;
   <span class="keyword">struct</span> Point pt = { .x = <span class="number">1</span>, .y = <span class="number">1</span> };
};

</pre>


<p>C++ compararion: This is very similar. The only diference is that in C++ the init expression does not need to be a constant expression.</p>



<h2> Empty Initializer/Compound literal</h2>

<p>Static initialization using the values of member initializer. </p>

<pre>
<span class="keyword">int</span> main() {
   
   <span class="comment">//new syntax
</span>   <span class="keyword">struct</span> X x = {};       
   <span class="keyword">struct</span> X x1[<span class="number">200</span>] = {};
}

</pre>


<p>This initialization can be used for global scope variables.</p>


<h3> Overloaded functions</h3>

<p>Overload functions are functions with name mangling. </p>

<pre>
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* p) overload;
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* p) overload;
</pre>


<p>See reference :<a href="https://clang.llvm.org/docs/AttributeReference.html#overloadable">https://clang.llvm.org/docs/AttributeReference.html#overloadable</a></p>

<p>We can think of it as an inverse of extern &quot;C&quot;.</p>


<h3> New operator</h3>


<pre>
 postfix-expression:
   new (type-name)
   new (type-name) { }
   new (type-name) { initializer-list }
</pre>

<p>The new operator allocates memory (using malloc) and if it succeeds it initialize the memory using the compound literal. </p>

<p><a href="https://en.cppreference.com/w/c/language/compound_literal">https://en.cppreference.com/w/c/language/compound_literal</a></p>

<p>The { initializer-list } can be omitted and in this case it results in the default.</p>



<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name;
};

<span class="keyword">int</span> main() {

  <span class="keyword">struct</span> X* pX = <span class="keyword">new</span> (<span class="keyword">struct</span> X) {};
  <span class="keyword">if</span> (pX != NULL)
  {
    free(pX-&gt;name);
  }
}

</pre>

<p>Comparion with C++: There is not constructor here. There is no need for exceptions.</p>

<p>Open question: Should we accept string literals?</p>

<pre>
<span class="keyword">char</span>  *s = <span class="keyword">new</span> (<span class="string">&quot;text&quot;</span>);
</pre>
<p>`</p>

<p>Open design: How to customize the allocator global or for types.</p>


<pre>

<span class="comment">//global
</span><span class="keyword">void</span> cprime_free(<span class="keyword">void</span>*)  {}
<span class="keyword">void</span>* cprime_new(<span class="keyword">int</span> size, <span class="keyword">void</span>* <span class="keyword">default</span>) {}

<span class="comment">//for an especific type
</span><span class="keyword">void</span> free(<span class="keyword">struct</span> X * <span class="keyword">auto</span> pX) overload {}
<span class="keyword">struct</span> X * <span class="keyword">auto</span> <span class="keyword">new</span>(<span class="keyword">int</span> size, <span class="keyword">void</span>* <span class="keyword">default</span>) overload {}

</pre>






<h2> Destroy operator</h2>

<p>Destroy operator instantiates an especial function that is used to destroy object parts recursively.</p>


<p>The user can optionally inform a destructor (overloading destroy function) that is called just before the object destruction.</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name = NULL;
};

<span class="keyword">void</span> destroy(<span class="keyword">struct</span> X* pX) overload {
   free(pX-&gt;name);
}

<span class="keyword">struct</span> Y {
    <span class="keyword">struct</span> X x;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> Y y = {};
  destroy(y);
}

</pre>


<h2> Auto pointers</h2>

<p>Pointers can be qualified with auto. This tells the type system that this pointer is the onwer of the pointed object.</p>

<p>This information is used to generate destructors.</p>

<pre>
<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * <span class="keyword">auto</span> name = NULL;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> X x = {};
  destroy(x);
}

</pre>


<p>When a pointer qualified with auto is destroyed it calls the destructor of the pointed object. So in this case the user does not need to overload destroy and free the name. He also can do this, in this case just removing auto.</p>


<h2> if with initializer </h2>

<p>This is the same of C++.  </p>

<p>Together with auto it creates an interesting pattern.</p>

<pre>

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> (<span class="keyword">struct</span> X), p)
  {
    <span class="comment">/*The scope of pX corresponds where it is alive*/</span>
    destroy(pX);
  }
  

</pre>
<p>`</p>

<h2> if with initializer and defer</h2>

<p>Here we add an extra expression that is executed at the end of scope.</p>

<pre>
  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> (<span class="keyword">struct</span> X), p, destroy(pX))
  {
        
  }

</pre>


<p>Open question:  What happend when break, return or goto is called?</p>

<p>Option 1: ban these keywords in this context.</p>

<p>Option2: call the defer expression before jump.</p>


<h2> Lambdas </h2>

<p>Similar of C++ but without capture.</p>

<pre>
 lambda-expression:
    [] ( parameters opt ) compound-statement
    [] compound-statement
</pre>


<h2> Polimorphism</h2>

<p>Pointers that can point to a especific <strong>set of types</strong>.</p>

<p>If you set of types have a <strong>common discriminant</strong> we also can  select the appropriated object in runtime according with the type.</p>

<p>Sample:</p>

<pre>
 
<span class="keyword">struct</span> Box {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">1</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* pBox) overload {
    printf(<span class="string">&quot;Box&quot;</span>);
}

<span class="keyword">struct</span> Circle {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">2</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* pCircle) overload {
    printf(<span class="string">&quot;Circle&quot;</span>);
}

<span class="keyword">struct</span> &lt;Box | Circle&gt; Shape;

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> Shape * <span class="keyword">auto</span> shapes[<span class="number">2</span>] = {};
  
  shapes[<span class="number">0</span>] = <span class="keyword">new</span> (<span class="keyword">struct</span> Box);
  shapes[<span class="number">1</span>] = <span class="keyword">new</span> (<span class="keyword">struct</span> Circle);
  
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)
  {    
    draw(shapes[i]); 

    printf(<span class="string">&quot;%d&quot;</span>, shapes[i].id);
  }
  
  destroy(shapes);
}

</pre>


<h2> Resizable arrays [auto]</h2>


<pre>
<span class="keyword">int</span> a[<span class="keyword">auto</span>];
 
 capacity(a);
 size(a);
 push(a, <span class="number">1</span>);
 reserve(a, <span class="number">10</span>);
 a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//ok
</span> 
</pre>


<p>(not implemented yet)</p>




<!-- Page content end --> 
</article> 
 
</body> 
</html>  