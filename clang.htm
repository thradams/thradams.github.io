
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<h1> The language between C and C++ I would like to have</h1>

<p>05 september 2020</p>

<h2> Objetive</h2>

<p>- Remove boilerplate code.</p>

<p>When reading this document consider that the features are additions into C and not changes in C++.</p>

<h2> Member initializer</h2>

<pre>

<span class="keyword">struct</span> X {
   <span class="keyword">int</span> i = <span class="number">1</span>;
   <span class="keyword">struct</span> Point pt = { .x = <span class="number">1</span>, .y = <span class="number">1</span> };
};

</pre>


<h2> Empty Initializer/Compound literal</h2>

<p>Static initialization using the values of member initializer</p>

<pre>
<span class="keyword">int</span> main() {
   
   <span class="comment">//new syntax
</span>   <span class="keyword">struct</span> X x = {};       
   <span class="keyword">struct</span> X x1[<span class="number">200</span>] = {};   
}

</pre>


<p>This initialization works for global static variables.There is no runtime function called like C++ constructor.Diferently from C++, we only accept constants. </p>

<h3> Overloaded functions</h3>

<p>Overload functions are especial functions with name mangling.</p>

<pre>
void draw(struct X* p) overload;
</pre>

<p>See reference:<a href="https://clang.llvm.org/docs/AttributeReference.html#overloadable">https://clang.llvm.org/docs/AttributeReference.html#overloadable</a></p>



<h3> new and destroy functions</h3>


<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name = NULL;
};

<span class="keyword">int</span> main() {
  <span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span>((<span class="keyword">struct</span> X) {});
  destroy(pX);
}

</pre>


<h2> Auto pointers</h2>

<p>Pointers can be qualified with auto.</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * <span class="keyword">auto</span> name = NULL;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> X x0 = {};
  <span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span>((<span class="keyword">struct</span> X){});  

  destroy(x0);
  destroy(pX);
}

</pre>


<h2> if with initializer </h2>
<p>Same of C++.  Togueter with auto it creates an interting pattern.</p>

<pre>

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p)
  {
    <span class="comment">//pX in scope AND != NULL
</span>    ..
    destroy(pX);
  }
  <span class="comment">//pX not in scope
</span>
</pre>
<p>`</p>

<h2> if with initializer  and final expression</h2>


<pre>
  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p, destroy(pX))
  {
    ...
    <span class="comment">/* final expression goes here*/</span>
  }

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* <span class="keyword">auto</span> pX = <span class="keyword">new</span> ((<span class="keyword">struct</span> X){}), p, destroy(pX))
  {
      <span class="comment">/* final expression goes here*/</span>
      <span class="keyword">break</span>;
      <span class="keyword">return</span>;
      <span class="keyword">goto</span> label:
  }


</pre>
<p>`</p>

<h2> Lambdas </h2>
<p>Similar of C++.</p>

<h2> Polimorphism</h2>

<p>Pointers that can point to a especific set of types.</p>

<p>If you set of types have a common discriminant we also can select the appropriated operator in runtime according with the type.</p>

<p>Sample:</p>
<pre>
 
<span class="keyword">struct</span> Box {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">1</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* pBox) overload {
    printf(<span class="string">&quot;Box&quot;</span>);
}

<span class="keyword">struct</span> Circle {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">2</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* pCircle) overload {
    printf(<span class="string">&quot;Circle&quot;</span>);
}

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> &lt;Box | Circle&gt; * <span class="keyword">auto</span> shapes[<span class="number">2</span>] = {};
  
  shapes[<span class="number">0</span>] = <span class="keyword">new</span> ((<span class="keyword">struct</span> Box){});
  shapes[<span class="number">1</span>] = <span class="keyword">new</span> ((<span class="keyword">struct</span> Circle){});
  
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)
  {    
    <span class="comment">//runtime selecion according with the discriminant
</span>    <span class="comment">//auto generated  draw for shape
</span>    draw(shapes[i]); 
    
    <span class="comment">//when types have a common discriminant it is available
</span>    printf(<span class="string">&quot;%d&quot;</span>, shapes[i].id);
  }
  
  destroy(shapes);
}

</pre>


<h2> Resizable arrays [auto]</h2>


<pre>
<span class="keyword">int</span> a[<span class="keyword">auto</span>];
 
 capacity(a);
 size(a);
 push(a, <span class="number">1</span>);
 reserve(a, <span class="number">10</span>);
 
 a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//ok
</span> 
</pre>


<h2> Standard build system </h2>
<p>Pragma source is a way to make source files discoverable respecting platform configuration.This allow compilers and other tools like lint finds the source code in a standard way.</p>

<p><a href="pragmasource.htm">Pragma source</a></p>





<!-- Page content end --> 
</article> 
 
</body> 
</html>  