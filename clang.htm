
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 


<h1> Part I - Additions into C language I would like to have</h1>

<p>September 2020</p>

<p>I have implemented these features in a c compiler that generatesc code.</p>

<p><a href="/web2/cprime.html">cprime online</a></p>


<h2> Struct member initializer</h2>

<pre>

<span class="keyword">struct</span> X {
   <span class="keyword">int</span> i = <span class="number">1</span>;
   <span class="keyword">struct</span> Point pt = { .x = <span class="number">1</span>, .y = <span class="number">1</span> };
};

</pre>


<h2> Empty Initializer/Compound literal</h2>

<p><strong>Static initialization</strong> using the values of member initializer. </p>

<pre>
<span class="keyword">int</span> main() {
   
   <span class="keyword">struct</span> X x = {};       
   <span class="keyword">struct</span> X x1[<span class="number">200</span>] = {};

   x = (<span class="keyword">struct</span> X) {};       

}

</pre>


<p>Default initialization and struct member initializers are part of C++.Designed initializers also were added into C++ 20.</p>

<p>While I was implementing this feature I check against C++ and I am  disappointed by the following.</p>

<pre>

<span class="keyword">struct</span> point {
    <span class="keyword">int</span> x = <span class="number">1</span>;
    <span class="keyword">int</span> y = <span class="number">2</span>;
};

<span class="keyword">struct</span> line {
  <span class="keyword">struct</span> point point = { .x= <span class="number">3</span>, .y = <span class="number">4</span> };
};

<span class="keyword">int</span> main() {
  <span class="keyword">struct</span> line line = { .point = { .x = <span class="number">5</span>} };
  printf(<span class="string">&quot;%d\n&quot;</span>, line.point.y);
}

</pre>


<p>This sample prints 2 in C++. So it does not take in account the default values of point variable in line.</p>

<p>I was planing to print 4 because this is the default of variable point in line.</p>

<p>This king of incompatibility with C++ would be very dangerous and I am holding this implementation.</p>



<h2> if with initializer </h2>

<p>This is the same of C++ 17. </p>

<pre>

  <span class="keyword">if</span> (<span class="keyword">struct</span> X* pX = malloc(<span class="keyword">sizeof</span> * pX), pX)
  {    
    ...
    free(pX);
  }
  
  <span class="comment">//pX out of scope
</span>
</pre>
<p>`</p>

<h2> if with initializer and defer</h2>

<p>Considering the interesting pattern above (that is very useful to avoid bugs) we also have an option with 'defer' to put everything at same line.</p>

<pre>
  <span class="keyword">if</span> (FILE* f = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), f, fclose(f))
  {        
     
  }
</pre>



<p>Open question:  What happens when break, return or goto is called?</p>

<p>Option 1: ban these keywords in this context.</p>

<p>Option2: call the defer expression before jump.</p>


<h2> Lambdas </h2>

<p>Similar of C++ but without capture.</p>

<pre>
 lambda-expression:
    [] ( parameters opt ) compound-statement
    [] compound-statement
</pre>


<h1> Part II - Features for a "light C++"</h1>

<h3> Overloaded functions</h3>

<p>Overload functions are functions with name mangling. </p>

<pre>
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* p) overload;
<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* p) overload;
</pre>


<p>See reference :<a href="https://clang.llvm.org/docs/AttributeReference.html#overloadable">https://clang.llvm.org/docs/AttributeReference.html#overloadable</a></p>

<p>We can think of it as an inverse of extern &quot;C&quot;.</p>


<h3> New operator</h3>


<pre>
 postfix-expression:
   new (type-name)
   new (type-name) { }
   new (type-name) { initializer-list }
</pre>

<p>The objective of the new operator is allocate memory an them copy the default compound literal or user provided compound literal,</p>

<p>The allocation is done using malloc.</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name;
};

<span class="keyword">int</span> main() {

  <span class="keyword">struct</span> X* pX = <span class="keyword">new</span> (<span class="keyword">struct</span> X) {};
  <span class="keyword">if</span> (pX != NULL)
  {
    free(pX-&gt;name);
  }
}

</pre>

<p>Comparison with C++: There is not constructor here. There is no need for exceptions.</p>

<p>Open question: Should we accept string literals?</p>

<pre>
<span class="keyword">char</span>  *s = <span class="keyword">new</span> (<span class="string">&quot;text&quot;</span>);
</pre>
<p>`</p>

<h2> Destroy operator</h2>

<p>Destroy operator instantiates an especial function that is used to destroy object parts recursively.</p>


<p>The user can optionally inform a destructor (overloading destroy function) that is called just before the object destruction.</p>

<pre>

<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name = NULL;
};

<span class="keyword">void</span> destroy(<span class="keyword">struct</span> X* pX) overload {
   free(pX-&gt;name);
}

<span class="keyword">struct</span> Y {
    <span class="keyword">struct</span> X x;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> Y y = {};
  destroy(y);
}

</pre>


<h2> Auto pointers</h2>

<p>Pointers can be qualified with auto. </p>

<p>This tells the type system that this pointer is the owner of the pointed object.</p>

<p>At this moment auto is used to generate destructors but it also could be used for static analysis in the future.</p>


<pre>
<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * <span class="keyword">auto</span> name = NULL;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> X x = {};
  destroy(x);
}

</pre>


<p>When a pointer qualified with auto is destroyed it calls the destructor of the pointed object.</p>

<p>Alternatively we can do,</p>

<pre>
<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * name = NULL;
};

<span class="keyword">void</span> destroy(<span class="keyword">struct</span> X* p) { free(p-&gt;name); }

<span class="keyword">int</span> main() {
  <span class="keyword">struct</span> X x = {};
  destroy(x);
}

</pre>


<pre>
<span class="keyword">struct</span> X {
    <span class="keyword">char</span> * <span class="keyword">auto</span> name = NULL;
};

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> X* pX = <span class="keyword">new</span> (<span class="keyword">struct</span> X);
  destroy(pX); <span class="comment">//warning does nothing
</span>  destroy(*pX); <span class="comment">//destroy the object but does not free memory
</span>
  <span class="keyword">struct</span> X* <span class="keyword">auto</span> pAuto = <span class="keyword">new</span> (<span class="keyword">struct</span> X);
  destroy(pAuto); <span class="comment">//destroy the pointed object and calls free
</span>  destroy(*pAuto); <span class="comment">//destroy the object but does not free memory
</span>}

</pre>





<h2> Polymorphism</h2>

<p>Pointers that can point to a specific <strong>set of struct types</strong>. </p>

<p>Syntax:</p>


<pre>
 struct &lt;tag-list&gt; 
 
 tag-list:
  identifier
  identifier , tag-list
</pre>

<pre>
 <span class="keyword">struct</span> &lt;X | Y&gt;* p; <span class="comment">// points to struct X or struct Y (or equivalent typedef) 
</span></pre>


<p>Structs must have a <strong>common discriminant</strong> that is usedin runtime to select the appropriated type.</p>

<p>For instance:</p>

<pre>
 <span class="keyword">struct</span> X {  <span class="keyword">int</span> type = <span class="number">1</span>;  }
 <span class="keyword">struct</span> Y {  <span class="keyword">int</span> type = <span class="number">2</span>;  }
</pre>


<p>We can define a name for this type without typedef</p>

<pre>

 <span class="keyword">struct</span> &lt;Box | Circle&gt; Shape;

 <span class="keyword">struct</span> Shape* pShape;
</pre>


<p>This name can be used in other pointers and the result is the union set of types.</p>

<pre>
 <span class="keyword">struct</span> &lt;Shape | Data&gt; Serializable;
</pre>



<p>The definition of the struct is automatic (auto generated). We provide only the declaration.</p>




<p>Sample:</p>

<pre>
 
<span class="keyword">struct</span> Box {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">1</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Box* pBox) overload {
    printf(<span class="string">&quot;Box&quot;</span>);
}

<span class="keyword">struct</span> Circle {
    <span class="keyword">const</span> <span class="keyword">int</span> id = <span class="number">2</span>; <span class="comment">//discriminant
</span>};

<span class="keyword">void</span> draw(<span class="keyword">struct</span> Circle* pCircle) overload {
    printf(<span class="string">&quot;Circle&quot;</span>);
}

<span class="keyword">struct</span> &lt;Box | Circle&gt; Shape;

<span class="keyword">int</span> main()
{
  <span class="keyword">struct</span> Shape * <span class="keyword">auto</span> shapes[<span class="number">2</span>] = {};
  
  shapes[<span class="number">0</span>] = <span class="keyword">new</span> (<span class="keyword">struct</span> Box);
  shapes[<span class="number">1</span>] = <span class="keyword">new</span> (<span class="keyword">struct</span> Circle);
  
  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)
  {    
    draw(shapes[i]); 

    printf(<span class="string">&quot;%d&quot;</span>, shapes[i].id);
  }
  
  destroy(shapes);
}

</pre>


<p>The discriminant can be constant strings or enuns etc.</p>

<pre>
<span class="keyword">struct</span> Box {
    <span class="keyword">const</span> <span class="keyword">char</span> * type= <span class="string">&quot;box&quot;</span>;
};

<span class="keyword">struct</span> Circle {
    <span class="keyword">const</span> <span class="keyword">char</span> * type= <span class="string">&quot;circle&quot;</span>;
};
</pre>


<p>(strings are not implemented yet)</p>

<p>We also need a way to cast. The syntax is a open question but the C++ syntax can be used.</p>

<pre>
<span class="keyword">struct</span> Box *pBox = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">struct</span> Box*&gt;(pShape);
</pre>


<p>Alternatives:</p>
<pre>
<span class="keyword">struct</span> Box *pBox = pShape as Box;

<span class="keyword">if</span> (pShape is Box)
{

}
</pre>

<p>Cast from box to shape for instance are normal casts but in the future the compiler can check the if the types are on the same set. </p>


<h2> Resizable arrays [auto]</h2>


<pre>
<span class="keyword">int</span> a[<span class="keyword">auto</span>];
 
  capacity(a);
  size(a);
  push(a, <span class="number">1</span>);
  reserve(a, <span class="number">10</span>);
  a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//ok
</span> 
</pre>


<p>(not implemented yet)</p>



<h2> Parametrized types</h2>

<p>(not implemented yet)</p>

<pre>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> <span class="keyword2">vector</span>{
  T * data;
  <span class="keyword">int</span> size;
  <span class="keyword">int</span> capacity;
};

<span class="keyword">void</span> F(<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt; * v) {}

</pre>


<h2> Parametrized functions</h2>


<pre>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">struct</span> <span class="keyword2">vector</span>
{
  T * data;
  <span class="keyword">int</span> size;
  <span class="keyword">int</span> capacity;
};

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> destroy(<span class="keyword2">vector</span>&lt;T&gt; * v) 
{

}

<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> push(<span class="keyword2">vector</span>&lt;T&gt; * v, T i) {

}

<span class="keyword">int</span> main()
{
   <span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt; v = {};
   push(v, <span class="number">1</span>);
   destroy(v);
}
<span class="comment">/*
  if T is struct is is passed by pointer otherwise by copy. 
*/</span>

</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  