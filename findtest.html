<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<a class = "linkbox" href = "codeblog.html">CODE-BLOG</a>
<a class = "linkbox" href = "about.html">ABOUT </a>
<p>C code for generating string-switch</p>

<p>Se <a href="switchgenerator.html">Online</a></p>

<pre><code class="language-cpp">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

 
struct Stopwatch
{
    clock_t m_StartCount;
    clock_t m_StopCount;
};

bool Stopwatch_IsRunning(struct Stopwatch* stopwatch)
{
    return stopwatch-&gt;m_StartCount != 0 &amp;&amp; stopwatch-&gt;m_StopCount == 0;
}

size_t GetFrequency() //in milliseconds
{
    return CLOCKS_PER_SEC / 1000;
}

void Stopwatch_Reset(struct Stopwatch* stopwatch)
{
    stopwatch-&gt;m_StopCount = 0;
    stopwatch-&gt;m_StartCount = 0;


}

void Stopwatch_Start(struct Stopwatch* stopwatch)
{
    bool resume = (stopwatch-&gt;m_StartCount != 0);
    if (resume)
        stopwatch-&gt;m_StopCount = 0;
    else
    {
        stopwatch-&gt;m_StartCount = clock();
    }

    //assert(Stopwatch_IsRunning());
}

void Stopwatch_Stop(struct Stopwatch* stopwatch)
{
    stopwatch-&gt;m_StopCount = clock();
}

clock_t Stopwatch_GetElapsedTicks(struct Stopwatch* stopwatch)
{
    if (Stopwatch_IsRunning(stopwatch))
        return (clock() - stopwatch-&gt;m_StartCount);

    return (stopwatch-&gt;m_StopCount - stopwatch-&gt;m_StartCount);
}

clock_t Stopwatch_GetElapsedMilliseconds(struct Stopwatch* stopwatch)
{
    return Stopwatch_GetElapsedTicks(stopwatch) / (CLOCKS_PER_SEC / 1000);
}



void GenerateCore(const char* keywords[], int first, int last, int level, int* count)
{
    int ident = (level + 1) * 2;
    printf(&quot;%*cswitch (text[%d])\n&quot;, ident, &#39; &#39;, level);
    printf(&quot;%*c{\n&quot;, ident, &#39; &#39;);

    for (int i = first; i &lt;= last; i++)
    {
        int begin = i;
        int end = begin;
        for (int k = i + 1; k &lt;= last; k++)
        {
            if (keywords[k][level] == keywords[begin][level])
            {
                i++;
                end++;
            }
            else
                break;
        }

        //we have the range
        if (begin == end)
        {
            //just one
            printf(&quot;%*ccase &#39;%c&#39;: /*%s*/ if (&quot;,
                ident * 2, &#39; &#39;, keywords[i][level], keywords[i]);

            int len = strlen(keywords[i]);

            int j = level + 1;
            for (; j &lt; len; j++)
            {
                if (j != level + 1)
                    printf(&quot;&amp;&amp;&quot;);

                printf(&quot;text[%d]==&#39;%c&#39;&quot;, j, keywords[i][j]);
            }
            if (j != level + 1)
                printf(&quot;&amp;&amp;&quot;);
            printf(&quot;text[%d]==&#39;\\0&#39;&quot;, j);

            printf(&quot;) result = %d; break;\n&quot;, *count);

            (*count)++;
        }
        else
        {
            printf(&quot;%*ccase &#39;%c&#39;:\n&quot;, ident * 2, &#39; &#39;, keywords[i][level]);
            GenerateCore(keywords, begin, end, level + 1, count);
            printf(&quot;%*cbreak;\n&quot;, ident * 2, &#39; &#39;);
        }

    }
    printf(&quot;%*cdefault : break;\n&quot;, ident * 2, &#39; &#39;);

    printf(&quot;%*c}\n&quot;, ident, &#39; &#39;);
}


void GenerateCore1(const char* keywords[], int first, int last, int level, int* count)
{
    int ident = (level + 1) * 2;
    printf(&quot;%*cswitch (text[%d])\n&quot;, ident, &#39; &#39;, level);
    printf(&quot;%*c{\n&quot;, ident, &#39; &#39;);

    for (int i = first; i &lt;= last; i++)
    {
        int begin = i;
        int end = begin;
        for (int k = i + 1; k &lt;= last; k++)
        {
            if (keywords[k][level] == keywords[begin][level])
            {
                i++;
                end++;
            }
            else
                break;
        }

        //we have the range
        if (begin == end)
        {
            //just one
            printf(&quot;%*ccase &#39;%c&#39;: /*%s*/ if (strcmp(text, \&quot;%s\&quot;) == 0) result = %d; break;\n&quot;, 
                ident * 2, &#39; &#39;, keywords[i][level], keywords[i],
                keywords[i],
                *count);

            (*count)++;
        }
        else
        {
            printf(&quot;%*ccase &#39;%c&#39;:\n&quot;, ident * 2, &#39; &#39;, keywords[i][level]);
            GenerateCore1(keywords, begin, end, level + 1, count);
            printf(&quot;%*cbreak;\n&quot;, ident * 2, &#39; &#39;);
        }

    }
    printf(&quot;%*cdefault : break;\n&quot;, ident * 2, &#39; &#39;);

    printf(&quot;%*c}\n&quot;, ident, &#39; &#39;);
}


void GenerateCore10(const char* keywords[], int first, int last, int level, int* count)
{
    int ident = (level + 1) * 2;
    printf(&quot;%*cswitch (text[%d])\n&quot;, ident, &#39; &#39;, level);
    printf(&quot;%*c{\n&quot;, ident, &#39; &#39;);

    for (int i = first; i &lt;= last; i++)
    {
        int begin = i;
        int end = begin;
        for (int k = i + 1; k &lt;= last; k++)
        {
            if (keywords[k][level] == keywords[begin][level])
            {
                i++;
                end++;
            }
            else
                break;
        }

        //we have the range
        if (begin == end)
        {
            //just one
            printf(&quot;%*ccase &#39;%c&#39;: /*%s*/ if (strcmp(&amp;text[%d], \&quot;%s\&quot;) == 0) result = %d; break;\n&quot;,
                ident * 2, &#39; &#39;, keywords[i][level], keywords[i],
                level + 1, &amp;keywords[i][level + 1],
                *count);

            (*count)++;
        }
        else
        {
            printf(&quot;%*ccase &#39;%c&#39;:\n&quot;, ident * 2, &#39; &#39;, keywords[i][level]);
            GenerateCore10(keywords, begin, end, level + 1, count);
            printf(&quot;%*cbreak;\n&quot;, ident * 2, &#39; &#39;);
        }

    }
    printf(&quot;%*cdefault : break;\n&quot;, ident * 2, &#39; &#39;);

    printf(&quot;%*c}\n&quot;, ident, &#39; &#39;);
}



void GenerateCore2(const char* keywords[], int first, int last, int level, int* count)
{
    int ident = (level + 1) * 2;
    printf(&quot;%*cswitch (text[%d])\n&quot;, ident, &#39; &#39;, level);
    printf(&quot;%*c{\n&quot;, ident, &#39; &#39;);

    for (int i = first; i &lt;= last; i++)
    {
        int begin = i;
        int end = begin;
        for (int k = i + 1; k &lt;= last; k++)
        {
            if (keywords[k][level] == keywords[begin][level])
            {
                i++;
                end++;
            }
            else
                break;
        }

        printf(&quot;%*ccase &#39;%c&#39;:\n&quot;, ident * 2, &#39; &#39;, keywords[i][level]);
        for (int j = begin; j &lt;= end; j++)
        {
            printf(&quot;%*c&quot;, ident * 3, &#39; &#39;);
            if (j != begin)
                printf(&quot;else &quot;);

            printf(&quot;if (strcmp(\&quot;%s\&quot;, text) == 0) result = %d;\n&quot;, keywords[j], *count);

            (*count)++;
        }

        printf(&quot;%*cbreak;\n&quot;, ident * 2, &#39; &#39;);


    }
    printf(&quot;%*cdefault : break;\n&quot;, ident * 2, &#39; &#39;);

    printf(&quot;%*c}\n&quot;, ident, &#39; &#39;);
}


void Generate(const char* keywords[], int size)
{
    printf(&quot;int find(const char* text)\n&quot;);
    printf(&quot;{\n&quot;);
    int count = 0;
    printf(&quot;%*cint result = -1;\n&quot;, 2, &#39; &#39;);
    GenerateCore(keywords, 0, size - 1, 0, &amp;count);
    printf(&quot;%*creturn result;\n&quot;, 2, &#39; &#39;);
    printf(&quot;}\n&quot;);
}

void Generate2(const char* keywords[], int size)
{
    printf(&quot;int find2(const char* text)\n&quot;);
    printf(&quot;{\n&quot;);
    int count = 0;
    printf(&quot;%*cint result = -1;\n&quot;, 2, &#39; &#39;);
    GenerateCore2(keywords, 0, size - 1, 0, &amp;count);
    printf(&quot;%*creturn result;\n&quot;, 2, &#39; &#39;);
    printf(&quot;}\n&quot;);
}

void Generate1(const char* keywords[], int size)
{
    printf(&quot;int find1(const char* text)\n&quot;);
    printf(&quot;{\n&quot;);
    int count = 0;
    printf(&quot;%*cint result = -1;\n&quot;, 2, &#39; &#39;);
    GenerateCore1(keywords, 0, size - 1, 0, &amp;count);
    printf(&quot;%*creturn result;\n&quot;, 2, &#39; &#39;);
    printf(&quot;}\n&quot;);
}


int find(const char* text)
{
    int result = -1;
    switch (text[0])
    {
    case &#39;a&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*alignof*/ if (text[2] == &#39;i&#39; &amp;&amp; text[3] == &#39;g&#39; &amp;&amp; text[4] == &#39;n&#39; &amp;&amp; text[5] == &#39;o&#39; &amp;&amp; text[6] == &#39;f&#39; &amp;&amp; text[7] == &#39;\0&#39;) result = 0; break;
        case &#39;u&#39;: /*auto*/ if (text[2] == &#39;t&#39; &amp;&amp; text[3] == &#39;o&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 1; break;
        default: break;
        }
        break;
    case &#39;b&#39;: /*break*/ if (text[1] == &#39;r&#39; &amp;&amp; text[2] == &#39;e&#39; &amp;&amp; text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;k&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 2; break;
    case &#39;c&#39;:
        switch (text[1])
        {
        case &#39;a&#39;: /*case*/ if (text[2] == &#39;s&#39; &amp;&amp; text[3] == &#39;e&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 3; break;
        case &#39;h&#39;: /*char*/ if (text[2] == &#39;a&#39; &amp;&amp; text[3] == &#39;r&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 4; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;n&#39;:
                switch (text[3])
                {
                case &#39;s&#39;: /*const*/ if (text[4] == &#39;t&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 5; break;
                case &#39;t&#39;: /*continue*/ if (text[4] == &#39;i&#39; &amp;&amp; text[5] == &#39;n&#39; &amp;&amp; text[6] == &#39;u&#39; &amp;&amp; text[7] == &#39;e&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 6; break;
                default: break;
                }
                break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;d&#39;:
        switch (text[1])
        {
        case &#39;e&#39;: /*default*/ if (text[2] == &#39;f&#39; &amp;&amp; text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;u&#39; &amp;&amp; text[5] == &#39;l&#39; &amp;&amp; text[6] == &#39;t&#39; &amp;&amp; text[7] == &#39;\0&#39;) result = 7; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39; &#39;: /*do*/ if (text[3] == &#39;\0&#39;) result = 8; break;
            case &#39;u&#39;: /*double*/ if (text[3] == &#39;b&#39; &amp;&amp; text[4] == &#39;l&#39; &amp;&amp; text[5] == &#39;e&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 9; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;e&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*else*/ if (text[2] == &#39;s&#39; &amp;&amp; text[3] == &#39;e&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 10; break;
        case &#39;n&#39;: /*enum*/ if (text[2] == &#39;u&#39; &amp;&amp; text[3] == &#39;m&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 11; break;
        case &#39;x&#39;: /*extern*/ if (text[2] == &#39;t&#39; &amp;&amp; text[3] == &#39;e&#39; &amp;&amp; text[4] == &#39;r&#39; &amp;&amp; text[5] == &#39;n&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 12; break;
        default: break;
        }
        break;
    case &#39;f&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*float*/ if (text[2] == &#39;o&#39; &amp;&amp; text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;t&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 13; break;
        case &#39;o&#39;: /*for*/ if (text[2] == &#39;r&#39; &amp;&amp; text[3] == &#39;\0&#39;) result = 14; break;
        default: break;
        }
        break;
    case &#39;g&#39;: /*goto*/ if (text[1] == &#39;o&#39; &amp;&amp; text[2] == &#39;t&#39; &amp;&amp; text[3] == &#39;o&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 15; break;
    case &#39;i&#39;:
        switch (text[1])
        {
        case &#39;f&#39;: /*if*/ if (text[2] == &#39;\0&#39;) result = 16; break;
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*inline*/ if (text[3] == &#39;i&#39; &amp;&amp; text[4] == &#39;n&#39; &amp;&amp; text[5] == &#39;e&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 17; break;
            case &#39;t&#39;: /*int*/ if (text[3] == &#39;\0&#39;) result = 18; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;l&#39;: /*long*/ if (text[1] == &#39;o&#39; &amp;&amp; text[2] == &#39;n&#39; &amp;&amp; text[3] == &#39;g&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 19; break;
    case &#39;r&#39;:
        switch (text[1])
        {
        case &#39;e&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*register*/ if (text[3] == &#39;i&#39; &amp;&amp; text[4] == &#39;s&#39; &amp;&amp; text[5] == &#39;t&#39; &amp;&amp; text[6] == &#39;e&#39; &amp;&amp; text[7] == &#39;r&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 20; break;
            case &#39;s&#39;: /*restrict*/ if (text[3] == &#39;t&#39; &amp;&amp; text[4] == &#39;r&#39; &amp;&amp; text[5] == &#39;i&#39; &amp;&amp; text[6] == &#39;c&#39; &amp;&amp; text[7] == &#39;t&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 21; break;
            case &#39;t&#39;: /*return*/ if (text[3] == &#39;u&#39; &amp;&amp; text[4] == &#39;r&#39; &amp;&amp; text[5] == &#39;n&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 22; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;s&#39;:
        switch (text[1])
        {
        case &#39;h&#39;: /*short*/ if (text[2] == &#39;o&#39; &amp;&amp; text[3] == &#39;r&#39; &amp;&amp; text[4] == &#39;t&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 23; break;
        case &#39;i&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*signed*/ if (text[3] == &#39;n&#39; &amp;&amp; text[4] == &#39;e&#39; &amp;&amp; text[5] == &#39;d&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 24; break;
            case &#39;z&#39;: /*sizeof*/ if (text[3] == &#39;e&#39; &amp;&amp; text[4] == &#39;o&#39; &amp;&amp; text[5] == &#39;f&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 25; break;
            default: break;
            }
            break;
        case &#39;t&#39;:
            switch (text[2])
            {
            case &#39;a&#39;: /*static*/ if (text[3] == &#39;t&#39; &amp;&amp; text[4] == &#39;i&#39; &amp;&amp; text[5] == &#39;c&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 26; break;
            case &#39;r&#39;: /*struct*/ if (text[3] == &#39;u&#39; &amp;&amp; text[4] == &#39;c&#39; &amp;&amp; text[5] == &#39;t&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 27; break;
            default: break;
            }
            break;
        case &#39;w&#39;: /*switch*/ if (text[2] == &#39;i&#39; &amp;&amp; text[3] == &#39;t&#39; &amp;&amp; text[4] == &#39;c&#39; &amp;&amp; text[5] == &#39;h&#39; &amp;&amp; text[6] == &#39;\0&#39;) result = 28; break;
        default: break;
        }
        break;
    case &#39;t&#39;: /*typedef*/ if (text[1] == &#39;y&#39; &amp;&amp; text[2] == &#39;p&#39; &amp;&amp; text[3] == &#39;e&#39; &amp;&amp; text[4] == &#39;d&#39; &amp;&amp; text[5] == &#39;e&#39; &amp;&amp; text[6] == &#39;f&#39; &amp;&amp; text[7] == &#39;\0&#39;) result = 29; break;
    case &#39;u&#39;:
        switch (text[1])
        {
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*union*/ if (text[3] == &#39;o&#39; &amp;&amp; text[4] == &#39;n&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 30; break;
            case &#39;s&#39;: /*unsigned*/ if (text[3] == &#39;i&#39; &amp;&amp; text[4] == &#39;g&#39; &amp;&amp; text[5] == &#39;n&#39; &amp;&amp; text[6] == &#39;e&#39; &amp;&amp; text[7] == &#39;d&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 31; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;v&#39;:
        switch (text[1])
        {
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*void*/ if (text[3] == &#39;d&#39; &amp;&amp; text[4] == &#39;\0&#39;) result = 32; break;
            case &#39;l&#39;: /*volatile*/ if (text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;t&#39; &amp;&amp; text[5] == &#39;i&#39; &amp;&amp; text[6] == &#39;l&#39; &amp;&amp; text[7] == &#39;e&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 33; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;w&#39;: /*while*/ if (text[1] == &#39;h&#39; &amp;&amp; text[2] == &#39;i&#39; &amp;&amp; text[3] == &#39;l&#39; &amp;&amp; text[4] == &#39;e&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 34; break;
    case &#39;_&#39;:
        switch (text[1])
        {
        case &#39;A&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*_Alignas*/ if (text[3] == &#39;i&#39; &amp;&amp; text[4] == &#39;g&#39; &amp;&amp; text[5] == &#39;n&#39; &amp;&amp; text[6] == &#39;a&#39; &amp;&amp; text[7] == &#39;s&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 35; break;
            case &#39;t&#39;: /*_Atomic*/ if (text[3] == &#39;o&#39; &amp;&amp; text[4] == &#39;m&#39; &amp;&amp; text[5] == &#39;i&#39; &amp;&amp; text[6] == &#39;c&#39; &amp;&amp; text[7] == &#39;\0&#39;) result = 36; break;
            default: break;
            }
            break;
        case &#39;B&#39;: /*_Bool*/ if (text[2] == &#39;o&#39; &amp;&amp; text[3] == &#39;o&#39; &amp;&amp; text[4] == &#39;l&#39; &amp;&amp; text[5] == &#39;\0&#39;) result = 37; break;
        case &#39;C&#39;: /*_Complex*/ if (text[2] == &#39;o&#39; &amp;&amp; text[3] == &#39;m&#39; &amp;&amp; text[4] == &#39;p&#39; &amp;&amp; text[5] == &#39;l&#39; &amp;&amp; text[6] == &#39;e&#39; &amp;&amp; text[7] == &#39;x&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 38; break;
        case &#39;G&#39;: /*_Generic*/ if (text[2] == &#39;e&#39; &amp;&amp; text[3] == &#39;n&#39; &amp;&amp; text[4] == &#39;e&#39; &amp;&amp; text[5] == &#39;r&#39; &amp;&amp; text[6] == &#39;i&#39; &amp;&amp; text[7] == &#39;c&#39; &amp;&amp; text[8] == &#39;\0&#39;) result = 39; break;
        case &#39;I&#39;: /*_Imaginary*/ if (text[2] == &#39;m&#39; &amp;&amp; text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;g&#39; &amp;&amp; text[5] == &#39;i&#39; &amp;&amp; text[6] == &#39;n&#39; &amp;&amp; text[7] == &#39;a&#39; &amp;&amp; text[8] == &#39;r&#39; &amp;&amp; text[9] == &#39;y&#39; &amp;&amp; text[10] == &#39;\0&#39;) result = 40; break;
        case &#39;N&#39;: /*_Noreturn*/ if (text[2] == &#39;o&#39; &amp;&amp; text[3] == &#39;r&#39; &amp;&amp; text[4] == &#39;e&#39; &amp;&amp; text[5] == &#39;t&#39; &amp;&amp; text[6] == &#39;u&#39; &amp;&amp; text[7] == &#39;r&#39; &amp;&amp; text[8] == &#39;n&#39; &amp;&amp; text[9] == &#39;\0&#39;) result = 41; break;
        case &#39;S&#39;: /*_Static_assert*/ if (text[2] == &#39;t&#39; &amp;&amp; text[3] == &#39;a&#39; &amp;&amp; text[4] == &#39;t&#39; &amp;&amp; text[5] == &#39;i&#39; &amp;&amp; text[6] == &#39;c&#39; &amp;&amp; text[7] == &#39;_&#39; &amp;&amp; text[8] == &#39;a&#39; &amp;&amp; text[9] == &#39;s&#39; &amp;&amp; text[10] == &#39;s&#39; &amp;&amp; text[11] == &#39;e&#39; &amp;&amp; text[12] == &#39;r&#39; &amp;&amp; text[13] == &#39;t&#39; &amp;&amp; text[14] == &#39;\0&#39;) result = 42; break;
        case &#39;T&#39;: /*_Thread_local*/ if (text[2] == &#39;h&#39; &amp;&amp; text[3] == &#39;r&#39; &amp;&amp; text[4] == &#39;e&#39; &amp;&amp; text[5] == &#39;a&#39; &amp;&amp; text[6] == &#39;d&#39; &amp;&amp; text[7] == &#39;_&#39; &amp;&amp; text[8] == &#39;l&#39; &amp;&amp; text[9] == &#39;o&#39; &amp;&amp; text[10] == &#39;c&#39; &amp;&amp; text[11] == &#39;a&#39; &amp;&amp; text[12] == &#39;l&#39; &amp;&amp; text[13] == &#39;\0&#39;) result = 43; break;
        default: break;
        }
        break;
    default: break;
    }
    return result;
}


int find2(const char* text)
{

    int result = -1;
    switch (text[0])
    {
    case &#39;a&#39;:
        if (strcmp(&quot;alignof&quot;, text) == 0) result = 0;
        else if (strcmp(&quot;auto&quot;, text) == 0) result = 1;
        break;
    case &#39;b&#39;:
        if (strcmp(&quot;break&quot;, text) == 0) result = 2;
        break;
    case &#39;c&#39;:
        if (strcmp(&quot;case&quot;, text) == 0) result = 3;
        else if (strcmp(&quot;char&quot;, text) == 0) result = 4;
        else if (strcmp(&quot;const&quot;, text) == 0) result = 5;
        else if (strcmp(&quot;continue&quot;, text) == 0) result = 6;
        break;
    case &#39;d&#39;:
        if (strcmp(&quot;default&quot;, text) == 0) result = 7;
        else if (strcmp(&quot;do&quot;, text) == 0) result = 8;
        else if (strcmp(&quot;double&quot;, text) == 0) result = 9;
        break;
    case &#39;e&#39;:
        if (strcmp(&quot;else&quot;, text) == 0) result = 10;
        else if (strcmp(&quot;enum&quot;, text) == 0) result = 11;
        else if (strcmp(&quot;extern&quot;, text) == 0) result = 12;
        break;
    case &#39;f&#39;:
        if (strcmp(&quot;float&quot;, text) == 0) result = 13;
        else if (strcmp(&quot;for&quot;, text) == 0) result = 14;
        break;
    case &#39;g&#39;:
        if (strcmp(&quot;goto&quot;, text) == 0) result = 15;
        break;
    case &#39;i&#39;:
        if (strcmp(&quot;if&quot;, text) == 0) result = 16;
        else if (strcmp(&quot;inline&quot;, text) == 0) result = 17;
        else if (strcmp(&quot;int&quot;, text) == 0) result = 18;
        break;
    case &#39;l&#39;:
        if (strcmp(&quot;long&quot;, text) == 0) result = 19;
        break;
    case &#39;r&#39;:
        if (strcmp(&quot;register&quot;, text) == 0) result = 20;
        else if (strcmp(&quot;restrict&quot;, text) == 0) result = 21;
        else if (strcmp(&quot;return&quot;, text) == 0) result = 22;
        break;
    case &#39;s&#39;:
        if (strcmp(&quot;short&quot;, text) == 0) result = 23;
        else if (strcmp(&quot;signed&quot;, text) == 0) result = 24;
        else if (strcmp(&quot;sizeof&quot;, text) == 0) result = 25;
        else if (strcmp(&quot;static&quot;, text) == 0) result = 26;
        else if (strcmp(&quot;struct&quot;, text) == 0) result = 27;
        else if (strcmp(&quot;switch&quot;, text) == 0) result = 28;
        break;
    case &#39;t&#39;:
        if (strcmp(&quot;typedef&quot;, text) == 0) result = 29;
        break;
    case &#39;u&#39;:
        if (strcmp(&quot;union&quot;, text) == 0) result = 30;
        else if (strcmp(&quot;unsigned&quot;, text) == 0) result = 31;
        break;
    case &#39;v&#39;:
        if (strcmp(&quot;void&quot;, text) == 0) result = 32;
        else if (strcmp(&quot;volatile&quot;, text) == 0) result = 33;
        break;
    case &#39;w&#39;:
        if (strcmp(&quot;while&quot;, text) == 0) result = 34;
        break;
    case &#39;_&#39;:
        if (strcmp(&quot;_Alignas&quot;, text) == 0) result = 35;
        else if (strcmp(&quot;_Atomic&quot;, text) == 0) result = 36;
        else if (strcmp(&quot;_Bool&quot;, text) == 0) result = 37;
        else if (strcmp(&quot;_Complex&quot;, text) == 0) result = 38;
        else if (strcmp(&quot;_Generic&quot;, text) == 0) result = 39;
        else if (strcmp(&quot;_Imaginary&quot;, text) == 0) result = 40;
        else if (strcmp(&quot;_Noreturn&quot;, text) == 0) result = 41;
        else if (strcmp(&quot;_Static_assert&quot;, text) == 0) result = 42;
        else if (strcmp(&quot;_Thread_local&quot;, text) == 0) result = 43;
        break;
    default: break;
    }
    return result;
}

//#define GENERATE 1

int linear_search_str(const char* sorted_array[],
    int n_elements,
    const char* searchItem)
{
    int result = -1;
    for (int i = 0; i &lt; n_elements; i++)
    {
        if (strcmp(sorted_array[i], searchItem) == 0)
        {
            result = i;
            break;
        }
    }
    return result;
}

int binary_search_str(const char* sorted_array[],
    int n_elements,
    const char* searchItem)
{
    int mid;
    int c = 0;
    int l = 0;
    int u = n_elements - 1;

    while (l &lt;= u)
    {
        mid = (l + u) / 2;

        int cmp = strcmp(searchItem, sorted_array[mid]);

        if (cmp == 0)
        {
            c = 1;
            break;
        }
        else if (cmp &lt; 0)
        {
            u = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }

    return c == 0 ? -1 : mid;
}


void Generate3(const char* keywords[], int size)
{
    printf(&quot;int find3(const char* text)\n&quot;);
    printf(&quot;{\n&quot;);

    printf(&quot;int result = -1;\n&quot;
        &quot;unsigned u = 0; \n&quot;
        &quot;for (int j = 0; j &lt; 4 &amp;&amp; text[j]; j++)\n&quot;
        &quot;{\n&quot;
        &quot;  u |= ((unsigned)text[j]) &lt;&lt; (j * 8); \n&quot;
        &quot;}\n&quot;);


    printf(&quot;  switch (u)\n&quot;);
    printf(&quot;  {\n&quot;);


    for (int i = 0; i &lt; size; i++)
    {
        unsigned u = 0;
        for (int j = 0; j &lt; 4 &amp;&amp; keywords[i][j]; j++)
        {
            u |= ((unsigned)keywords[i][j]) &lt;&lt; (j * 8);
        }

        printf(&quot;case 0x%04x: /*%s*/result = %d; break;\n&quot;, u % size, keywords[i], i);
    }
    printf(&quot;  }\n&quot;);
    printf(&quot;  return result;\n&quot;);
    printf(&quot;}\n&quot;);
}



int find3(const char* text)
{
    int result = -1;
    unsigned u = 0;
    
    if (text[0])
     u |= ((unsigned)text[0]) &lt;&lt; (0);
    
    if (text[1])
        u |= ((unsigned)text[1]) &lt;&lt; 8;

    if (text[2])
        u |= ((unsigned)text[2]) &lt;&lt; 16;

    if (text[3])
        u |= ((unsigned)text[3]) &lt;&lt; 24;


    switch (u)
    {
    case 0x67696c61: /*alignof*/result = 0; break;
    case 0x6f747561: /*auto*/result = 1; break;
    case 0x61657262: /*break*/result = 2; break;
    case 0x65736163: /*case*/result = 3; break;
    case 0x72616863: /*char*/result = 4; break;
    case 0x736e6f63: /*const*/result = 5; break;
    case 0x746e6f63: /*continue*/result = 6; break;
    case 0x61666564: /*default*/result = 7; break;
    case 0x6f64: /*do*/result = 8; break;
    case 0x62756f64: /*double*/result = 9; break;
    case 0x65736c65: /*else*/result = 10; break;
    case 0x6d756e65: /*enum*/result = 11; break;
    case 0x65747865: /*extern*/result = 12; break;
    case 0x616f6c66: /*float*/result = 13; break;
    case 0x726f66: /*for*/result = 14; break;
    case 0x6f746f67: /*goto*/result = 15; break;
    case 0x6669: /*if*/result = 16; break;
    case 0x696c6e69: /*inline*/result = 17; break;
    case 0x746e69: /*int*/result = 18; break;
    case 0x676e6f6c: /*long*/result = 19; break;
    case 0x69676572: /*register*/result = 20; break;
    case 0x74736572: /*restrict*/result = 21; break;
    case 0x75746572: /*return*/result = 22; break;
    case 0x726f6873: /*short*/result = 23; break;
    case 0x6e676973: /*signed*/result = 24; break;
    case 0x657a6973: /*sizeof*/result = 25; break;
    case 0x74617473: /*static*/result = 26; break;
    case 0x75727473: /*struct*/result = 27; break;
    case 0x74697773: /*switch*/result = 28; break;
    case 0x65707974: /*typedef*/result = 29; break;
    case 0x6f696e75: /*union*/result = 30; break;
    case 0x69736e75: /*unsigned*/result = 31; break;
    case 0x64696f76: /*void*/result = 32; break;
    case 0x616c6f76: /*volatile*/result = 33; break;
    case 0x6c696877: /*while*/result = 34; break;
    case 0x696c415f: /*_Alignas*/result = 35; break;
    case 0x6f74415f: /*_Atomic*/result = 36; break;
    case 0x6f6f425f: /*_Bool*/result = 37; break;
    case 0x6d6f435f: /*_Complex*/result = 38; break;
    case 0x6e65475f: /*_Generic*/result = 39; break;
    case 0x616d495f: /*_Imaginary*/result = 40; break;
    case 0x726f4e5f: /*_Noreturn*/result = 41; break;
    case 0x6174535f: /*_Static_assert*/result = 42; break;
    case 0x7268545f: /*_Thread_local*/result = 43; break;
    }
    return result;
}

int find1(const char* text)
{
    int result = -1;
    switch (text[0])
    {
    case &#39;a&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*alignof*/ if (strcmp(text, &quot;alignof&quot;) == 0) result = 0; break;
        case &#39;u&#39;: /*auto*/ if (strcmp(text, &quot;auto&quot;) == 0) result = 1; break;
        default: break;
        }
        break;
    case &#39;b&#39;: /*break*/ if (strcmp(text, &quot;break&quot;) == 0) result = 2; break;
    case &#39;c&#39;:
        switch (text[1])
        {
        case &#39;a&#39;: /*case*/ if (strcmp(text, &quot;case&quot;) == 0) result = 3; break;
        case &#39;h&#39;: /*char*/ if (strcmp(text, &quot;char&quot;) == 0) result = 4; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;n&#39;:
                switch (text[3])
                {
                case &#39;s&#39;: /*const*/ if (strcmp(text, &quot;const&quot;) == 0) result = 5; break;
                case &#39;t&#39;: /*continue*/ if (strcmp(text, &quot;continue&quot;) == 0) result = 6; break;
                default: break;
                }
                break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;d&#39;:
        switch (text[1])
        {
        case &#39;e&#39;: /*default*/ if (strcmp(text, &quot;default&quot;) == 0) result = 7; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39; &#39;: /*do*/ if (strcmp(text, &quot;do&quot;) == 0) result = 8; break;
            case &#39;u&#39;: /*double*/ if (strcmp(text, &quot;double&quot;) == 0) result = 9; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;e&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*else*/ if (strcmp(text, &quot;else&quot;) == 0) result = 10; break;
        case &#39;n&#39;: /*enum*/ if (strcmp(text, &quot;enum&quot;) == 0) result = 11; break;
        case &#39;x&#39;: /*extern*/ if (strcmp(text, &quot;extern&quot;) == 0) result = 12; break;
        default: break;
        }
        break;
    case &#39;f&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*float*/ if (strcmp(text, &quot;float&quot;) == 0) result = 13; break;
        case &#39;o&#39;: /*for*/ if (strcmp(text, &quot;for&quot;) == 0) result = 14; break;
        default: break;
        }
        break;
    case &#39;g&#39;: /*goto*/ if (strcmp(text, &quot;goto&quot;) == 0) result = 15; break;
    case &#39;i&#39;:
        switch (text[1])
        {
        case &#39;f&#39;: /*if*/ if (strcmp(text, &quot;if&quot;) == 0) result = 16; break;
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*inline*/ if (strcmp(text, &quot;inline&quot;) == 0) result = 17; break;
            case &#39;t&#39;: /*int*/ if (strcmp(text, &quot;int&quot;) == 0) result = 18; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;l&#39;: /*long*/ if (strcmp(text, &quot;long&quot;) == 0) result = 19; break;
    case &#39;r&#39;:
        switch (text[1])
        {
        case &#39;e&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*register*/ if (strcmp(text, &quot;register&quot;) == 0) result = 20; break;
            case &#39;s&#39;: /*restrict*/ if (strcmp(text, &quot;restrict&quot;) == 0) result = 21; break;
            case &#39;t&#39;: /*return*/ if (strcmp(text, &quot;return&quot;) == 0) result = 22; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;s&#39;:
        switch (text[1])
        {
        case &#39;h&#39;: /*short*/ if (strcmp(text, &quot;short&quot;) == 0) result = 23; break;
        case &#39;i&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*signed*/ if (strcmp(text, &quot;signed&quot;) == 0) result = 24; break;
            case &#39;z&#39;: /*sizeof*/ if (strcmp(text, &quot;sizeof&quot;) == 0) result = 25; break;
            default: break;
            }
            break;
        case &#39;t&#39;:
            switch (text[2])
            {
            case &#39;a&#39;: /*static*/ if (strcmp(text, &quot;static&quot;) == 0) result = 26; break;
            case &#39;r&#39;: /*struct*/ if (strcmp(text, &quot;struct&quot;) == 0) result = 27; break;
            default: break;
            }
            break;
        case &#39;w&#39;: /*switch*/ if (strcmp(text, &quot;switch&quot;) == 0) result = 28; break;
        default: break;
        }
        break;
    case &#39;t&#39;: /*typedef*/ if (strcmp(text, &quot;typedef&quot;) == 0) result = 29; break;
    case &#39;u&#39;:
        switch (text[1])
        {
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*union*/ if (strcmp(text, &quot;union&quot;) == 0) result = 30; break;
            case &#39;s&#39;: /*unsigned*/ if (strcmp(text, &quot;unsigned&quot;) == 0) result = 31; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;v&#39;:
        switch (text[1])
        {
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*void*/ if (strcmp(text, &quot;void&quot;) == 0) result = 32; break;
            case &#39;l&#39;: /*volatile*/ if (strcmp(text, &quot;volatile&quot;) == 0) result = 33; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;w&#39;: /*while*/ if (strcmp(text, &quot;while&quot;) == 0) result = 34; break;
    case &#39;_&#39;:
        switch (text[1])
        {
        case &#39;A&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*_Alignas*/ if (strcmp(text, &quot;_Alignas&quot;) == 0) result = 35; break;
            case &#39;t&#39;: /*_Atomic*/ if (strcmp(text, &quot;_Atomic&quot;) == 0) result = 36; break;
            default: break;
            }
            break;
        case &#39;B&#39;: /*_Bool*/ if (strcmp(text, &quot;_Bool&quot;) == 0) result = 37; break;
        case &#39;C&#39;: /*_Complex*/ if (strcmp(text, &quot;_Complex&quot;) == 0) result = 38; break;
        case &#39;G&#39;: /*_Generic*/ if (strcmp(text, &quot;_Generic&quot;) == 0) result = 39; break;
        case &#39;I&#39;: /*_Imaginary*/ if (strcmp(text, &quot;_Imaginary&quot;) == 0) result = 40; break;
        case &#39;N&#39;: /*_Noreturn*/ if (strcmp(text, &quot;_Noreturn&quot;) == 0) result = 41; break;
        case &#39;S&#39;: /*_Static_assert*/ if (strcmp(text, &quot;_Static_assert&quot;) == 0) result = 42; break;
        case &#39;T&#39;: /*_Thread_local*/ if (strcmp(text, &quot;_Thread_local&quot;) == 0) result = 43; break;
        default: break;
        }
        break;
    default: break;
    }
    return result;
}

int find10(const char* text)
{
    int result = -1;
    switch (text[0])
    {
    case &#39;a&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*alignof*/ if (strcmp(&amp;text[2], &quot;ignof&quot;) == 0) result = 0; break;
        case &#39;u&#39;: /*auto*/ if (strcmp(&amp;text[2], &quot;to&quot;) == 0) result = 1; break;
        default: break;
        }
        break;
    case &#39;b&#39;: /*break*/ if (strcmp(&amp;text[1], &quot;reak&quot;) == 0) result = 2; break;
    case &#39;c&#39;:
        switch (text[1])
        {
        case &#39;a&#39;: /*case*/ if (strcmp(&amp;text[2], &quot;se&quot;) == 0) result = 3; break;
        case &#39;h&#39;: /*char*/ if (strcmp(&amp;text[2], &quot;ar&quot;) == 0) result = 4; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;n&#39;:
                switch (text[3])
                {
                case &#39;s&#39;: /*const*/ if (strcmp(&amp;text[4], &quot;t&quot;) == 0) result = 5; break;
                case &#39;t&#39;: /*continue*/ if (strcmp(&amp;text[4], &quot;inue&quot;) == 0) result = 6; break;
                default: break;
                }
                break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;d&#39;:
        switch (text[1])
        {
        case &#39;e&#39;: /*default*/ if (strcmp(&amp;text[2], &quot;fault&quot;) == 0) result = 7; break;
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39; &#39;: /*do*/ if (strcmp(&amp;text[3], &quot;&quot;) == 0) result = 8; break;
            case &#39;u&#39;: /*double*/ if (strcmp(&amp;text[3], &quot;ble&quot;) == 0) result = 9; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;e&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*else*/ if (strcmp(&amp;text[2], &quot;se&quot;) == 0) result = 10; break;
        case &#39;n&#39;: /*enum*/ if (strcmp(&amp;text[2], &quot;um&quot;) == 0) result = 11; break;
        case &#39;x&#39;: /*extern*/ if (strcmp(&amp;text[2], &quot;tern&quot;) == 0) result = 12; break;
        default: break;
        }
        break;
    case &#39;f&#39;:
        switch (text[1])
        {
        case &#39;l&#39;: /*float*/ if (strcmp(&amp;text[2], &quot;oat&quot;) == 0) result = 13; break;
        case &#39;o&#39;: /*for*/ if (strcmp(&amp;text[2], &quot;r&quot;) == 0) result = 14; break;
        default: break;
        }
        break;
    case &#39;g&#39;: /*goto*/ if (strcmp(&amp;text[1], &quot;oto&quot;) == 0) result = 15; break;
    case &#39;i&#39;:
        switch (text[1])
        {
        case &#39;f&#39;: /*if*/ if (strcmp(&amp;text[2], &quot;&quot;) == 0) result = 16; break;
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*inline*/ if (strcmp(&amp;text[3], &quot;ine&quot;) == 0) result = 17; break;
            case &#39;t&#39;: /*int*/ if (strcmp(&amp;text[3], &quot;&quot;) == 0) result = 18; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;l&#39;: /*long*/ if (strcmp(&amp;text[1], &quot;ong&quot;) == 0) result = 19; break;
    case &#39;r&#39;:
        switch (text[1])
        {
        case &#39;e&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*register*/ if (strcmp(&amp;text[3], &quot;ister&quot;) == 0) result = 20; break;
            case &#39;s&#39;: /*restrict*/ if (strcmp(&amp;text[3], &quot;trict&quot;) == 0) result = 21; break;
            case &#39;t&#39;: /*return*/ if (strcmp(&amp;text[3], &quot;urn&quot;) == 0) result = 22; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;s&#39;:
        switch (text[1])
        {
        case &#39;h&#39;: /*short*/ if (strcmp(&amp;text[2], &quot;ort&quot;) == 0) result = 23; break;
        case &#39;i&#39;:
            switch (text[2])
            {
            case &#39;g&#39;: /*signed*/ if (strcmp(&amp;text[3], &quot;ned&quot;) == 0) result = 24; break;
            case &#39;z&#39;: /*sizeof*/ if (strcmp(&amp;text[3], &quot;eof&quot;) == 0) result = 25; break;
            default: break;
            }
            break;
        case &#39;t&#39;:
            switch (text[2])
            {
            case &#39;a&#39;: /*static*/ if (strcmp(&amp;text[3], &quot;tic&quot;) == 0) result = 26; break;
            case &#39;r&#39;: /*struct*/ if (strcmp(&amp;text[3], &quot;uct&quot;) == 0) result = 27; break;
            default: break;
            }
            break;
        case &#39;w&#39;: /*switch*/ if (strcmp(&amp;text[2], &quot;itch&quot;) == 0) result = 28; break;
        default: break;
        }
        break;
    case &#39;t&#39;: /*typedef*/ if (strcmp(&amp;text[1], &quot;ypedef&quot;) == 0) result = 29; break;
    case &#39;u&#39;:
        switch (text[1])
        {
        case &#39;n&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*union*/ if (strcmp(&amp;text[3], &quot;on&quot;) == 0) result = 30; break;
            case &#39;s&#39;: /*unsigned*/ if (strcmp(&amp;text[3], &quot;igned&quot;) == 0) result = 31; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;v&#39;:
        switch (text[1])
        {
        case &#39;o&#39;:
            switch (text[2])
            {
            case &#39;i&#39;: /*void*/ if (strcmp(&amp;text[3], &quot;d&quot;) == 0) result = 32; break;
            case &#39;l&#39;: /*volatile*/ if (strcmp(&amp;text[3], &quot;atile&quot;) == 0) result = 33; break;
            default: break;
            }
            break;
        default: break;
        }
        break;
    case &#39;w&#39;: /*while*/ if (strcmp(&amp;text[1], &quot;hile&quot;) == 0) result = 34; break;
    case &#39;_&#39;:
        switch (text[1])
        {
        case &#39;A&#39;:
            switch (text[2])
            {
            case &#39;l&#39;: /*_Alignas*/ if (strcmp(&amp;text[3], &quot;ignas&quot;) == 0) result = 35; break;
            case &#39;t&#39;: /*_Atomic*/ if (strcmp(&amp;text[3], &quot;omic&quot;) == 0) result = 36; break;
            default: break;
            }
            break;
        case &#39;B&#39;: /*_Bool*/ if (strcmp(&amp;text[2], &quot;ool&quot;) == 0) result = 37; break;
        case &#39;C&#39;: /*_Complex*/ if (strcmp(&amp;text[2], &quot;omplex&quot;) == 0) result = 38; break;
        case &#39;G&#39;: /*_Generic*/ if (strcmp(&amp;text[2], &quot;eneric&quot;) == 0) result = 39; break;
        case &#39;I&#39;: /*_Imaginary*/ if (strcmp(&amp;text[2], &quot;maginary&quot;) == 0) result = 40; break;
        case &#39;N&#39;: /*_Noreturn*/ if (strcmp(&amp;text[2], &quot;oreturn&quot;) == 0) result = 41; break;
        case &#39;S&#39;: /*_Static_assert*/ if (strcmp(&amp;text[2], &quot;tatic_assert&quot;) == 0) result = 42; break;
        case &#39;T&#39;: /*_Thread_local*/ if (strcmp(&amp;text[2], &quot;hread_local&quot;) == 0) result = 43; break;
        default: break;
        }
        break;
    default: break;
    }
    return result;
}

//#include &lt;string.h&gt;
//#include &lt;stdio.h&gt;

unsigned hash(unsigned d, const char* str, int str_length) {
    if (d == 0) { d = 0x811c9dc5; }
    for (unsigned i = 0; i &lt; str_length; i++) {
        // http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
        // http://isthe.com/chongo/src/fnv/hash_32.c
        // multiply by the 32 bit FNV magic prime mod 2^32
        d += (d &lt;&lt; 1) + (d &lt;&lt; 4) + (d &lt;&lt; 7) + (d &lt;&lt; 8) + (d &lt;&lt; 24);
        // xor the bottom with the current octet
        d ^= str[i];
    }
    return d &amp; 0x7fffffff;
}

unsigned lookup(int G[], int G_length, int V[], int V_length, const char* key)
{
    unsigned d = G[hash(0, key, strlen(key)) % G_length];
    if (d &lt; 0) return V[0 - d - 1];
    return V[hash(d, key, strlen(key)) % V_length];
};

#define undefined 0xFFFFFFFF

int findhash(const char* keyword)
{
    int G[] =
    {
     undefined, undefined, -44, -42, 9, -39, -38, -34,
     undefined, 1, -27, undefined, -25, 1, -23, undefined,
     undefined, -13, undefined, 2, undefined, undefined,
     1, 1, 3, undefined, 1, -9, -6, -3, 11, 1, -10, 3, -16,
     -20, -26, undefined, -30, undefined, 1, undefined,
     undefined, 1
    };

    int G_length = sizeof(G) / sizeof(G[0]);

    int V[] = {
    19, 5, 24, 42, 27, 32, 16, 1, 33, 39, 11,
    37, 26, 25, 15, 10, 38, 29, 12, 36, 44,
    22, 6, 20, 35, 17, 3, 41, 31, 21, 30, 4,
    8, 13, 2, 43, 40, 9, 14, 34, 7, 23, 28, 18
    };
    int V_length = sizeof(V) / sizeof(V[0]);

    unsigned r = lookup(G, G_length, V, V_length, keyword);

    //printf(&quot;%d&quot;, r);
    return r;
}
int Day(const char* key)
{
    int result = -1;
    switch (key[0])
    {
    case /*Friday*/ &#39;F&#39;:
        if (key[1] == &#39;r&#39; &amp;&amp; key[2] == &#39;i&#39; &amp;&amp; key[3] == &#39;d&#39; &amp;&amp; key[4] == &#39;a&#39; &amp;&amp; key[5] == &#39;y&#39; &amp;&amp; key[6] == &#39;\0&#39;) {
            result = 0;
        }
        break;
    case /*Monday*/ &#39;M&#39;:
        if (key[1] == &#39;o&#39; &amp;&amp; key[2] == &#39;n&#39; &amp;&amp; key[3] == &#39;d&#39; &amp;&amp; key[4] == &#39;a&#39; &amp;&amp; key[5] == &#39;y&#39; &amp;&amp; key[6] == &#39;\0&#39;) {
            result = 1;
        }
        break;
    case &#39;S&#39;:
        switch (key[1])
        {
        case /*Saturday*/ &#39;a&#39;:
            if (key[2] == &#39;t&#39; &amp;&amp; key[3] == &#39;u&#39; &amp;&amp; key[4] == &#39;r&#39; &amp;&amp; key[5] == &#39;d&#39; &amp;&amp; key[6] == &#39;a&#39; &amp;&amp; key[7] == &#39;y&#39; &amp;&amp; key[8] == &#39;\0&#39;) {
                result = 2;
            }
            break;
        case /*Sunday*/ &#39;u&#39;:
            if (key[2] == &#39;n&#39; &amp;&amp; key[3] == &#39;d&#39; &amp;&amp; key[4] == &#39;a&#39; &amp;&amp; key[5] == &#39;y&#39; &amp;&amp; key[6] == &#39;\0&#39;) {
                result = 3;
            }
            break;
        default: break;
        }
        break;
    case &#39;T&#39;:
        switch (key[1])
        {
        case /*Thursday*/ &#39;h&#39;:
            if (key[2] == &#39;u&#39; &amp;&amp; key[3] == &#39;r&#39; &amp;&amp; key[4] == &#39;s&#39; &amp;&amp; key[5] == &#39;d&#39; &amp;&amp; key[6] == &#39;a&#39; &amp;&amp; key[7] == &#39;y&#39; &amp;&amp; key[8] == &#39;\0&#39;) {
                result = 4;
            }
            break;
        case /*Tuesday*/ &#39;u&#39;:
            if (key[2] == &#39;e&#39; &amp;&amp; key[3] == &#39;s&#39; &amp;&amp; key[4] == &#39;d&#39; &amp;&amp; key[5] == &#39;a&#39; &amp;&amp; key[6] == &#39;y&#39; &amp;&amp; key[7] == &#39;\0&#39;) {
                result = 5;
            }
            break;
        default: break;
        }
        break;
    case /*Wednesday*/ &#39;W&#39;:
        if (key[1] == &#39;e&#39; &amp;&amp; key[2] == &#39;d&#39; &amp;&amp; key[3] == &#39;n&#39; &amp;&amp; key[4] == &#39;e&#39; &amp;&amp; key[5] == &#39;s&#39; &amp;&amp; key[6] == &#39;d&#39; &amp;&amp; key[7] == &#39;a&#39; &amp;&amp; key[8] == &#39;y&#39; &amp;&amp; key[9] == &#39;\0&#39;) {
            result = 6;
        }
        break;
    default: break;
    }
    return result;
}


//#define NITER 2147483647
#define NITER (2147483646)
int main()
{
    
    

    const char* keywords[] = {
    &quot;alignof&quot;, &quot;auto&quot;, &quot;break&quot;, &quot;case&quot;, &quot;char&quot;, &quot;const&quot;,
        &quot;continue&quot;, &quot;default&quot;,      &quot;do&quot;, &quot;double&quot;, &quot;else&quot;,
        &quot;enum&quot;, &quot;extern&quot;, &quot;float&quot;, &quot;for&quot;,
        &quot;goto&quot;, &quot;if&quot;, &quot;inline&quot;, &quot;int&quot;, &quot;long&quot;,
        &quot;register&quot;, &quot;restrict&quot;, &quot;return&quot;, &quot;short&quot;,
        &quot;signed&quot;, &quot;sizeof&quot;, &quot;static&quot;, &quot;struct&quot;,
        &quot;switch&quot;, &quot;typedef&quot;, &quot;union&quot;, &quot;unsigned&quot;,
        &quot;void&quot;, &quot;volatile&quot;, &quot;while&quot;, &quot;_Alignas&quot;,
        &quot;_Atomic&quot;, &quot;_Bool&quot;, &quot;_Complex&quot;, &quot;_Generic&quot;,
        &quot;_Imaginary&quot;, &quot;_Noreturn&quot;, &quot;_Static_assert&quot;, &quot;_Thread_local&quot; };

    //Generate(keywords, sizeof(keywords) / sizeof(keywords[0]));
    //Generate1(keywords, sizeof(keywords) / sizeof(keywords[0]));
    //Generate2(keywords, sizeof(keywords) / sizeof(keywords[0]));
    //Generate3(keywords, sizeof(keywords) / sizeof(keywords[0]));
    //Generate4(keywords, sizeof(keywords) / sizeof(keywords[0]));
    

    char search[122];// = &quot;goto&quot;;
    printf(&quot;Enter a C keyword:\n&quot;);
    scanf(&quot;%[^\n]&quot;, search);


    //find3(search);
    struct Stopwatch s = { 0 };


    Stopwatch_Start(&amp;s);
    int r2 = 0;

    for (int i = 0; i &lt; NITER; i++)
    {
        r2 = find2(search);
    }

    Stopwatch_Stop(&amp;s);
    printf(&quot;strcmp %d %d\n&quot;, r2, Stopwatch_GetElapsedTicks(&amp;s));

    Stopwatch_Reset(&amp;s);

    
    //////////////////

    Stopwatch_Start(&amp;s);
    int r22 = 0;

    for (int i = 0; i &lt; NITER; i++)
    {
        r22 = find1(search);
    }

    Stopwatch_Stop(&amp;s);
    printf(&quot;switch + strcmp %d %d\n&quot;, r22, Stopwatch_GetElapsedTicks(&amp;s));
    Stopwatch_Reset(&amp;s);

    
    //////////////////

    Stopwatch_Start(&amp;s);
    int r1 = 0;
    for (int i = 0; i &lt; NITER; i++)
    {
        r1 = find(search);
    }
    Stopwatch_Stop(&amp;s);
    
    printf(&quot;switches %d %d\n&quot;, r1, Stopwatch_GetElapsedTicks(&amp;s));

    Stopwatch_Reset(&amp;s);
    ////////////
    Stopwatch_Start(&amp;s);
    int r3 = 0;
    for (int i = 0; i &lt; NITER; i++)
    {
        r3 = binary_search_str(keywords, sizeof(keywords) / sizeof(keywords[0]), search);
    }
    Stopwatch_Stop(&amp;s);
    printf(&quot;Binary Search %d %d\n&quot;, r3, Stopwatch_GetElapsedTicks(&amp;s));

    Stopwatch_Reset(&amp;s);
    Stopwatch_Start(&amp;s);
    int r5 = 0;
    for (int i = 0; i &lt; NITER; i++)
    {
        r5 = find3(search);
    }
    Stopwatch_Stop(&amp;s);
    printf(&quot;Hash %d %d\n&quot;, r5, Stopwatch_GetElapsedTicks(&amp;s));

    
    ///////////
    Stopwatch_Reset(&amp;s);
    Stopwatch_Start(&amp;s);
    int r6 = 0;
    for (int i = 0; i &lt; NITER; i++)
    {
        r6 = findhash(search);
    }
    Stopwatch_Stop(&amp;s);
    
    printf(&quot;Haash %d %d\n&quot;, r6, Stopwatch_GetElapsedTicks(&amp;s));
    Stopwatch_Reset(&amp;s);
    ////////////

    Stopwatch_Start(&amp;s);
    int r4 = 0;
    for (int i = 0; i &lt; NITER; i++)
    {
        r4 = linear_search_str(keywords, sizeof(keywords) / sizeof(keywords[0]), search);
    }
    Stopwatch_Stop(&amp;s);
    
    printf(&quot;Linear %d %d\n&quot;, r4, Stopwatch_GetElapsedTicks(&amp;s));
    Stopwatch_Reset(&amp;s);

}



</code></pre>
</body></html>