<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->


<pre>


<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;async.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;tinycthread.h&quot;</span>
<span class="keyword">#include</span> &lt;assert.h&gt;
<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> <span class="string">&quot;actor.h&quot;</span>
<span class="keyword">#include</span> &lt;stdio.h&gt;

<span class="keyword">struct</span> A
{
    <span class="keyword">int</span> i;
};
<span class="keyword">#define</span> A_INIT { <span class="number">0</span> }

<span class="keyword">struct</span> B
{
    <span class="keyword">int</span> i;
};
<span class="keyword">#define</span> B_INIT { <span class="number">0</span> }


<span class="keyword">struct</span> A a = A_INIT;
<span class="keyword">struct</span> actor actorA;

<span class="keyword">struct</span> B b = B_INIT;
<span class="keyword">struct</span> actor actorB;

<span class="keyword">void</span> pong(<span class="keyword">struct</span> actor* actor, <span class="keyword">void</span>* data);

<span class="keyword">void</span> ping(<span class="keyword">struct</span> actor* actor, <span class="keyword">void</span>* data)
{
    <span class="comment">/*actor a est� recebendo a mensagem ping */</span>
    <span class="keyword">struct</span> actor * actorA = (<span class="keyword">struct</span> actor *)actor;
    
    printf(<span class="string">&quot;ping\n&quot;</span>);

    <span class="comment">/*envia mensagem &quot;pong&quot; para actor B*/</span>
    actor_post(&amp;actorB, &amp;pong, <span class="number">0</span>);
}

<span class="keyword">void</span> pong(<span class="keyword">struct</span> actor* actor, <span class="keyword">void</span>* data)
{
    <span class="comment">/*actor b est� recebendo a mensagem pong */</span>
    <span class="keyword">struct</span> actor * actorB = (<span class="keyword">struct</span> actor *)actor;

    printf(<span class="string">&quot;pong\n&quot;</span>);
    
    <span class="comment">/*envia mensagem &quot;ping&quot; para actor A*/</span>
    actor_post(&amp;actorA, &amp;ping, <span class="number">0</span>);
}


<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
    async_pool_init();

    actor_init(&amp;actorA);
    actorA.object = &amp;a;

    actor_init(&amp;actorB);
    actorB.object = &amp;b;

    <span class="comment">/*envia mensagem &quot;ping&quot; para actor A*/</span>
    actor_post(&amp;actorA, &amp;ping, <span class="number">0</span>);
    
    async_pool_join();

    <span class="keyword">return</span> <span class="number">0</span>;
}


</pre>


<p>actor.h</p>
<pre>
<span class="keyword">#pragma</span> once
<span class="keyword">#include</span> <span class="string">&quot;tinycthread.h&quot;</span>

<span class="keyword">enum</span> ACTOR_STATE
{
    ACTOR_STATE_NONE,
    ACTOR_STATE_RUNNING,
    ACTOR_STATE_ONQUEUE
};

<span class="keyword">typedef</span> <span class="keyword">void</span>(*actor_callback)(<span class="keyword">struct</span> actor* actor, <span class="keyword">void</span>*);
<span class="keyword">struct</span> actor_closure
{
    actor_callback callback;
    <span class="keyword">void</span>*    callback_data;
};

<span class="keyword">struct</span> actor
{
    ACTOR_STATE state;
    mtx_t s_queue_mutex;

    <span class="keyword">struct</span> actor_closure* current_tasks;
    <span class="keyword">int</span> tasks_size;
    <span class="keyword">int</span> taks_max_size;

    <span class="keyword">void</span>* object;
};


<span class="keyword">int</span>  actor_init(<span class="keyword">struct</span> actor* actor);
<span class="keyword">void</span> actor_destroy(<span class="keyword">struct</span> actor* actor);

<span class="keyword">int</span> actor_post(<span class="keyword">struct</span> actor* actor,
               actor_callback callback,
               <span class="keyword">void</span>* callback_data);

</pre>


<p>actor.cpp</p>
<pre>
<span class="keyword">#include</span> <span class="string">&quot;actor.h&quot;</span>


<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> <span class="string">&quot;async.h&quot;</span>
<span class="keyword">#include</span> &lt;assert.h&gt;

<span class="keyword">int</span> actor_init(<span class="keyword">struct</span> actor* actor)
{
    actor-&gt;state = ACTOR_STATE_NONE;
    actor-&gt;tasks_size = <span class="number">0</span>;
    actor-&gt;taks_max_size = <span class="number">100</span>;
    actor-&gt;current_tasks = <span class="number">0</span>;
    <span class="keyword">int</span> r = mtx_init(&amp;actor-&gt;s_queue_mutex, mtx_plain);
    <span class="keyword">return</span> r;
}

<span class="keyword">void</span> actor_destroy(<span class="keyword">struct</span> actor* actor)
{
    mtx_destroy(&amp;actor-&gt;s_queue_mutex);
}

<span class="keyword">static</span> <span class="keyword">int</span> actor_get_messages(actor* actor, <span class="keyword">struct</span> actor_closure** current_tasks)
{
    *current_tasks = <span class="number">0</span>;
    <span class="keyword">int</span> tasks = <span class="number">0</span>;
    mtx_lock(&amp;actor-&gt;s_queue_mutex);
    tasks = actor-&gt;tasks_size;

    <span class="keyword">if</span> (tasks != <span class="number">0</span>)
    {
        actor-&gt;state = ACTOR_STATE_RUNNING;
        *current_tasks = actor-&gt;current_tasks;
        actor-&gt;current_tasks = <span class="number">0</span>;
        actor-&gt;tasks_size = <span class="number">0</span>;
    }
    <span class="keyword">else</span>
    {
        actor-&gt;state = ACTOR_STATE_NONE;
    }

    mtx_unlock(&amp;actor-&gt;s_queue_mutex);
    <span class="keyword">return</span> tasks;
}


<span class="keyword">static</span> <span class="keyword">void</span> actor_process_messages(<span class="keyword">int</span>, <span class="keyword">void</span>* p)
{
    <span class="keyword">struct</span> actor* a = (<span class="keyword">struct</span> actor*)(p);

    <span class="keyword">for</span> (;;)
    {
        <span class="keyword">struct</span> actor_closure* current_tasks;
        <span class="keyword">int</span> tasks = actor_get_messages(a, &amp;current_tasks);

        <span class="keyword">if</span> (tasks == <span class="number">0</span>)
        {
            <span class="keyword">break</span>;
        }

        <span class="keyword">for</span> (<span class="keyword">int</span> i = tasks - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)
        {
            current_tasks[i].callback(a, <span class="number">0</span>);
        }
    }
}

<span class="keyword">int</span> actor_post(actor* actor,
               actor_callback callback,
               <span class="keyword">void</span>* callback_data)
{
    <span class="keyword">int</span> result = <span class="number">0</span>;
    mtx_lock(&amp;actor-&gt;s_queue_mutex);

    <span class="keyword">if</span> (actor-&gt;current_tasks == <span class="number">0</span>)
    {
        actor-&gt;current_tasks =
            (actor_closure*) malloc(<span class="keyword">sizeof</span>(actor_closure) * actor-&gt;taks_max_size);

        <span class="keyword">if</span> (actor-&gt;current_tasks == <span class="number">0</span>)
        {
            <span class="comment">//out of memory
</span>            result = <span class="number">1</span>;
        }
    }

    <span class="keyword">if</span> (result == <span class="number">0</span>)
    {
        actor-&gt;current_tasks[actor-&gt;tasks_size].callback = callback;
        actor-&gt;current_tasks[actor-&gt;tasks_size].callback_data = callback_data;
        actor-&gt;tasks_size++;

        <span class="keyword">switch</span> (actor-&gt;state)
        {
        <span class="keyword">case</span> ACTOR_STATE_NONE:
            actor-&gt;state = ACTOR_STATE_ONQUEUE;
            async_pool_run(&amp;actor_process_messages, actor);
            <span class="keyword">break</span>;

        <span class="keyword">case</span> ACTOR_STATE_ONQUEUE:
        <span class="keyword">case</span> ACTOR_STATE_RUNNING:
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            assert(<span class="keyword">false</span>);
        }
    }
    <span class="keyword">else</span>
    {
    }

    mtx_unlock(&amp;actor-&gt;s_queue_mutex);
    <span class="keyword">return</span> result;
}
</pre>


<p>async.h</p>
<pre>
<span class="keyword">#pragma</span> once


<span class="keyword">typedef</span> <span class="keyword">void</span>(*execute_task)(<span class="keyword">int</span>, <span class="keyword">void</span>*);

<span class="keyword">int</span> async_pool_init();

<span class="keyword">int</span> async_pool_run(execute_task exectask,<span class="keyword">void</span>* arg);

<span class="keyword">void</span> async_pool_join();

</pre>



<p>async.cpp</p>
<pre>
<span class="keyword">#include</span> <span class="string">&quot;async.h&quot;</span>


<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;async.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;tinycthread.h&quot;</span>
<span class="keyword">#include</span> &lt;assert.h&gt;

<span class="keyword">#define</span> POOL_SIZE <span class="number">2</span>
<span class="keyword">#define</span> MAX_TASKS <span class="number">100</span>

<span class="keyword">struct</span> task
{
    execute_task exectask;
    <span class="keyword">void</span>*        arg;
};

<span class="keyword">static</span> <span class="keyword">void</span> task_init(<span class="keyword">struct</span> task* task,
    execute_task exectask,
    <span class="keyword">void</span>* arg)
{
    task-&gt;arg = arg;
    task-&gt;exectask = exectask;
}



<span class="keyword">struct</span> task_queue
{
    <span class="keyword">struct</span> task  buffer[MAX_TASKS];
    size_t       count;
    <span class="keyword">struct</span> task* head;
    <span class="keyword">struct</span> task* tail;
};

<span class="keyword">static</span> mtx_t             s_queue_mutex;
<span class="keyword">static</span> thrd_t            s_threads[POOL_SIZE];
<span class="keyword">static</span> BOOL              s_stop = FALSE;
<span class="keyword">static</span> cnd_t             s_condition;
<span class="keyword">static</span> <span class="keyword">struct</span> task_queue s_queue;

<span class="keyword">static</span> <span class="keyword">void</span> task_queue_init(<span class="keyword">struct</span> task_queue *q)
{
    q-&gt;count = <span class="number">0</span>;
    q-&gt;head = q-&gt;buffer;
    q-&gt;tail = q-&gt;buffer;
}

<span class="keyword">static</span> <span class="keyword">int</span> task_queue_push(<span class="keyword">struct</span> task_queue * q,
    execute_task exectask,
    <span class="keyword">void</span>* arg)
{
    <span class="keyword">int</span> result = <span class="number">1</span>;
    <span class="keyword">if</span> (q-&gt;count &lt; MAX_TASKS)
    {
        task_init(q-&gt;head,
            exectask,
            arg);

        q-&gt;head++;

        <span class="keyword">if</span> (q-&gt;head == (q-&gt;buffer + MAX_TASKS))
        {
            q-&gt;head = q-&gt;buffer;
        }
        q-&gt;count++;
        result = <span class="number">0</span>;
    }

    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="keyword">static</span> <span class="keyword">struct</span> task* task_queue_pop(<span class="keyword">struct</span> task_queue *q)
{
    <span class="keyword">struct</span> task* task = NULL;
    <span class="keyword">if</span> (q-&gt;count &gt;= <span class="number">0</span>)
    {
        task = q-&gt;tail;
        q-&gt;tail++;
        <span class="keyword">if</span> (q-&gt;tail == (q-&gt;buffer + MAX_TASKS))
        {
            q-&gt;tail = q-&gt;buffer;
        }
        q-&gt;count--;
    }
    <span class="keyword">return</span> task;
}

<span class="keyword">static</span> <span class="keyword">void</span> task_queue_clear(<span class="keyword">struct</span> task_queue *q)
{
    <span class="keyword">while</span> (s_queue.count &gt; <span class="number">0</span>)
    {
        <span class="keyword">struct</span> task *p = task_queue_pop(q);
        p-&gt;exectask(<span class="number">0</span>, p-&gt;arg);
    }
}

<span class="keyword">int</span> main_loop(<span class="keyword">void</span>* pData)
{
    <span class="keyword">for</span> (;;)
    {
        mtx_lock(&amp;s_queue_mutex);

        <span class="keyword">while</span> (!s_stop &amp;&amp;
            s_queue.count == <span class="number">0</span>)
        {
            cnd_wait(&amp;s_condition, &amp;s_queue_mutex);
        }

        <span class="keyword">if</span> (s_stop &amp;&amp;
            s_queue.count == <span class="number">0</span>)
        {
            mtx_unlock(&amp;s_queue_mutex);
            <span class="keyword">break</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">struct</span> task *p = task_queue_pop(&amp;s_queue);
            mtx_unlock(&amp;s_queue_mutex);
            (*p-&gt;exectask)(<span class="number">1</span>, p-&gt;arg);          
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="keyword">int</span> async_pool_init()
{
    task_queue_init(&amp;s_queue);

    <span class="keyword">int</span> r = mtx_init(&amp;s_queue_mutex, mtx_plain);
    <span class="keyword">if</span> (r == thrd_success)
    {
        r = cnd_init(&amp;s_condition);
        <span class="keyword">if</span> (r == thrd_success)
        {
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++)
            {
                r = thrd_create(&amp;s_threads[i], &amp;main_loop, <span class="number">0</span>);
                <span class="keyword">if</span> (r != thrd_success)
                {
                    <span class="keyword">break</span>;
                }
            }
        }
    }
    <span class="keyword">return</span> r == thrd_success ? <span class="number">0</span> : <span class="number">1</span>;
}

<span class="keyword">int</span> async_pool_run(execute_task exectask,
    <span class="keyword">void</span>* arg)
{
    <span class="keyword">int</span> result = <span class="number">0</span>;
    mtx_lock(&amp;s_queue_mutex);

    result = task_queue_push(&amp;s_queue, exectask, arg);

    mtx_unlock(&amp;s_queue_mutex);

    <span class="keyword">if</span> (result == <span class="number">0</span>)
    {
        cnd_broadcast(&amp;s_condition);
    }

    <span class="keyword">return</span> result;
}

<span class="keyword">void</span> async_pool_join()
{
    BOOL wasstoped = FALSE;
    mtx_lock(&amp;s_queue_mutex);
    wasstoped = s_stop;
    s_stop = TRUE;
    mtx_unlock(&amp;s_queue_mutex);

    <span class="keyword">if</span> (wasstoped)
    {
        <span class="keyword">return</span>;
    }

    cnd_broadcast(&amp;s_condition);

    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; POOL_SIZE; ++i)
    {
        <span class="keyword">int</span> res;
        <span class="keyword">int</span> r = thrd_join(s_threads[i], &amp;res);
        assert(r == thrd_success);
    }

    mtx_lock(&amp;s_queue_mutex);
    task_queue_clear(&amp;s_queue);
    mtx_unlock(&amp;s_queue_mutex);
}


</pre>



<p>tinycthread.h e tinycthread.cpp from<a href="https://github.com/tinycthread/tinycthread">https://github.com/tinycthread/tinycthread</a></p>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  