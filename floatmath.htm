
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml"> 
 <head> 
 <title>Thiago's website</title> 
 <link href="trastyle.css" type="text/css" rel="stylesheet"/>    
 <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" /> 
</head> 
 <script type="text/javascript"> var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script> 

 <script type="text/javascript"> try {var pageTracker = _gat._getTracker("UA-9617326-1");pageTracker._trackPageview();} catch(err) {}</script> 
 <body>     <div  class="pageheader">

 <h2>Thiago R. Adams website</h2> <p>     
 
 <a class="linkbox" href="index.htm">HOME</a>     
 <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
 <a class="linkbox" href="about.htm">ABOUT</a>     
 <br /> </p> </div>
 
 <article>

 <!-- Page content begin --> 




<p>64 bits double representation:</p>

<p><a href="http://en.wikipedia.org/wiki/IEEE_754-1985">http://en.wikipedia.org/wiki/IEEE_754-1985</a></p>


<h3>What is the real number represented inside a double type?</h3>

<p>The 64 bits double type uses </p>


<ul>
<li> 1 bit (bit 63) for signal; 1 means negative, 0 positive;</li>
<li> 11 bits for expoent (bit 52-62) (n - 1023)</li>
<li> 52 bits for mantissa (bit 0-51)</li>
</ul>



<p>The number normalized represented in base 2 is:</p>

<p>(1 + 0.xxx) </p>

<p>where 1 is inplicty and xxx are the mantissa digits in binary (base 2).</p>

<p>To convert the fractional binary number in decimal we sum the digits that are 1 plus the implity 1:</p>

<pre>
     1      1
1 + --- + ---- ....
    2^2    2^3
</pre>

<h3>Sample:</h3>

<p>The number 0.15625.</p>

<pre>
 0                                                                 63
 |        mantissa                                    | exp         | signal
 0000000000000000000000000000000000000000000000000010 | 00111111110 | 0

double   = 0.15625
mantissa = 1125899906842624
exponent = -3
signal   = 0

</pre>

<p>The second digit of mantissa is 1 then we have to include it in the sum plus the inplicity 1.</p>

<pre>
         1       -3
 ( 1 +  --- ) * 2 
        2^2 

=&gt;
        1      1
 ( 1 + ---) * --- 
        4      8
=&gt;
  1      1  
  -- +  --- 
  8      32 
=&gt;
  4  + 1  
  ------- 
     32

=&gt;
      5  
  ------- = 1.15625 (exactly)
     32

</pre>



<h3>Some numbers</h3>
<p>See <a href="http://msdn.microsoft.com/en-us/library/6bs3y5ya.aspx">Limits on Floating-Point Constants</a></p>

<hr>

<p>Maximum representable floating-point number.</p>

<p>DBL</p>
<pre>

bits =
1111111111111111111111111111111111111111111111111111011111111110

binary number =
1.1111111111111111111111111111111111111111111111111111 * 2 ^ 1023

double   = 1.79769e+308
mantissa = 4503599627370495
exponent = 1023
signal   = 0
representation :
(2 ^ 1023 + 2 ^ 1022 + 2 ^ 1021 + 2 ^ 1020 + 2 ^ 1019 + 2 ^ 1018 + 2 ^ 1017 + 2
^ 1016 + 2 ^ 1015 + 2 ^ 1014 + 2 ^ 1013 + 2 ^ 1012 + 2 ^ 1011 + 2 ^ 1010 + 2 ^ 1
009 + 2 ^ 1008 + 2 ^ 1007 + 2 ^ 1006 + 2 ^ 1005 + 2 ^ 1004 + 2 ^ 1003 + 2 ^ 1002
 + 2 ^ 1001 + 2 ^ 1000 + 2 ^ 999 + 2 ^ 998 + 2 ^ 997 + 2 ^ 996 + 2 ^ 995 + 2 ^ 9
94 + 2 ^ 993 + 2 ^ 992 + 2 ^ 991 + 2 ^ 990 + 2 ^ 989 + 2 ^ 988 + 2 ^ 987 + 2 ^ 9
86 + 2 ^ 985 + 2 ^ 984 + 2 ^ 983 + 2 ^ 982 + 2 ^ 981 + 2 ^ 980 + 2 ^ 979 + 2 ^ 9
78 + 2 ^ 977 + 2 ^ 976 + 2 ^ 975 + 2 ^ 974 + 2 ^ 973 + 2 ^ 972 + 2 ^ 971)


Decimal:

179769313486231570814527423731704356798070567525844996598917476803157260 ...
780028538760589558632766878171540458953514382464234321326889464182768467 ...
546703537516986049910576551282076245490090389328944075868508455133942304 ...
583236903222948165808559332123348274797826204144723168738177180919299881 ...
250404026184124858368

</pre>

<hr>

<p>Smallest positive number x, such that x + 1.0 is not equal to 1.0.</p>

<p>DBL</p>

<pre>
bits =
0000000000000000000000000000000000000000000000000000110100111100

binary number =
1.0000000000000000000000000000000000000000000000000000 * 2 ^ -52

double   = 2.22045e-016
mantissa = 0
exponent = -52
signal   = 0
representation :
(2 ^ -52)


       1
----------------
4503599627370496

</pre>

<hr>

<p>Minimum positive value.</p>

<p>DBL</p>

<pre>
bits =
0000000000000000000000000000000000000000000000000000100000000000

binary number =
1.0000000000000000000000000000000000000000000000000000 * 2 ^ -1022

double   = 2.22507e-308
mantissa = 0
exponent = -1022
signal   = 0
representation :
(2 ^ -1022)


1/4494232837155789769323262976972561834044942447355766431835752028943316...
895137524078317711933060188400528002846996784833941469744220360415562321...
185765986853109444197335621637131907555490031152352986327073802125144220...
953767058561572036847827763520680929083762767114657455998681148461992907...
6208839082406056034304

</pre>

<hr>

<p>NaN</p>
<pre>
bits =
0000000000000000000000000000000000000000000000000000111111111110

binary number =
1.0000000000000000000000000000000000000000000000000000 * 2 ^ 1024

double   = 1.#INF
mantissa = 0
exponent = 1024
signal   = 0
representation :
(2 ^ 1024)

This is reserved for NAN


</pre>

<hr>

<p>Second biggest number:</p>

<pre>
bits =
0111111111111111111111111111111111111111111111111111011111111110

binary number =
1.1111111111111111111111111111111111111111111111111110 * 2 ^ 1023

double   = 1.79769e+308
mantissa = 4503599627370494
exponent = 1023
signal   = 0
representation :
(2 ^ 1023 + 2 ^ 1022 + 2 ^ 1021 + 2 ^ 1020 + 2 ^ 1019 + 2 ^ 1018 + 2 ^ 1017 + 2
^ 1016 + 2 ^ 1015 + 2 ^ 1014 + 2 ^ 1013 + 2 ^ 1012 + 2 ^ 1011 + 2 ^ 1010 + 2 ^ 1
009 + 2 ^ 1008 + 2 ^ 1007 + 2 ^ 1006 + 2 ^ 1005 + 2 ^ 1004 + 2 ^ 1003 + 2 ^ 1002
 + 2 ^ 1001 + 2 ^ 1000 + 2 ^ 999 + 2 ^ 998 + 2 ^ 997 + 2 ^ 996 + 2 ^ 995 + 2 ^ 9
94 + 2 ^ 993 + 2 ^ 992 + 2 ^ 991 + 2 ^ 990 + 2 ^ 989 + 2 ^ 988 + 2 ^ 987 + 2 ^ 9
86 + 2 ^ 985 + 2 ^ 984 + 2 ^ 983 + 2 ^ 982 + 2 ^ 981 + 2 ^ 980 + 2 ^ 979 + 2 ^ 9
78 + 2 ^ 977 + 2 ^ 976 + 2 ^ 975 + 2 ^ 974 + 2 ^ 973 + 2 ^ 972)


1797693134862315508561243283845062402343434371574593359244048724485818...
457545561143884706399431262203219608040271573715708098528849645117430...
440876627676009095943319277282370788761887605795325637686986540648252...
621157710157914639830148577040081234194593862451417237031480975291084...
23358883457665451722744025579520

</pre>

<p>Distance between first and second biggest numbers:</p>
<pre>
1995840309534719811656372713036838566067451260435457541502547242437211...
8918689640657849579654926357010893424468441924952439724379883935936607...
3917179828483142032000567295108567651753772144436298718265335674454392...
3993330810455120870388888855268448044157507120906875756041642358495230...
3440099278848
</pre>
<hr>

<h3>Source code</h3>

<p>Include</p>

<p><a href="memory.htm">memory</a></p>

<p>limits</p>
<pre>
<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<span class="keyword">void</span> PrintBitsLn(T v)
{
    std::cout &lt;&lt; <span class="string">&quot;bits = &quot;</span> &lt;&lt; std::endl;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(T) * CHAR_BIT ; i++)
    {
        std::cout &lt;&lt; (memory::is_bit_on(v, i) ? <span class="string">'1'</span> : <span class="string">'0'</span>);
    }

    std::cout &lt;&lt; std::endl;
}


<span class="keyword">void</span> PrintBinary(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> u)
{
    std::cout &lt;&lt; <span class="string">&quot;binary number = &quot;</span> &lt;&lt; std::endl;
    <span class="keyword">long</span> <span class="keyword">long</span> exponent = memory::getbits(u, <span class="number">52</span>, <span class="number">11</span>) - <span class="number">1023</span>;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> signal = memory::getbits(u, <span class="number">64</span> - <span class="number">1</span>, <span class="number">1</span>);
    <span class="keyword">if</span> (signal == <span class="number">-1</span>)
      std::cout &lt;&lt; <span class="string">&quot;-&quot;</span>;

    std::cout &lt;&lt; <span class="string">&quot;1.&quot;</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">51</span>; i &gt;= <span class="number">0</span>; i--)
    {
        std::cout &lt;&lt; (memory::is_bit_on(u, i) ? <span class="string">'1'</span> : <span class="string">'0'</span>);
    }

    std::cout &lt;&lt; <span class="string">&quot; * 2 ^ &quot;</span> &lt;&lt; exponent &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
}


<span class="keyword">void</span> Frac(<span class="keyword">double</span> d)
{
    <span class="comment">//http://en.wikipedia.org/wiki/IEEE_754-1985
</span>
    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(d) * CHAR_BIT == <span class="number">64</span>, <span class="string">&quot;expected double with 64 bits&quot;</span>);
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> u = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>*)(&amp;d));

    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> mantissa = memory::getbits(u, <span class="number">0</span>, <span class="number">52</span>);
    <span class="keyword">long</span> <span class="keyword">long</span> exponent = memory::getbits(u, <span class="number">52</span>, <span class="number">11</span>) - <span class="number">1023</span>;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> signal = memory::getbits(u, <span class="number">64</span> - <span class="number">1</span>, <span class="number">1</span>);
  
    PrintBitsLn(u);
    std::cout &lt;&lt; std::endl;
    PrintBinary(u);

    std::cout &lt;&lt; <span class="string">&quot;double   = &quot;</span> &lt;&lt; d &lt;&lt; endl;
    std::cout &lt;&lt; <span class="string">&quot;mantissa = &quot;</span> &lt;&lt; mantissa &lt;&lt; endl;
    std::cout &lt;&lt; <span class="string">&quot;exponent = &quot;</span> &lt;&lt; exponent &lt;&lt; endl;
    std::cout &lt;&lt; <span class="string">&quot;signal   = &quot;</span> &lt;&lt; signal &lt;&lt; endl;

    <span class="keyword">if</span> (exponent == <span class="number">-1023</span>)
    {
        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;
        <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (signal == <span class="number">1</span>)
    {
        cout &lt;&lt; <span class="string">&quot; -1 * &quot;</span> ;
    }

    std::cout &lt;&lt; <span class="string">&quot;representation :&quot;</span> &lt;&lt; std::endl;
    cout &lt;&lt; <span class="string">&quot;(2 ^ &quot;</span> &lt;&lt; exponent &lt;&lt; <span class="string">&quot;&quot;</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">51</span>; i &gt;= <span class="number">0</span> ; i--)
    {
        <span class="keyword">if</span> (memory::is_bit_on(u, i))
        {
            cout &lt;&lt; <span class="string">&quot; + 2 ^ &quot;</span> &lt;&lt; (exponent  - (<span class="number">52</span> - i));
        }
    }

    cout &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;
}
</pre>




<!-- Page content end --> 
</article> 
 
</body> 
</html>  