<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->

<p><a href="tklgen2.htm">TKLGEN HOME</a></p>

<h2>Tutorial and sample</h2>

<p>This sample parse expressions.</p>

<p>This <strong>is not the tklgen grammar</strong> but it helps to think how to build LL1 grammars.</p>


<p>The brackets The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. The unquoted parentheses ( and ) serve only to group elements in a production.)</p>

<pre>
  E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
  T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
  F --&gt; P [&quot;^&quot; F]
  P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
</pre>


<p>Now lets see how to build a tklgen LL1 grammar:</p>

<h3>grammar.txt</h3>

<pre>

<span class="keyword">module</span> Sample2
{
  <span class="keyword">language</span> Sample2
   {
    <span class="keyword">token</span> Plus = <span class="string">'+'</span>;
    <span class="keyword">token</span> Minus = <span class="string">'-'</span>;
    <span class="keyword">token</span> Multi = <span class="string">'*'</span>;
    <span class="keyword">token</span> Div = <span class="string">'/'</span>;
    <span class="keyword">token</span> Power = <span class="string">'^'</span>;
    <span class="keyword">token</span> Open = <span class="string">'('</span>;
    <span class="keyword">token</span> Close = <span class="string">')'</span>;
    <span class="keyword">token</span> End = <span class="string">';'</span>;
    <span class="keyword">token</span> EndMark = <span class="string">'\0'</span>;
    <span class="keyword">token</span> Integer   = (<span class="string">'0'</span>..<span class="string">'9'</span>)+;
    <span class="keyword">token</span> Identifier   = (<span class="string">'a'</span>..<span class="string">'z'</span> | <span class="string">'A'</span>..<span class="string">'Z'</span> | <span class="string">'_'</span> | <span class="string">'$'</span>) +
                       (<span class="string">'0'</span>..<span class="string">'9'</span> + (<span class="string">'a'</span>..<span class="string">'z'</span> | <span class="string">'A'</span>..<span class="string">'Z'</span> | <span class="string">'_'</span> | <span class="string">'$'</span>) +) ?;
    
    <span class="keyword">interleave</span> Blanks  = (<span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span> | <span class="string">&quot;\r&quot;</span>) +;

    
    <span class="keyword">syntax</span> Main = Expressions;
    <span class="keyword">syntax</span> Expression = E <span class="string">';'</span> {PrintNewLine};
    <span class="keyword">syntax</span> Expressions = Expression Expressions | <span class="keyword">empty</span>;

    <span class="comment">// E --&gt; T {( &quot;+&quot; | &quot;-&quot; ) T}
</span>    <span class="keyword">syntax</span> E = T E2;
    <span class="keyword">syntax</span> E2 = <span class="string">'+'</span> T {PrintPlus} E2 |
                <span class="string">'-'</span> T {PrintMinus} E2 |
                <span class="keyword">empty</span>;

    <span class="comment">// T --&gt; F {( &quot;*&quot; | &quot;/&quot; ) F}
</span>    <span class="keyword">syntax</span> T = F T2;
    <span class="keyword">syntax</span> T2 = <span class="string">'*'</span> F {PrintMulti} T2|
                <span class="string">'/'</span> F {PrintDiv}T2|
                <span class="keyword">empty</span>;

    <span class="comment">// F --&gt; P [&quot;^&quot; F]
</span>    <span class="keyword">syntax</span> F = P FOpt;
    <span class="keyword">syntax</span> FOpt = <span class="string">'^'</span> F {PrintPower} | <span class="keyword">empty</span>;

    <span class="comment">// P --&gt; v | &quot;(&quot; E &quot;)&quot; | &quot;-&quot; T
</span>    <span class="keyword">syntax</span> P = {PrintLexeme} Integer |
               {PrintLexeme} Identifier | 
               <span class="string">'('</span> E <span class="string">')'</span> | 
               <span class="string">'-'</span> T {PrintNeg};
      }
}

</pre>


<p>Use this command line:</p>

<pre>
 tklgen grammar.txt
</pre>

<p>The files below will be generated:</p>

<pre>
 Sample2Parser.h
 Sample2Parser.cpp
 Sample2DFA.h
</pre>


<p>The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.</p>

<pre>
Tokenizer.h
FileStream.h
StringStream.h
SampleProgram.txt
</pre>


<h3>Sample2Parser.h</h3>

<pre>
<span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="comment">// Generated by TKLGEN - Version Sep 27 2013
</span><span class="comment">// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// www.thradams.com
</span><span class="comment">//
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span><span class="comment">//
</span><span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="keyword">#pragma</span> once

<span class="keyword">#include</span> &lt;cassert&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;
<span class="keyword">#include</span> <span class="string">&quot;tokenizer.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;Sample2DFA.h&quot;</span>


<span class="keyword">#include</span> <span class="string">&quot;FileStream.h&quot;</span>

<span class="keyword">namespace</span> Sample2
{
    <span class="keyword">enum</span> ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    };

    <span class="keyword">class</span> Context;
    <span class="keyword">void</span> OnError(Context&amp;, ErrorCode);

    <span class="keyword">class</span> ParserException : <span class="keyword">public</span> std::exception
    {
    <span class="keyword">public</span>:
        <span class="keyword">int</span> m_Line;
        <span class="keyword">int</span> m_Col;
        ErrorCode m_Error;
        ParserException(<span class="keyword">int</span> line, <span class="keyword">int</span> col, ErrorCode error)
            : m_Line(line), m_Col(col), m_Error(error)
        {
        }
    };


    <span class="keyword">class</span> Context
    {
    <span class="keyword">public</span>:
        FileStream&amp; m_Stream;

        Tokens m_CurrentToken;
        std::<span class="keyword2">wstring</span> m_lexeme;
        
        Context(FileStream&amp; stream) : m_Stream(stream)
        {
            <span class="keyword">if</span> (!NextToken&lt;DFA&gt;(
                        stream,
                        m_lexeme,
                        m_CurrentToken))
            {
              assert(<span class="keyword">false</span>);
            }
        }
    };

    <span class="keyword">inline</span> <span class="keyword">void</span> OnError(Context&amp; context, ErrorCode er)
    {
        <span class="keyword">throw</span> ParserException(GetLine(context.m_Stream),
                              GetCol(context.m_Stream),
                              er);
    }

    <span class="keyword">inline</span> Tokens GetToken(Context&amp; context)
    {
        <span class="keyword">return</span> context.m_CurrentToken;
    }

    <span class="keyword">inline</span> <span class="keyword">bool</span> Match(Context&amp; context, Tokens tk)
    {
        <span class="keyword">if</span> (tk != context.m_CurrentToken)
        {
            OnError(context, ErrorCodeUnexpectedToken);
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        <span class="keyword">if</span> (!NextToken&lt;DFA&gt;(
                    context.m_Stream,
                    context.m_lexeme,
                    context.m_CurrentToken))
        {
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }


    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintNewLine(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintPlus(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintMinus(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintMulti(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintDiv(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintPower(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintLexeme(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintNeg(Context&amp; <span class="comment">/*ctx*/</span>)
    {
    }

    <span class="keyword">void</span> Parse_Main(Context&amp;);
} <span class="comment">// namespace
</span>
</pre>




<h3>Sample2Parser.cpp</h3>

<pre>
<span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="comment">// Generated by TKLGEN - Version Sep 27 2013
</span><span class="comment">// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// www.thradams.com
</span><span class="comment">//
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span><span class="comment">//
</span><span class="comment">//////////////////////////////////////////////////////////////////////////////
</span>
<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> &lt;cassert&gt;
<span class="keyword">#include</span> &lt;<span class="keyword2">string</span>&gt;
<span class="keyword">#include</span> <span class="string">&quot;tokenizer.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;Sample2DFA.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;Sample2Parser.h&quot;</span>


<span class="keyword">namespace</span> Sample2
{
    <span class="comment">//forward declarations 
</span>    <span class="keyword">void</span> Parse_Main(Context&amp;);
    <span class="keyword">void</span> Parse_Expressions(Context&amp;);
    <span class="keyword">void</span> Parse_E(Context&amp;);
    <span class="keyword">void</span> Parse_T(Context&amp;);
    <span class="keyword">void</span> Parse_E2(Context&amp;);
    <span class="keyword">void</span> Parse_Expression(Context&amp;);
    <span class="keyword">void</span> Parse_T2(Context&amp;);
    <span class="keyword">void</span> Parse_F(Context&amp;);
    <span class="keyword">void</span> Parse_P(Context&amp;);
    <span class="keyword">void</span> Parse_FOpt(Context&amp;);


    <span class="keyword">void</span> Parse_Main(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKEndMark ||
            token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//Main =&gt; Expressions 
</span>            Parse_Expressions(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_Expressions(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//Expressions =&gt; Expression Expressions 
</span>            Parse_Expression(ctx);
            Parse_Expressions(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKEndMark)
        {
            <span class="comment">//Expressions =&gt; Epsilon 
</span>        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_E(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//E =&gt; T E2 
</span>            Parse_T(ctx);
            Parse_E2(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_T(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//T =&gt; F T2 
</span>            Parse_F(ctx);
            Parse_T2(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_E2(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKPlus)
        {
            <span class="comment">//E2 =&gt; Plus T E2 
</span>            Match(ctx, TKPlus);
            Parse_T(ctx);
            Action_PrintPlus(ctx);
            Parse_E2(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKMinus)
        {
            <span class="comment">//E2 =&gt; Minus T E2 
</span>            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintMinus(ctx);
            Parse_E2(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKClose ||
            token == TKEnd)
        {
            <span class="comment">//E2 =&gt; Epsilon 
</span>        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_Expression(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//Expression =&gt; E End 
</span>            Parse_E(ctx);
            Match(ctx, TKEnd);
            Action_PrintNewLine(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_T2(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMulti)
        {
            <span class="comment">//T2 =&gt; Multi F T2 
</span>            Match(ctx, TKMulti);
            Parse_F(ctx);
            Action_PrintMulti(ctx);
            Parse_T2(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKDiv)
        {
            <span class="comment">//T2 =&gt; Div F T2 
</span>            Match(ctx, TKDiv);
            Parse_F(ctx);
            Action_PrintDiv(ctx);
            Parse_T2(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            <span class="comment">//T2 =&gt; Epsilon 
</span>        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_F(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            <span class="comment">//F =&gt; P FOpt 
</span>            Parse_P(ctx);
            Parse_FOpt(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_P(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKInteger)
        {
            <span class="comment">//P =&gt; Integer 
</span>            Action_PrintLexeme(ctx);
            Match(ctx, TKInteger);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKIdentifier)
        {
            <span class="comment">//P =&gt; Identifier 
</span>            Action_PrintLexeme(ctx);
            Match(ctx, TKIdentifier);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKOpen)
        {
            <span class="comment">//P =&gt; Open E Close 
</span>            Match(ctx, TKOpen);
            Parse_E(ctx);
            Match(ctx, TKClose);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKMinus)
        {
            <span class="comment">//P =&gt; Minus T 
</span>            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintNeg(ctx);
        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    <span class="keyword">void</span> Parse_FOpt(Context&amp; ctx)
    {
        <span class="keyword">auto</span> token = GetToken(ctx);

        <span class="keyword">if</span> (token == TKPower)
        {
            <span class="comment">//FOpt =&gt; Power F 
</span>            Match(ctx, TKPower);
            Parse_F(ctx);
            Action_PrintPower(ctx);
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            <span class="comment">//FOpt =&gt; Epsilon 
</span>        }
        <span class="keyword">else</span>
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

} <span class="comment">//namespace Sample2
</span>
</pre>


<h3>Sample2DFA.h</h3>

<pre>
<span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="comment">// Generated by TKLGEN - Version Sep 27 2013
</span><span class="comment">// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// www.thradams.com
</span><span class="comment">//
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span><span class="comment">//
</span><span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="keyword">#ifndef</span> __SAMPLE2DFA_H__
<span class="keyword">#define</span> __SAMPLE2DFA_H__

<span class="keyword">namespace</span> Sample2
{

<span class="keyword">enum</span> Tokens
{
    TKPlus,
    TKMinus,
    TKMulti,
    TKDiv,
    TKPower,
    TKOpen,
    TKClose,
    TKEnd,
    TKEndMark,
    TKInteger,
    TKIdentifier,
    TKBlanks,
};

<span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">wchar_t</span>* TokensToString(Tokens e)
{
    <span class="keyword">switch</span>(e)
    {
    <span class="keyword">case</span> TKPlus: <span class="keyword">return</span> L<span class="string">&quot;Plus&quot;</span>;
    <span class="keyword">case</span> TKMinus: <span class="keyword">return</span> L<span class="string">&quot;Minus&quot;</span>;
    <span class="keyword">case</span> TKMulti: <span class="keyword">return</span> L<span class="string">&quot;Multi&quot;</span>;
    <span class="keyword">case</span> TKDiv: <span class="keyword">return</span> L<span class="string">&quot;Div&quot;</span>;
    <span class="keyword">case</span> TKPower: <span class="keyword">return</span> L<span class="string">&quot;Power&quot;</span>;
    <span class="keyword">case</span> TKOpen: <span class="keyword">return</span> L<span class="string">&quot;Open&quot;</span>;
    <span class="keyword">case</span> TKClose: <span class="keyword">return</span> L<span class="string">&quot;Close&quot;</span>;
    <span class="keyword">case</span> TKEnd: <span class="keyword">return</span> L<span class="string">&quot;End&quot;</span>;
    <span class="keyword">case</span> TKEndMark: <span class="keyword">return</span> L<span class="string">&quot;EndMark&quot;</span>;
    <span class="keyword">case</span> TKInteger: <span class="keyword">return</span> L<span class="string">&quot;Integer&quot;</span>;
    <span class="keyword">case</span> TKIdentifier: <span class="keyword">return</span> L<span class="string">&quot;Identifier&quot;</span>;
    <span class="keyword">case</span> TKBlanks: <span class="keyword">return</span> L<span class="string">&quot;Blanks&quot;</span>;
    <span class="keyword">default</span>:<span class="keyword">break</span>;
    }
    <span class="keyword">return</span> L<span class="string">&quot;&quot;</span>;
}

<span class="keyword">struct</span> DFA
{
    <span class="keyword">typedef</span> Tokens TokenType;

    <span class="keyword">static</span> <span class="keyword">int</span> GetNext(<span class="keyword">int</span> state, <span class="keyword">wchar_t</span> ch)
    {
        <span class="keyword">switch</span> (state)
        {
            <span class="keyword">case</span> <span class="number">0</span>:
            <span class="keyword">if</span> (ch == L<span class="string">'\0'</span>)
                <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'\t'</span> &amp;&amp; ch &lt;= L<span class="string">'\n'</span>)
          <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'\r'</span>)
                <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">' '</span>)
                <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'$'</span>)
                <span class="keyword">return</span> <span class="number">3</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'('</span>)
                <span class="keyword">return</span> <span class="number">4</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">')'</span>)
                <span class="keyword">return</span> <span class="number">5</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'*'</span>)
                <span class="keyword">return</span> <span class="number">6</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'+'</span>)
                <span class="keyword">return</span> <span class="number">7</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'-'</span>)
                <span class="keyword">return</span> <span class="number">8</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'/'</span>)
                <span class="keyword">return</span> <span class="number">9</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'0'</span> &amp;&amp; ch &lt;= L<span class="string">'9'</span>)
          <span class="keyword">return</span> <span class="number">10</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">';'</span>)
                <span class="keyword">return</span> <span class="number">11</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'A'</span> &amp;&amp; ch &lt;= L<span class="string">'Z'</span>)
          <span class="keyword">return</span> <span class="number">3</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'^'</span>)
                <span class="keyword">return</span> <span class="number">12</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'_'</span>)
                <span class="keyword">return</span> <span class="number">3</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= L<span class="string">'z'</span>)
           <span class="keyword">return</span> <span class="number">3</span>;
    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">1</span>:
        <span class="comment">//TKEndMark
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">2</span>:
        <span class="keyword">if</span> (ch &gt;= L<span class="string">'\t'</span> &amp;&amp; ch &lt;= L<span class="string">'\n'</span>)
          <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'\r'</span>)
                <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">' '</span>)
                <span class="keyword">return</span> <span class="number">2</span>;
        <span class="comment">//TKBlanks
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">3</span>:
            <span class="keyword">if</span> (ch == L<span class="string">'$'</span>)
                <span class="keyword">return</span> <span class="number">3</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'0'</span> &amp;&amp; ch &lt;= L<span class="string">'9'</span>)
          <span class="keyword">return</span> <span class="number">14</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'A'</span> &amp;&amp; ch &lt;= L<span class="string">'Z'</span>)
          <span class="keyword">return</span> <span class="number">3</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'_'</span>)
                <span class="keyword">return</span> <span class="number">3</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= L<span class="string">'z'</span>)
          <span class="keyword">return</span> <span class="number">3</span>;
        <span class="comment">//TKIdentifier
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">4</span>:
        <span class="comment">//TKOpen
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">5</span>:
        <span class="comment">//TKClose
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">6</span>:
        <span class="comment">//TKMulti
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">7</span>:
        <span class="comment">//TKPlus
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">8</span>:
        <span class="comment">//TKMinus
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">9</span>:
        <span class="comment">//TKDiv
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">10</span>:
        <span class="keyword">if</span> (ch &gt;= L<span class="string">'0'</span> &amp;&amp; ch &lt;= L<span class="string">'9'</span>)
          <span class="keyword">return</span> <span class="number">10</span>;
        <span class="comment">//TKInteger
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">11</span>:
        <span class="comment">//TKEnd
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">12</span>:
        <span class="comment">//TKPower
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">13</span>:
  <span class="keyword">return</span> <span class="number">-1</span>;
    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">14</span>:
            <span class="keyword">if</span> (ch == L<span class="string">'$'</span>)
                <span class="keyword">return</span> <span class="number">15</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'0'</span> &amp;&amp; ch &lt;= L<span class="string">'9'</span>)
          <span class="keyword">return</span> <span class="number">14</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'A'</span> &amp;&amp; ch &lt;= L<span class="string">'Z'</span>)
          <span class="keyword">return</span> <span class="number">15</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'_'</span>)
                <span class="keyword">return</span> <span class="number">15</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= L<span class="string">'z'</span>)
           <span class="keyword">return</span> <span class="number">15</span>;
    <span class="keyword">break</span>; <span class="comment">// 
</span>            <span class="keyword">case</span> <span class="number">15</span>:
            <span class="keyword">if</span> (ch == L<span class="string">'$'</span>)
                <span class="keyword">return</span> <span class="number">15</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'A'</span> &amp;&amp; ch &lt;= L<span class="string">'Z'</span>)
          <span class="keyword">return</span> <span class="number">15</span>;
            <span class="keyword">else</span> <span class="keyword">if</span> (ch == L<span class="string">'_'</span>)
                <span class="keyword">return</span> <span class="number">15</span>;
        <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= L<span class="string">'a'</span> &amp;&amp; ch &lt;= L<span class="string">'z'</span>)
          <span class="keyword">return</span> <span class="number">15</span>;
        <span class="comment">//TKIdentifier
</span>    <span class="keyword">break</span>; <span class="comment">// 
</span>        } <span class="comment">//switch
</span>        <span class="keyword">return</span> <span class="number">-1</span>;
    }

    <span class="keyword">static</span> <span class="keyword">bool</span> IsInterleave(Tokens tk)
    {
        <span class="keyword">return</span> tk == TKBlanks;
    }

    <span class="keyword">static</span> <span class="keyword">bool</span> GetTokenFromState(<span class="keyword">int</span> state, Tokens&amp; tk)
    {
        <span class="keyword">switch</span>(state)
        {
            <span class="keyword">case</span> <span class="number">1</span>: tk = TKEndMark; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">2</span>: tk = TKBlanks; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">3</span>: tk = TKIdentifier; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">4</span>: tk = TKOpen; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">5</span>: tk = TKClose; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">6</span>: tk = TKMulti; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">7</span>: tk = TKPlus; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">8</span>: tk = TKMinus; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">9</span>: tk = TKDiv; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">10</span>: tk = TKInteger; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">11</span>: tk = TKEnd; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">12</span>: tk = TKPower; <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">15</span>: tk = TKIdentifier; <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
};
} <span class="comment">//namespace
</span><span class="keyword">#endif</span> <span class="comment">//header
</span>
</pre>




<h3>Tokenizer (do not depend on grammar)</h3>

<pre>
<span class="comment">//////////////////////////////////////////////////////////////////////////////
</span><span class="comment">// Generated by TKLGEN - Version Sep 27 2013
</span><span class="comment">// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// www.thradams.com
</span><span class="comment">//
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span><span class="comment">//
</span><span class="comment">//////////////////////////////////////////////////////////////////////////////
</span>
<span class="keyword">#pragma</span> once

<span class="keyword">inline</span> <span class="keyword">void</span> Clear(std::<span class="keyword2">wstring</span>&amp; ws)
{
    ws.clear();
}

<span class="keyword">inline</span> <span class="keyword">void</span> Append(std::<span class="keyword2">wstring</span>&amp; ws, <span class="keyword">wchar_t</span> ch)
{
    ws.append(<span class="number">1</span>, ch);
}


<span class="keyword">inline</span> <span class="keyword">void</span> Clear(std::<span class="keyword2">string</span>&amp; ws)
{
    ws.clear();
}

<span class="keyword">inline</span> <span class="keyword">void</span> Append(std::<span class="keyword2">string</span>&amp; ws, <span class="keyword">char</span> ch)
{
    ws.append(<span class="number">1</span>, ch);
}

<span class="keyword">template</span> &lt; <span class="keyword">class</span> TDFA,
         <span class="keyword">class</span> T,
         <span class="keyword">class</span> TInputStream &gt;
<span class="keyword">bool</span> NextTokenNoInterleave(TInputStream&amp; stream,
                           T&amp; lexeme,
                           <span class="keyword">typename</span> TDFA::TokenType&amp; tk)
{
    Clear(lexeme);
    <span class="keyword">int</span> lastGoodState = <span class="number">-1</span>;
    <span class="keyword">int</span> currentState = <span class="number">0</span>;
    <span class="keyword">wchar_t</span> ch;

    <span class="keyword">while</span> (GetChar(stream, ch))
    {
        currentState = TDFA::GetNext(currentState, ch);

        <span class="keyword">if</span> (currentState == <span class="number">-1</span>)
        {
            PutBack(stream, ch);
            <span class="keyword">break</span>;
        }

        <span class="keyword">typename</span> TDFA::TokenType tk2;

        <span class="keyword">if</span> (TDFA::GetTokenFromState(currentState, tk2))
        {
            tk = tk2;
            lastGoodState = currentState;
        }

        Append(lexeme, ch);
    }

    <span class="keyword">return</span> (lastGoodState != <span class="number">-1</span>);
}

<span class="keyword">template</span> &lt; <span class="keyword">class</span> TDFA,
         <span class="keyword">class</span> T,
         <span class="keyword">class</span> TInputStream &gt;
<span class="keyword">bool</span> NextToken(TInputStream&amp; stream,
               T&amp; lexeme,
               <span class="keyword">typename</span> TDFA::TokenType&amp; tk)
{
    <span class="keyword">for</span> (;;)
    {
        <span class="keyword">if</span> (!NextTokenNoInterleave&lt;TDFA&gt;(stream, lexeme, tk))
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }

        <span class="keyword">if</span> (!TDFA::IsInterleave(tk))
        {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
}



</pre>


<h3>FileStream (do not depend on grammar)</h3>

<pre>


<span class="keyword">#pragma</span> once

<span class="keyword">#include</span> &lt;cstdio&gt;
<span class="keyword">#include</span> &lt;cassert&gt;

<span class="keyword">struct</span> FileStream
{
  <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">wchar_t</span>* BufferIterator;

  <span class="keyword">wchar_t</span>*     m_pCharacteres;
  <span class="keyword">const</span> size_t m_MaxBufferSize;
  <span class="keyword">wchar_t</span>*     m_pCurrentChar;
  FILE*        m_hFile;
  size_t       m_CurrentLine;
  size_t       m_CurrentCol;

  <span class="keyword">bool</span>         m_HasPutBack;
  <span class="keyword">wchar_t</span>      m_PutBackCharacter;

  <span class="keyword">bool</span>         m_EofSent;

  BufferIterator FirstBufferEnd() <span class="keyword">const</span>
  {
    <span class="keyword">return</span> m_pCharacteres + m_MaxBufferSize - <span class="number">1</span>;
  }

  BufferIterator SecondBufferEnd() <span class="keyword">const</span>
  {
    <span class="keyword">return</span> m_pCharacteres + m_MaxBufferSize * <span class="number">2</span> - <span class="number">1</span>;
  }

  <span class="keyword">bool</span> GetCharCore(<span class="keyword">wchar_t</span>&amp; ch)
  {
    <span class="keyword">if</span> (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = <span class="keyword">false</span>;
      m_PutBackCharacter = <span class="number">0</span>;
      <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (m_EofSent)
      <span class="keyword">return</span> <span class="keyword">false</span>;

    ch = *m_pCurrentChar++;

    <span class="keyword">if</span> (ch == L<span class="string">'\0'</span>)
    {
      ch = <span class="string">'\0'</span>;
      m_EofSent = <span class="keyword">true</span>;
    }
    <span class="keyword">else</span>
    {
      <span class="keyword">if</span> (*m_pCurrentChar == L<span class="string">'\0'</span>)
      {
        <span class="keyword">if</span> (m_pCurrentChar == FirstBufferEnd())
        {
          <span class="keyword">wchar_t</span>* pSecondBuffer =
            m_pCharacteres + m_MaxBufferSize;

          size_t r = fread(pSecondBuffer,
                           <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>),
                           m_MaxBufferSize - <span class="number">1</span>,
                           m_hFile);
          pSecondBuffer[r] = <span class="number">0</span>;
          m_pCurrentChar = pSecondBuffer;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (m_pCurrentChar == SecondBufferEnd())
        {
          <span class="keyword">wchar_t</span>* pFirstBuffer = m_pCharacteres;

          size_t r = fread(pFirstBuffer,
                           <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>),
                           m_MaxBufferSize - <span class="number">1</span>,
                           m_hFile);

          pFirstBuffer[r] = <span class="number">0</span>;
          m_pCurrentChar = pFirstBuffer;
        }
      }
    }

    assert(m_pCharacteres[m_MaxBufferSize - <span class="number">1</span>] == <span class="number">0</span>);
    assert(m_pCharacteres[m_MaxBufferSize * <span class="number">2</span> - <span class="number">1</span>] == <span class="number">0</span>);
    <span class="keyword">return</span> <span class="keyword">true</span>;
  }

<span class="keyword">public</span>:

  FileStream(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* fileName, size_t bufferSize = <span class="number">4096</span>)
    : m_MaxBufferSize(bufferSize)
    , m_CurrentLine(<span class="number">1</span>)
    , m_CurrentCol(<span class="number">1</span>)
    , m_HasPutBack(<span class="keyword">false</span>)
    , m_PutBackCharacter(L<span class="string">'\0'</span>)
    , m_EofSent(<span class="keyword">false</span>)
  {
    assert(bufferSize &gt;= <span class="number">2</span>);

    <span class="comment">//allocate 2 buffers
</span>    m_pCharacteres = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[m_MaxBufferSize * <span class="number">2</span>];
    m_pCharacteres[m_MaxBufferSize * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;
    m_pCharacteres[m_MaxBufferSize - <span class="number">1</span>] = <span class="number">0</span>;
    m_pCurrentChar = m_pCharacteres;

    errno_t err = _wfopen_s(&amp;m_hFile, fileName, L<span class="string">&quot;r,ccs=UTF-8&quot;</span>);

    <span class="keyword">if</span> (err == <span class="number">0</span>)
    {
      size_t r = fread(m_pCharacteres,
                       <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>),
                       m_MaxBufferSize - <span class="number">1</span>,
                       m_hFile);

      m_pCharacteres[r] = L<span class="string">'\0'</span>;
    }
  }

  ~FileStream()
  {
    fclose(m_hFile);
    <span class="keyword">delete</span> [] m_pCharacteres;
  }

  <span class="keyword">friend</span> <span class="keyword">void</span> PutBack(FileStream&amp; fileStream, <span class="keyword">wchar_t</span> ch)
  {
    assert(fileStream.m_HasPutBack == <span class="keyword">false</span>);

    <span class="keyword">if</span> (ch == L<span class="string">'\n'</span>)
    {
      <span class="keyword">if</span> (fileStream.m_CurrentLine &gt; <span class="number">1</span>)
      {
        fileStream.m_CurrentLine--;
      }
    }
    <span class="keyword">else</span>
    {
      <span class="keyword">if</span> (fileStream.m_CurrentCol &gt; <span class="number">1</span>)
      {
        fileStream.m_CurrentCol--;
      }
    }

    fileStream.m_PutBackCharacter = ch;
    fileStream.m_HasPutBack = <span class="keyword">true</span>;
  }
  
  <span class="keyword">friend</span> <span class="keyword">bool</span> GetChar(FileStream&amp; fileStream, <span class="keyword">wchar_t</span>&amp; ch)
  {
    <span class="keyword">bool</span> b = fileStream.GetCharCore(ch);

    <span class="keyword">if</span> (b &amp;&amp; ch == L<span class="string">'\n'</span>)
    {
      fileStream.m_CurrentLine++;
      fileStream.m_CurrentCol = <span class="number">1</span>;
    }
    <span class="keyword">else</span>
    {
      fileStream.m_CurrentCol++;
    }

    <span class="keyword">return</span> b;
  }

  <span class="keyword">friend</span> size_t GetLine(<span class="keyword">const</span> FileStream&amp; fileStream)
  {
    <span class="keyword">return</span> fileStream.m_CurrentLine;
  }

  <span class="keyword">friend</span> size_t GetCol(<span class="keyword">const</span> FileStream&amp; fileStream)
  {
    <span class="keyword">return</span> fileStream.m_CurrentCol;
  }
};


</pre>


<h3>StringStream (do not depend on grammar) ===</h3>

<pre>

<span class="keyword">#pragma</span> once
<span class="keyword">#include</span> &lt;cassert&gt;

<span class="keyword">struct</span> StringStream
{
  <span class="keyword">const</span> <span class="keyword">wchar_t</span>* m_pCharacteres;
  <span class="keyword">const</span> <span class="keyword">wchar_t</span>* m_pCurrentChar;
  size_t         m_CurrentLine;
  size_t         m_CurrentCol;
  <span class="keyword">bool</span>           m_HasPutBack;
  <span class="keyword">wchar_t</span>        m_PutBackCharacter;
  <span class="keyword">bool</span>           m_EofSent;

  <span class="keyword">bool</span> GetCharCore(<span class="keyword">wchar_t</span>&amp; ch)
  {
    <span class="keyword">if</span> (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = <span class="keyword">false</span>;
      m_PutBackCharacter = <span class="number">0</span>;
      <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (m_EofSent)
      <span class="keyword">return</span> <span class="keyword">false</span>;

    ch = *m_pCurrentChar++;

    <span class="keyword">if</span> (ch == L<span class="string">'\0'</span>)
    {
      ch = <span class="string">'\0'</span>;
      m_EofSent = <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
  }

<span class="keyword">public</span>:

  StringStream(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* psz)
    : m_pCharacteres(psz)
    , m_CurrentLine(<span class="number">1</span>)
    , m_CurrentCol(<span class="number">1</span>)
    , m_HasPutBack(<span class="keyword">false</span>)
    , m_PutBackCharacter(L<span class="string">'\0'</span>)
    , m_EofSent(<span class="keyword">false</span>)
  {
    m_pCurrentChar = m_pCharacteres;
  }

  <span class="keyword">friend</span> <span class="keyword">void</span> PutBack(StringStream&amp; stream,  <span class="keyword">wchar_t</span> ch)
  {
    assert(stream.m_HasPutBack == <span class="keyword">false</span>);

    <span class="keyword">if</span> (ch == L<span class="string">'\n'</span>)
    {
      <span class="keyword">if</span> (stream.m_CurrentLine &gt; <span class="number">1</span>)
      {
        stream.m_CurrentLine--;
      }
    }
    <span class="keyword">else</span>
    {
      <span class="keyword">if</span> (stream.m_CurrentCol &gt; <span class="number">1</span>)
      {
        stream.m_CurrentCol--;
      }
    }

    stream.m_PutBackCharacter = ch;
    stream.m_HasPutBack = <span class="keyword">true</span>;
  }

  <span class="keyword">friend</span> <span class="keyword">bool</span> GetChar(StringStream&amp; stream, <span class="keyword">wchar_t</span>&amp; ch)
  {
    <span class="keyword">bool</span> b = stream.GetCharCore(ch);

    <span class="keyword">if</span> (b &amp;&amp; ch == L<span class="string">'\n'</span>)
    {
      stream.m_CurrentLine++;
      stream.m_CurrentCol = <span class="number">1</span>;
    }
    <span class="keyword">else</span>
    {
      stream.m_CurrentCol++;
    }

    <span class="keyword">return</span> b;
  }

  size_t GetLine(<span class="keyword">const</span> StringStream&amp; stream)
  {
    <span class="keyword">return</span> stream.m_CurrentLine;
  }

  size_t GetCol(<span class="keyword">const</span> StringStream&amp; stream) 
  {
    <span class="keyword">return</span> stream.m_CurrentCol;
  }
};

</pre>



<h3>SampleProgram.txt (just a sample)===</h3>


<pre>

<span class="keyword">#include</span> <span class="string">&quot;stdafx.h&quot;</span>
<span class="keyword">#include</span> <span class="string">&quot;Sample2Parser.h&quot;</span>
<span class="keyword">#include</span> &lt;iostream&gt;

<span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])
{
  <span class="keyword">if</span> (argc == <span class="number">1</span>)
  {
    std::cout &lt;&lt; <span class="string">&quot;missing input file &quot;</span>;
    <span class="keyword">return</span> <span class="number">1</span>;
  }

  <span class="keyword">try</span>
  {
    FileStream ss(argv[<span class="number">1</span>]);
    Sample2::Context ctx(ss);
    Sample2::Parse_Main(ctx);
  }
  <span class="keyword">catch</span> (<span class="keyword">const</span> Sample2::ParserException&amp; e)
  {
    std::cout &lt;&lt; <span class="string">&quot;Error : line, col = &quot;</span> &lt;&lt; e.m_Line &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; e.m_Col &lt;&lt; std::endl;
  }
  <span class="keyword">catch</span> (<span class="keyword">const</span> std::exception&amp; e)
  {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  <span class="keyword">return</span> <span class="number">0</span>;
}

</pre>



<h2>Modifed SampleParser.h</h2>


<pre>

<span class="comment">//iostream included
</span><span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using</span> <span class="keyword">namespace</span> std;

...

   <span class="comment">//Actions added
</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintNewLine(Context&amp; <span class="comment">/*ctx*/</span>)
    {
      wcout &lt;&lt; std::endl;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintPlus(Context&amp; <span class="comment">/*ctx*/</span>)
    {    
       wcout &lt;&lt; L<span class="string">&quot; +&quot;</span>;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintMinus(Context&amp; <span class="comment">/*ctx*/</span>)
    {
        wcout &lt;&lt; L<span class="string">&quot; -&quot;</span>;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintMulti(Context&amp; <span class="comment">/*ctx*/</span>)
    {
       wcout &lt;&lt; L<span class="string">&quot; *&quot;</span>;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintDiv(Context&amp; <span class="comment">/*ctx*/</span>)
    {
       wcout &lt;&lt; L<span class="string">&quot; /&quot;</span>;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintPower(Context&amp; <span class="comment">/*ctx*/</span>)
    {
       wcout &lt;&lt; L<span class="string">&quot; ^&quot;</span>;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintLexeme(Context&amp; ctx)
    {
         wcout &lt;&lt; L<span class="string">&quot; &quot;</span> &lt;&lt; ctx.m_lexeme;
    }

    <span class="keyword">inline</span> <span class="keyword">void</span> Action_PrintNeg(Context&amp; <span class="comment">/*ctx*/</span>)
    {
         wcout &lt;&lt; L<span class="string">&quot; NEG&quot;</span>;
    }

...
} <span class="comment">// namespace
</span>
</pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  