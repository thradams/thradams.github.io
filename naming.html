<!DOCTYPE html>
<html>
<head>
   <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href = "default.min.css">
  <script src = "highlight.min.js"></script>
  <script>hljs.highlightAll(); </script>
 <link rel = "stylesheet" href = "style.css"/>
</head>
<body>
<a class = "linkbox" href = "index.html" > HOME</a>
<a class = "linkbox" href = "codeblog.html">CODE-BLOG</a>
<a class = "linkbox" href = "about.html">ABOUT </a>
<h2 id="toc_0">My naming conventions</h2>

<h3>General conventions</h3>

<ul>
<li>Do favour readability over brevity.</li>
<li>Don&#39;t use underscores, hyphens, or any non alphanumeric char.</li>
</ul>

<h3>Capitalization conventions</h3>

<ul>
<li>Use PascalCasing for namespace, types, and member names </li>
<li>Use camelCasing for parameter names, local variables</li>
<li>SCREAMING_CAPS for macros (if you can not avoid them)</li>
</ul>

<h3>Names of classes, structs and interfaces</h3>

<ul>
<li>Use PascalCasing.</li>
<li>Do not use prefixes like &quot;C&quot; or &quot;T&quot; for class types</li>
<li>Use the &quot;I&quot; prefix for interfaces</li>
<li>Consider end the names of derived class with the name of base class</li>
<li>For exception classes use the suffix &quot;Exception&quot;</li>
<li>Try not to use the name or suffix &quot;Manager&quot;</li>
<li>Don&#39;t use the name or suffix &quot;Singleton&quot;
E.g.
```cpp
// interfaces
struct ISerialize {};</li>
</ul>

<p>//derived classes
class Dialog {};
class FontDialog : public Dialog{};</p>

<p>// exception classes
class SocketException : public std::exception {};</p>

<pre><code>
###Data Members

*Use the prefix &quot;m_&quot; for data members and &quot;s_&quot; for static data members.

###Naming Enumerations

* Use the enumeration name as a prefix of the enumerations items
```cpp
enum FontStyle
{
   FontStyleNormal,
   FontStyleBold,
   FontStyleItalic
};
</code></pre>

<p>Use &quot;EnumNameNone&quot; when appropriated for the 0 value
Namespaces</p>

<ul>
<li>Use PascalCasing.</li>
<li>Avoid names like &quot;Utils&quot;, &quot;Utilities&quot;, &quot;Management&quot;, &quot;Common&quot;, &quot;Misc&quot;, &quot;Tools&quot; (This rule is valid for libs and classes as well)</li>
<li>Use anonymous namespaces inside cpp files</li>
<li>Use &quot;Detail&quot; namespace in header files to create sub-namespaces that are useful only for the implementation</li>
</ul>

<h3>Functions</h3>

<ul>
<li>Use PascalCasing.</li>
<li>The name for functions should be a verb like:
<code>cpp
Remove();
Create();
</code></li>
</ul>

<h3>Member functions</h3>

<p>*Use the prefix &quot;Get&quot; for data member inquiries - Use &quot;Set&quot; to modify values.
<code>
CString Class::GetName() const;
void Class::SetName(const CString &amp;);
</code>
* For Boolean inquires use: &quot;Is&quot;, &quot;Can&quot;, &quot;Has&quot;
E.g.
<code>cpp
bool Class::CanSearch() const;
bool Class::IsActive() const;
bool Class::HasChild() const;
</code>
Use only affirmative phrases. Don&#39;t use IsNotActive, or CannotSearch</p>

<h3>Function arguments</h3>

<ul>
<li>Use camelCasing. </li>
<li>Describe the argument meaning</li>
</ul>

<p>In header files is not always necessary to have an argument name
For instance, I prefer to declare copy constructors without naming the argument
E.g.
<code>cpp
class X
{
    X(const X&amp;);
    X &amp; operator = (const X&amp;);
    void DrawLine(const Pen &amp;); // is possible to understand, isn&#39;t it?
};
</code></p>

<ul>
<li>Consider the suffix &quot;Name&quot;, &quot;Text&quot; for string types or anything that reminds text
<code>cpp
Open(const string &amp;fileName);
Alert(const string &amp;alertText);
Alert(const string &amp;alertMessage);
</code>
Some people like to use the prefix &quot;str&quot; for strings. I don&#39;t like because choosing the correct name the prefix &quot;str&quot; is redundant.
<code>cpp
Open(const string &amp;strFileName);
//is not better than
Open(const string &amp;fileName);
</code>
The &quot;Name&quot; suffix for me means text; Otherwise I will specify different like:
Open(int fileId);</li>
<li>Consider the suffix &quot;Count&quot;, &quot;Index&quot; for integer types.</li>
<li>Consider the prefix &quot;num&quot; for integer types
E.g.
<code>cpp
void Array::GetAt(int index);
void Allocator::Allocate(int numElements);
</code></li>
</ul>

<h3>Variables</h3>

<ul>
<li>Use camelCasing</li>
</ul>

<p>If choosing the type name to use as the variable name is enough to understand the variable meaning then use it.
E.g.
```cpp
class Airplane
{
    Propeller m_Propeller;
};</p>

<p>Airplane airplane;
```</p>

<p>If the type name is not enough to understand the variable then explain what makes it different
<code>
Airplane bigAirplane(100);
Airplane smallAirplane(1);
</code></p>

<h3>Name for containers</h3>

<p>If plural name of the item is enough to understand the meaning do like this:
E.g.
<code>
std::vector&lt;Control&gt; m_Controls;
</code>
if you need to specify a name don&#39;t do this
<code>
std::vector&lt;Control&gt; m_Controls1;
</code>
Do something like:
<code>
std::vector&lt;Control&gt; m_StaticControls;
std::vector&lt;Control&gt; m_DynamicControls;
</code>
This tip is valid for arguments and variables as well
E.g.
<code>
//Don&#39;t do this
Paint(const Pen &amp; pen1, const Pen &amp; pen2);
//Do
Paint(const Pen &amp; backgroundPen, const Pen &amp; borderPen);
</code></p>

<h3>Important variable prefixes</h3>

<ul>
<li>Use the &quot;sp&quot; for smart pointers and use &quot;p&quot; for pointers</li>
<li>Use the prefix &quot;h&quot; or the suffix &quot;Handle&quot; for handles E.g.
<code>cpp
class File
{
FILE m_hFile; // or m_FileHandle;
shared_ptr&lt;Item&gt; m_spItem;
Item * m_pSelectedItem;
};
</code></li>
</ul>
</body></html>