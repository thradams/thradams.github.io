<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h2>Pattern matching</h2>

<p>Generic algorithms to find patterns similar to regular expressions </p>

<p>Operators:</p>
<pre>
(Expression) * OneOrMore : 
(Expression) * ZeroOrMore : 
(Expression) * Optional : 
! (Expression) : Not 
(Left)&amp;(Right) : And 
(Left)|(Right) : Or 
Val(iterator::value_type) : Matches this value
Range(begin, end) : Matches if the value is in the interval begin end
</pre>

<p>Sample</p>

<pre>
<span class="keyword">int</span> main()
{
    std::<span class="keyword2">string</span> s = <span class="string">&quot;a 123 b 45.67 c&quot;</span> ;
    <span class="keyword">using</span> <span class="keyword">namespace</span> PatternMatching;

    find_replace(s,
                 Range(<span class="string">'0'</span>, <span class="string">'9'</span>) * OneOrMore &amp; (<span class="string">'.'</span> &amp; Range(<span class="string">'0'</span>, <span class="string">'9'</span>) * OneOrMore) * Optional,
                 std::<span class="keyword2">string</span>(<span class="string">&quot;NUMBER&quot;</span>));



    <span class="keyword">using</span> <span class="keyword">namespace</span> PatternMatching;
    std::<span class="keyword2">wstring</span> ss = L<span class="string">&quot;121.54&quot;</span>;

    Result r;
    <span class="comment">//number :  digit+ ('.' digit+)?
</span>    std::<span class="keyword2">wstring</span>::iterator it = Match(ss.begin(), ss.end(),
                                      Range(L<span class="string">'0'</span>, L<span class="string">'9'</span>) * OneOrMore &amp; (L<span class="string">'.'</span> &amp; Range(L<span class="string">'0'</span>, L<span class="string">'9'</span>) * OneOrMore) * Optional, r);
    <span class="keyword">if</span> (r)
    {
<span class="comment">//        std::wcout &lt;&lt; *it;
</span>    }

    std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt; v;
    v.push_back(<span class="number">1</span>);
    v.push_back(<span class="number">2</span>);
    v.push_back(<span class="number">2</span>);
    v.push_back(<span class="number">4</span>);

    <span class="comment">//while not 2 walk...
</span>    std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = Match(v.begin(), v.end(), ! Val(<span class="number">2</span>) * ZeroOrMore, r);
    <span class="keyword">if</span> (it2 != v.begin())
    {
        std::cout &lt;&lt; *it2;
    }

    std::<span class="keyword2">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it3 =  Find(v.begin(), v.end(), (Val(<span class="number">2</span>) | Val(<span class="number">3</span>)) * OneOrMore);

    <span class="keyword">return</span> <span class="number">0</span>;
}

</pre>


<p>Code</p>
<pre>


<span class="comment">// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)
</span><span class="comment">// Permission to copy, use, modify, sell and distribute this software
</span><span class="comment">// is granted provided this copyright notice appears in all copies.
</span><span class="comment">// This software is provided &quot;as is&quot; without express or implied
</span><span class="comment">// warranty, and with no claim as to its suitability for any purpose.
</span>
<span class="keyword">namespace</span> PatternMatching
{
    <span class="keyword">enum</span> Result
    {
        ResultFalse = <span class="number">0</span>,
        ResultTrue,
        ResultTrueOptional,
        ResultFalseOptional
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Expression&gt;
    Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                   <span class="keyword">const</span> Iterator&amp; end,
                   <span class="keyword">const</span> Expression&amp; expr,
                   Result&amp; result)
    {
        <span class="keyword">return</span> expr.Match(begin, end, result);
    }

<span class="comment">//especialization
</span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
    Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                   <span class="keyword">const</span> Iterator&amp; end,
                   <span class="keyword">const</span> <span class="keyword">typename</span> Iterator::value_type&amp; value,
                   Result&amp; result)
    {
        result = ResultFalse;
        std::cout &lt;&lt; <span class="string">&quot;Val&quot;</span> &lt;&lt; std::endl;
        <span class="keyword">if</span> (begin == end)
            <span class="keyword">return</span> begin;
        result = (*begin == value) ? ResultTrue : ResultFalse;
        <span class="keyword">if</span> (result)
        {
            <span class="keyword">return</span> begin;<span class="comment">// + 1;
</span>        }
        <span class="keyword">return</span> begin;
    }


    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
    <span class="keyword">struct</span> ValT
    {
        T ch;
        ValT(<span class="keyword">const</span> T&amp; c) : ch(c) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;ValT&quot;</span> &lt;&lt; std::endl;
            result = ResultFalse;
            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;

            result = (*begin == ch) ? ResultTrue : ResultFalse;
            <span class="comment">//if (result)
</span>            <span class="comment">//{
</span>            <span class="comment">//  return begin;// + 1;
</span>            <span class="comment">//}
</span>            <span class="keyword">return</span> begin;
        }
    };
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
    ValT&lt;T&gt; Val(<span class="keyword">const</span> T&amp; v)
    {
        <span class="keyword">return</span> v;
    }


    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
    <span class="keyword">struct</span> RangeT
    {
        T m_begin;
        T m_end;
        RangeT(T b, T e) : m_begin(b), m_end(e) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;Range&quot;</span> &lt;&lt; std::endl;
            result = ResultFalse;
            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;
            <span class="keyword">if</span> ((*begin &gt;= m_begin) &amp;&amp; (*begin &lt;= m_end))
                result = ResultTrue;
            <span class="keyword">else</span>
                result = ResultFalse;
            <span class="comment">//if (result)
</span>            <span class="comment">//{
</span>            <span class="comment">//  return begin ;//+ 1;
</span>            <span class="comment">//}
</span>            <span class="keyword">return</span> begin;
        }
    };
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
    RangeT&lt;T&gt; Range(<span class="keyword">const</span> T&amp; begin, <span class="keyword">const</span> T&amp; end)
    {
        <span class="keyword">return</span> RangeT&lt;T&gt;(begin, end);
    }


    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;
    <span class="keyword">struct</span> NotExpression
    {
        Expr exp;
        NotExpression(<span class="keyword">const</span> Expr&amp; ll) : exp(ll) {}
        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;Not&quot;</span> &lt;&lt; std::endl;
            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;
            Iterator it = PatternMatching::Match(begin, end, exp, result);
            <span class="keyword">if</span> (result == ResultFalse)
            {
                result = ResultTrue;
                <span class="keyword">return</span> begin;
            }
            <span class="keyword">else</span>
            {
              result = ResultFalse;
            }
            <span class="keyword">return</span> it;
        }
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;
    NotExpression&lt;Expr&gt; <span class="keyword">operator</span>!(<span class="keyword">const</span> Expr&amp; a)
    {
        <span class="keyword">return</span> NotExpression&lt;Expr&gt;(a);
    }


    <span class="keyword">enum</span> ZeroOrMoreT {ZeroOrMore};
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Expr&gt;
    <span class="keyword">struct</span> ZeroOrMoreExpression
    {
        Expr exp;
        ZeroOrMoreExpression(<span class="keyword">const</span> Expr&amp; e) : exp(e) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;ZeroOrMore&quot;</span> &lt;&lt; std::endl;
            result = ResultFalse;
            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;
            Iterator it(begin);
            result = ResultTrue;
            <span class="keyword">while</span> (result == ResultTrue)
            {
                Result r;
                Iterator it2 = PatternMatching::Match(it, end, exp, r);
                <span class="keyword">if</span> (r == ResultFalse)
                    <span class="keyword">break</span>;
                it++;<span class="comment">//passa p frente
</span>                it = it2;
            }
            <span class="keyword">return</span> it;
        }
    };


    <span class="keyword">enum</span> OneOrMoreT {OneOrMore};
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Expr&gt;
    <span class="keyword">struct</span> OneOrMoreExpression
    {
        Expr exp;
        OneOrMoreExpression(<span class="keyword">const</span> Expr&amp; e) : exp(e) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;OneOrMore&quot;</span> &lt;&lt; std::endl;

            result = ResultFalse;
            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;
            Iterator it(begin);

            it = PatternMatching::Match(begin, end, exp, result);
            <span class="keyword">if</span> (result == ResultFalse)
                <span class="keyword">return</span> begin;
            result = ResultTrue;

            Iterator it2 = it;
            it2++;<span class="comment">//passa p frente
</span>
            <span class="keyword">for</span> (;it2 != end;)
            {
                Result r2;
                it2 = PatternMatching::Match(it2, end, exp, r2);
                <span class="keyword">if</span> (r2 == ResultFalse)
                    <span class="keyword">break</span>;
                result = ResultTrue;
                it = it2;
                <span class="keyword">if</span> (it2 == end)
                  <span class="keyword">break</span>;
                it2++;<span class="comment">//passa p frente
</span>            }
            <span class="keyword">return</span> it;
        }
    };

    <span class="keyword">struct</span> OptionalExpressionType {};

    <span class="keyword">enum</span> OptionalT {Optional};
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Expr&gt;
    <span class="keyword">struct</span> OptionalExpression : <span class="keyword">public</span> OptionalExpressionType
    {
        Expr exp;
        OptionalExpression(<span class="keyword">const</span> Expr&amp; e) : exp(e) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;Optional&quot;</span> &lt;&lt; std::endl;
            result = ResultFalse;

            <span class="keyword">if</span> (begin == end)
                <span class="keyword">return</span> begin;

            Iterator it = PatternMatching::Match(begin, end, exp, result);
            <span class="keyword">if</span> (result == ResultFalse)
                result = ResultFalseOptional;
            <span class="keyword">else</span>
                result = ResultTrueOptional;

            <span class="keyword">return</span> it;
        }
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> left, <span class="keyword">class</span> right&gt;
    <span class="keyword">struct</span> AndExpression
    {
        left l;
        right r;
        AndExpression(<span class="keyword">const</span> left&amp; ll,
                      <span class="keyword">const</span> right&amp; rr) : r(rr), l(ll)
        {
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
          result = ResultFalse;
           <span class="keyword">if</span> (begin == end)
             <span class="keyword">return</span> begin;

            std::cout &lt;&lt; <span class="string">&quot;And&quot;</span> &lt;&lt; std::endl;
            
            Iterator it = PatternMatching::Match(begin, end, l, result);
            <span class="keyword">if</span> (result == ResultFalse)
                <span class="keyword">return</span> begin;

            Iterator it2 = it;
            it2++; <span class="comment">//passar 1 p frente
</span>
            it2 = PatternMatching::Match(it2, end, r, result);
            <span class="keyword">if</span> (result == ResultFalse)
                <span class="keyword">return</span> begin;

            <span class="keyword">if</span> (result == ResultFalseOptional)
            {
                result = ResultTrue;
                <span class="comment">//fica parado
</span>                it = it;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (result == ResultTrueOptional)
            {
                result = ResultTrue;
                it = it2; <span class="comment">//commit
</span>            }
            <span class="keyword">else</span>
            {
                it = it2; <span class="comment">//commit
</span>            }

            <span class="keyword">return</span> it;
        }
    };
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> left, <span class="keyword">class</span> right&gt;
    <span class="keyword">struct</span> OrExpression
    {
        left l;
        right r;
        OrExpression(<span class="keyword">const</span> left&amp; ll,
                     <span class="keyword">const</span> right&amp; rr) : r(rr), l(ll)
        {
        }

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;Or&quot;</span> &lt;&lt; std::endl;
            Iterator it = PatternMatching::Match(begin, end, l, result);
            <span class="keyword">if</span> (result)
                <span class="keyword">return</span> it;
            Iterator it2(it);
            it2++;

            it2 = PatternMatching::Match(it2, end, r, result);
            <span class="keyword">if</span> (result != ResultFalse)
            {
                it = it2; <span class="comment">//comit
</span>            }
            <span class="keyword">return</span> it;
        }
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
    <span class="keyword">struct</span> FunctionExpression
    {
        <span class="keyword">typedef</span> Iterator(*MatchFunction)(<span class="keyword">const</span> Iterator&amp; begin,
                                         <span class="keyword">const</span> Iterator&amp; end,
                                         Result&amp; result);
        MatchFunction m_f;

        FunctionExpression(MatchFunction f): m_f(f) {}

        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        Iterator Match(<span class="keyword">const</span> Iterator&amp; begin,
                       <span class="keyword">const</span> Iterator&amp; end,
                       Result&amp; result) <span class="keyword">const</span>
        {
            std::cout &lt;&lt; <span class="string">&quot;F&quot;</span> &lt;&lt; std::endl;
            <span class="keyword">return</span> (*m_f)(begin, end, result);
        }
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
    FunctionExpression&lt;Iterator&gt; F(Iterator(*f)(<span class="keyword">const</span> Iterator&amp; begin,
                                                <span class="keyword">const</span> Iterator&amp; end,
                                                Result&amp; result))
    {
        <span class="keyword">return</span> FunctionExpression&lt;Iterator&gt;(f);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;
    OptionalExpression&lt;Expr&gt; <span class="keyword">operator</span> *(<span class="keyword">const</span> Expr&amp; a,  OptionalT)
    {
        <span class="keyword">return</span> OptionalExpression&lt;Expr&gt;(a);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;
    OneOrMoreExpression&lt;Expr&gt; <span class="keyword">operator</span> *(<span class="keyword">const</span> Expr&amp; a,  OneOrMoreT)
    {
        <span class="keyword">return</span> OneOrMoreExpression&lt;Expr&gt;(a);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Expr&gt;
    ZeroOrMoreExpression&lt;Expr&gt; <span class="keyword">operator</span> *(<span class="keyword">const</span> Expr&amp; a,  ZeroOrMoreT)
    {
        <span class="keyword">return</span> ZeroOrMoreExpression&lt;Expr&gt;(a);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> left, <span class="keyword">class</span> right&gt;
    AndExpression&lt;left, right&gt; <span class="keyword">operator</span> &amp; (<span class="keyword">const</span> left&amp; l, <span class="keyword">const</span> right&amp; r)
    {
        <span class="keyword">return</span> AndExpression&lt;left, right&gt;(l, r);
    }

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> left, <span class="keyword">class</span> right&gt;
    OrExpression&lt;left, right&gt; <span class="keyword">operator</span> | (<span class="keyword">const</span> left&amp; l, <span class="keyword">const</span> right&amp; r)
    {
        <span class="keyword">return</span> OrExpression&lt;left, right&gt;(l, r);
    }
} <span class="comment">//namespace PatternMatching
</span>

<span class="keyword">template</span>&lt;<span class="keyword">class</span>  Exp&gt;
<span class="keyword">inline</span> <span class="keyword">void</span> find_replace(std::<span class="keyword2">string</span>&amp; in_this_string,
                         <span class="keyword">const</span> Exp&amp; e,
                         <span class="keyword">const</span> std::<span class="keyword2">string</span>&amp; replace)
{
    <span class="keyword">using</span> <span class="keyword">namespace</span> PatternMatching;

    std::<span class="keyword2">string</span>::iterator itbegin = in_this_string.begin();

    <span class="keyword">for</span> (; itbegin != in_this_string.end();)
    {
        Result r;
        std::<span class="keyword2">string</span>::iterator it = PatternMatching::Match(itbegin, in_this_string.end(), e, r);
        <span class="keyword">if</span> (r == ResultTrue || r == ResultTrueOptional)
        {
            size_t pos = itbegin - in_this_string.begin();
            in_this_string.replace(itbegin, it + <span class="number">1</span>, replace);

            itbegin = in_this_string.begin() + pos + replace.length();
        }
        <span class="keyword">else</span>
        {
            itbegin++;
        }
    }
}


<span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span>  Exp&gt;
<span class="keyword">inline</span> Iterator Find(<span class="keyword">const</span> Iterator&amp; begin,
                     <span class="keyword">const</span> Iterator&amp; end,
                     <span class="keyword">const</span> Exp&amp; e)
{
    Iterator itbegin = begin;

    <span class="keyword">for</span> (; itbegin != end; itbegin++)
    {
        PatternMatching::Result r;
        Iterator it = PatternMatching::Match(itbegin, end, e, r);
        <span class="keyword">if</span> (r != PatternMatching::ResultFalse)
        {
            <span class="keyword">return</span> it;
        }
    }
}

</pre>


<!-- Page content end --> 
</article> 
 
</body> 
</html>  