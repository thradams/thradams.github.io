<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Remove Empty Lines</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 0; background: #f6f7f9; color: #0f172a; }
    .container { max-width: 900px; margin: 3rem auto; padding: 1.25rem; }
    .card { background: white; border-radius: 16px; box-shadow: 0 2px 12px rgba(0,0,0,.06); padding: 1.25rem; }
    h1 { font-size: 1.25rem; margin: 0 0 1rem; }
    textarea { width: 100%; min-height: 320px; resize: vertical; padding: .75rem; border-radius: 12px; border: 1px solid #e2e8f0; font: 14px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .row { display:flex; gap:.75rem; align-items:center; margin-top: .75rem; flex-wrap: wrap; }
    button { border: 0; border-radius: 12px; padding: .6rem .9rem; font-weight: 600; cursor: pointer; background: #0ea5e9; color: white; box-shadow: 0 1px 5px rgba(14,165,233,.35); }
    button.secondary { background: #e2e8f0; color: #111827; box-shadow:none; }
    label { display:flex; align-items:center; gap:.5rem; font-size:.9rem; color:#334155; }
    .muted { color:#64748b; font-size:.85rem; margin-top:.5rem; }
    #defines { margin-top: 1rem; padding: 1rem; background:#f1f5f9; border-radius:12px; font-size:.9rem; }
    #defines h2 { margin-top:0; font-size:1rem; }
    #defines ul { margin:0; padding-left:1.25rem; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Remove Empty Lines</h1>
      <textarea id="text" placeholder="Paste or type text hereâ€¦&#10;&#10;Lines that are blank, only whitespace, or '#pragma once' will be removed."></textarea>
      <div class="row">
        <button id="removeBtn" title="Remove blank/whitespace-only lines and #pragma once (Ctrl+Enter)">Remove empty lines</button>
        <button id="copyBtn" class="secondary" title="Copy result to clipboard">Copy</button>
        <button id="clearBtn" class="secondary" title="Clear the textarea">Clear</button>
        <label><input type="checkbox" id="dedupe" /> Also deduplicate consecutive blank lines (keep one)</label>
      </div>
      <p class="muted">Tip: Press <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to remove empty lines.</p>
      <div id="defines">
        <h2>Defines found:</h2>
        <ul id="defineList"></ul>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const ta = document.getElementById('text');
      const btn = document.getElementById('removeBtn');
      const copyBtn = document.getElementById('copyBtn');
      const clearBtn = document.getElementById('clearBtn');
      const dedupe = document.getElementById('dedupe');
      const defineList = document.getElementById('defineList');

      function removeEmptyLines() {
        // Normalize Windows/Mac line endings to \n for processing
        const normalized = ta.value.replace(/\r\n?|\u2028|\u2029/g, '\n');
        const lines = normalized.split('\n');

        let defines = [];

        if (dedupe.checked) {
          const collapsed = [];
          let lastBlank = false;
          for (const line of lines) {
            const trimmed = line.trim();
            const isBlank = trimmed === '' || trimmed === '#pragma once';
            if (trimmed.startsWith('#define ')) {
              const parts = trimmed.split(/\s+/);
              if (parts.length > 1) defines.push(parts[1]);
            }
            if (isBlank) {
              if (!lastBlank) collapsed.push('');
              lastBlank = true;
            } else {
              collapsed.push(line);
              lastBlank = false;
            }
          }
          const filtered = collapsed.filter(l => l.trim() !== '' && l.trim() !== '#pragma once');
          ta.value = filtered.join('\n');
        } else {
          const filtered = [];
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('#define ')) {
              const parts = trimmed.split(/\s+/);
              if (parts.length > 1) defines.push(parts[1]);
            }
            if (trimmed !== '' && trimmed !== '#pragma once') {
              filtered.push(line);
            }
          }
          ta.value = filtered.join('\n');
        }

        // Update define list
        defineList.innerHTML = '';
        defines.forEach(d => {
          const li = document.createElement('li');
          li.textContent = `"define " "${d}" TOSTRING(${d})`;
          defineList.appendChild(li);
        });
      }

      btn.addEventListener('click', removeEmptyLines);
      clearBtn.addEventListener('click', () => { ta.value = ''; ta.focus(); defineList.innerHTML=''; });
      copyBtn.addEventListener('click', async () => {
        try { await navigator.clipboard.writeText(ta.value); copyBtn.textContent = 'Copied!'; setTimeout(() => copyBtn.textContent = 'Copy', 1200); }
        catch (_) { /* ignore */ }
      });

      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          removeEmptyLines();
        }
      });
    })();
  </script>
</body>
</html>
