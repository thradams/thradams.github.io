<!DOCTYPE html
   PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
   <title>Thiago's website</title>
   <link href="trastyle.css" type="text/css" rel="stylesheet" />
   <link rel="alternate" type="application/rss+xml" title="RSS" href="http://wwww.thradams/codeblog/rss.xml" />
</head>

<body>
   <div class="pageheader">

      <h2>Thiago R. Adams website</h2>
      <p>
         <a class="linkbox" href="index.htm">HOME</a>
         <a class="linkbox" href="codeblog.htm">CODE-BLOG</a>
         <a class="linkbox" href="about.htm">ABOUT</a>
         <br />
      </p>
   </div>

   <article>
  
      <!-- Page content begin -->
<h2>gc - Simple class to detect memory leaks</h2>
<p>24 December 2004</p>


<p>Use this small class to detected memory leaks in your application. To use it just derive your class from the gc class. If any object is still alive in the end of your application, the method OnMemoryLeak will be called.</p>

<p>Generally I use an assert(false) to customize the OnMemoryLeak method.</p>

<pre>

<span class="keyword">#ifndef</span> __GC_H__
<span class="keyword">#define</span> __GC_H__

<span class="keyword">#ifdef</span> _DEBUG

<span class="keyword">#include</span> &lt;<span class="keyword2">vector</span>&gt;
<span class="keyword">#include</span> &lt;algorithm&gt;
<span class="keyword">#include</span> &lt;functional&gt;
<span class="keyword">#include</span> &lt;typeinfo&gt;

<span class="keyword">class</span> gc
{
    <span class="keyword">struct</span> gcList : <span class="keyword">public</span> std::<span class="keyword2">vector</span>&lt;gc*&gt;
    {
        ~gcList()
        {
            std::for_each(begin(), end(), std::mem_fun(&amp;OnMemoryLeak));
        }
    };

    <span class="keyword">static</span> gcList&amp; GCList()
    {
        <span class="keyword">static</span> gcList vec;
        <span class="keyword">return</span> vec;
    }

  <span class="keyword">void</span> OnMemoryLeak(<span class="keyword">void</span>)
  {
     <span class="keyword">const</span> <span class="keyword">char</span> *leak_in = <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name();
     <span class="comment">//do something here :
</span>  }

<span class="keyword">protected</span>:
  gc()
  {
    GCList().push_back(<span class="keyword">this</span>);
  }

  <span class="keyword">virtual</span> ~gc() {
      std::<span class="keyword2">vector</span>&lt;gc*&gt;::iterator it = std::find(GCList().begin(), GCList().end(), <span class="keyword">this</span>);
      <span class="keyword">if</span> (it != GCList().end())
         GCList().erase(it);
  }
};

<span class="keyword">#else</span>

<span class="comment">// it does nothing in releas
</span><span class="keyword">class</span> gc {};

<span class="keyword">#endif</span>


<span class="keyword">#endif</span> <span class="comment">//__GC_H_
</span></pre>



<!-- Page content end --> 
</article> 
 
</body> 
</html>  